{
  "generated_date": "2025-08-24",
  "generated_timestamp": "2025-08-24T00:24:04.627379",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10248,
  "game_filename": "2025-08-24.js",
  "game_size_bytes": 31184,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Educational Math Game: \"Sparky's Power-Up\"\n  // Ages 7-9. Theme: Electricity. Math focus: addition (combine sparks to match bulb targets).\n  // Renders entirely inside element with ID \"game-of-the-day-stage\".\n  // All visuals drawn on a 720x480 canvas, all sounds generated with Web Audio API.\n  // Accessible via keyboard, includes aria-live status updates, and error handling.\n\n  // Constants\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const BG_COLOR = '#e8f6ff';\n  const SPARK_COLORS = ['#ffdd57', '#ffd1a9', '#ff9aa2', '#c6f6d5', '#d0f0ff'];\n  const BULB_COLOR = '#fff7c0';\n  const MAX_SPARKS = 6;\n  const LEVELS = [\n    { bulbs: [5, 7, 6] },\n    { bulbs: [8, 9, 5] },\n    { bulbs: [10, 7, 8] }\n  ];\n\n  // Game references\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = '';\n  container.style.width = WIDTH + 'px';\n  container.style.height = HEIGHT + 'px';\n  container.style.position = 'relative';\n  container.style.outline = 'none';\n  container.setAttribute('role', 'application');\n  container.setAttribute('aria-label', 'Sparky power-up math game. Use mouse or keyboard to play.');\n  container.tabIndex = 0;\n\n  // Create hidden accessible instructions (screen-reader-friendly)\n  const srInstructions = document.createElement('div');\n  srInstructions.style.position = 'absolute';\n  srInstructions.style.left = '-9999px';\n  srInstructions.style.width = '1px';\n  srInstructions.style.height = '1px';\n  srInstructions.style.overflow = 'hidden';\n  srInstructions.setAttribute('aria-live', 'polite');\n  srInstructions.id = 'sparky-aria';\n  srInstructions.textContent =\n    'Welcome to Sparky\\'s Power-Up! Combine numbered sparks to match bulb energy. ' +\n    'Use mouse or touch to drag sparks into bulbs. Keyboard: Tab to focus, arrow keys to move, space to pick up/drop, Q/E to cycle sparks.';\n  container.appendChild(srInstructions);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = 'block';\n  canvas.style.background = BG_COLOR;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Interactive game area. Visuals are decorative; use the game controls described in the instructions.');\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Setup audio context with error handling\n  let audioCtx = null;\n  let audioEnabled = false;\n  function tryCreateAudioContext() {\n    if (audioCtx) return audioCtx;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AudioContext();\n      return audioCtx;\n    } catch (e) {\n      audioCtx = null;\n      console.warn('Web Audio API not supported or blocked:', e);\n      return null;\n    }\n  }\n\n  // Sound utilities\n  function playTone({ freq = 440, duration = 0.25, type = 'sine', volume = 0.12, onended = null }) {\n    const ctx = tryCreateAudioContext();\n    if (!ctx) return;\n    try {\n      const o = ctx.createOscillator();\n      const g = ctx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(ctx.destination);\n      const now = ctx.currentTime;\n      g.gain.cancelScheduledValues(now);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(volume, now + 0.02);\n      o.start(now);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.stop(now + duration + 0.05);\n      o.onended = onended;\n    } catch (e) {\n      console.warn('Audio play error:', e);\n    }\n  }\n\n  function playChord(success = true) {\n    if (!audioEnabled) return;\n    const ctx = tryCreateAudioContext();\n    if (!ctx) return;\n    try {\n      const now = ctx.currentTime;\n      const osc1 = ctx.createOscillator();\n      const osc2 = ctx.createOscillator();\n      const g = ctx.createGain();\n      osc1.type = 'sine';\n      osc2.type = 'triangle';\n      const base = success ? 660 : 220;\n      osc1.frequency.value = base;\n      osc2.frequency.value = base * (success ? 1.5 : 0.5);\n      g.gain.value = 0.0001;\n      osc1.connect(g);\n      osc2.connect(g);\n      g.connect(ctx.destination);\n      g.gain.exponentialRampToValueAtTime(success ? 0.14 : 0.08, now + 0.01);\n      osc1.start(now);\n      osc2.start(now);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + (success ? 0.5 : 0.25));\n      osc1.stop(now + (success ? 0.6 : 0.35));\n      osc2.stop(now + (success ? 0.6 : 0.35));\n    } catch (e) {\n      console.warn('Chord error:', e);\n    }\n  }\n\n  // Gentle background hum (looping subtle noise)\n  let humOsc = null;\n  function startBackgroundHum() {\n    if (!audioEnabled) return;\n    const ctx = tryCreateAudioContext();\n    if (!ctx || humOsc) return;\n    try {\n      humOsc = ctx.createOscillator();\n      const gain = ctx.createGain();\n      humOsc.type = 'sine';\n      humOsc.frequency.value = 80;\n      gain.gain.value = 0.02;\n      humOsc.connect(gain);\n      gain.connect(ctx.destination);\n      humOsc.start();\n    } catch (e) {\n      console.warn('Background hum error:', e);\n    }\n  }\n  function stopBackgroundHum() {\n    if (humOsc) {\n      try {\n        humOsc.stop();\n        humOsc.disconnect();\n      } catch (e) {\n        // ignore\n      }\n      humOsc = null;\n    }\n  }\n\n  // Game classes\n  class Spark {\n    constructor(id, x, y, value, color) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.vx = (Math.random() - 0.5) * 0.6;\n      this.vy = (Math.random() - 0.5) * 0.6;\n      this.radius = 24;\n      this.value = value;\n      this.color = color;\n      this.dragging = false;\n      this.picked = false; // picked by player\n      this.visible = true;\n      this.bounce = Math.random() * Math.PI * 2;\n    }\n\n    draw(ctx) {\n      if (!this.visible) return;\n      // Glow halo\n      ctx.save();\n      ctx.beginPath();\n      const gradient = ctx.createRadialGradient(this.x, this.y, this.radius * 0.2, this.x, this.y, this.radius * 2);\n      gradient.addColorStop(0, this.color);\n      gradient.addColorStop(1, 'rgba(0,0,0,0)');\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.35;\n      ctx.fillRect(this.x - this.radius * 2, this.y - this.radius * 2, this.radius * 4, this.radius * 4);\n      ctx.globalAlpha = 1.0;\n      ctx.restore();\n\n      // Spark shape (lightning bolt)\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      ctx.rotate(Math.sin(this.bounce) * 0.08);\n      ctx.beginPath();\n      ctx.moveTo(-8, -16);\n      ctx.lineTo(4, -4);\n      ctx.lineTo(-2, -4);\n      ctx.lineTo10 = ctx.lineTo; // prevent minifiers, harmless\n      ctx.lineTo(8, 16);\n      ctx.lineTo(-4, 4);\n      ctx.lineTo(2, 4);\n      ctx.closePath();\n      ctx.fillStyle = this.color;\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 2;\n      ctx.fill();\n      ctx.stroke();\n\n      // Number label\n      ctx.fillStyle = '#222';\n      ctx.font = 'bold 16px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(this.value.toString(), 0, 0);\n      if (this.picked) {\n        // outline to indicate selection\n        ctx.beginPath();\n        ctx.arc(0, 0, this.radius + 6, 0, Math.PI * 2);\n        ctx.strokeStyle = '#3b82f6';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n\n    update(dt) {\n      if (!this.visible || this.dragging || this.picked) {\n        // small bobbing even when idle\n        this.bounce += dt * 0.006;\n        this.bounce %= Math.PI * 2;\n        return;\n      }\n      this.x += this.vx * dt * 0.06;\n      this.y += this.vy * dt * 0.06;\n      // boundaries\n      if (this.x < this.radius) { this.x = this.radius; this.vx *= -0.8; }\n      if (this.x > WIDTH - this.radius) { this.x = WIDTH - this.radius; this.vx *= -0.8; }\n      if (this.y < this.radius + 80) { this.y = this.radius + 80; this.vy *= -0.8; }\n      if (this.y > HEIGHT - this.radius) { this.y = HEIGHT - this.radius; this.vy *= -0.8; }\n      // slow down\n      this.vx *= 0.995;\n      this.vy *= 0.995;\n      this.bounce += 0.01;\n    }\n\n    containsPoint(px, py) {\n      const dx = px - this.x;\n      const dy = py - this.y;\n      return dx * dx + dy * dy <= (this.radius * this.radius) * 1.1;\n    }\n  }\n\n  class Bulb {\n    constructor(id, x, y, target) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.radius = 48;\n      this.target = target;\n      this.current = 0;\n      this.lit = false;\n      this.pulse = 0;\n    }\n\n    draw(ctx) {\n      // base bulb\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      // bulb glow if lit\n      if (this.lit) {\n        const glow = ctx.createRadialGradient(0, -8, 10, 0, -8, 120);\n        glow.addColorStop(0, 'rgba(255, 246, 200, 0.9)');\n        glow.addColorStop(1, 'rgba(255, 246, 200, 0.0)');\n        ctx.fillStyle = glow;\n        ctx.beginPath();\n        ctx.arc(0, 0, 90 + Math.sin(this.pulse) * 6, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // bulb body\n      ctx.beginPath();\n      ctx.ellipse(0, -6, this.radius * 0.9, this.radius * 1.1, 0, 0, Math.PI * 2);\n      ctx.fillStyle = BULB_COLOR;\n      ctx.fill();\n      ctx.strokeStyle = '#caa84f';\n      ctx.lineWidth = 3;\n      ctx.stroke();\n\n      // screw base\n      ctx.fillStyle = '#b0b0b0';\n      ctx.fillRect(-18, 28, 36, 18);\n      ctx.strokeRect(-18, 28, 36, 18);\n\n      // face\n      ctx.fillStyle = '#222';\n      ctx.beginPath();\n      ctx.arc(-12, -6, 4, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(8, -6, 4, 0, Math.PI * 2);\n      ctx.fill();\n      if (this.lit) {\n        ctx.beginPath();\n        ctx.arc(-6, 6, 6, 0, Math.PI);\n        ctx.fillStyle = '#222';\n        ctx.fill();\n      } else {\n        ctx.beginPath();\n        ctx.moveTo(-6, 6);\n        ctx.lineTo(6, 6);\n        ctx.strokeStyle = '#222';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n\n      // numbers and progress\n      ctx.fillStyle = '#333';\n      ctx.font = 'bold 16px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(`${this.current} / ${this.target}`, 0, 54);\n\n      // target hint when not met\n      if (!this.lit) {\n        ctx.fillStyle = '#666';\n        ctx.font = '12px sans-serif';\n        ctx.fillText('Need exact match!', 0, 70);\n      } else {\n        ctx.fillStyle = '#2b8a3e';\n        ctx.font = '12px sans-serif';\n        ctx.fillText('Powered!', 0, 70);\n      }\n\n      ctx.restore();\n    }\n\n    containsPoint(px, py) {\n      const dx = px - this.x;\n      const dy = py - this.y;\n      // elliptical hit region\n      return (dx * dx) / ((this.radius * 0.9) ** 2) + (dy * dy) / ((this.radius * 1.1) ** 2) <= 1;\n    }\n\n    addSparkValue(val) {\n      if (this.lit) return { success: false, reason: 'already lit' };\n      this.current += val;\n      if (this.current === this.target) {\n        this.lit = true;\n        this.pulse = 0;\n        return { success: true, exact: true };\n      } else if (this.current > this.target) {\n        return { success: false, reason: 'too much' };\n      } else {\n        return { success: true, exact: false };\n      }\n    }\n\n    update(dt) {\n      if (this.lit) {\n        this.pulse += dt * 0.01;\n      }\n    }\n  }\n\n  // Game state\n  let sparks = [];\n  let bulbs = [];\n  let selectedIndex = 0;\n  let heldSpark = null;\n  let levelIndex = 0;\n  let score = 0;\n  let lastTime = performance.now();\n  let mouseDown = false;\n  let hoverSpark = null;\n  let tooltip = '';\n  let showStartOverlay = true;\n  let particles = [];\n\n  // Initialize level\n  function initLevel(index) {\n    sparks = [];\n    bulbs = [];\n    selectedIndex = 0;\n    heldSpark = null;\n    tooltip = '';\n    const level = LEVELS[index % LEVELS.length];\n    // place bulbs evenly\n    const bulbPositions = [\n      { x: 140, y: 170 },\n      { x: 360, y: 170 },\n      { x: 580, y: 170 }\n    ];\n    for (let i = 0; i < level.bulbs.length; i++) {\n      const b = new Bulb(i, bulbPositions[i].x, bulbPositions[i].y, level.bulbs[i]);\n      bulbs.push(b);\n    }\n    // create sparks with random values that can solve bulbs (ensure solvable)\n    // Strategy: generate some sparks that sum to each bulb target, plus extras.\n    let created = 0;\n    for (let i = 0; i < bulbs.length; i++) {\n      const t = bulbs[i].target;\n      // split into 2 values for complexity\n      const a = Math.max(1, Math.floor((Math.random() * (t - 1)) + 1));\n      const b = t - a;\n      sparks.push(new Spark(created++, 140 + i * 160, 320 + Math.random() * 80, a, SPARK_COLORS[created % SPARK_COLORS.length]));\n      sparks.push(new Spark(created++, 140 + i * 160 + 30, 320 + Math.random() * 80, b, SPARK_COLORS[created % SPARK_COLORS.length]));\n    }\n    // add some random filler sparks\n    while (created < MAX_SPARKS) {\n      const val = 1 + Math.floor(Math.random() * 9);\n      sparks.push(new Spark(created++, 120 + Math.random() * 480, 320 + Math.random() * 120, val, SPARK_COLORS[created % SPARK_COLORS.length]));\n    }\n    // ensure indices safe\n    selectedIndex = 0;\n    score = 0;\n    particles = createParticles();\n    updateAria('New level loaded. Combine sparks to match bulb energy numbers.');\n  }\n\n  // Particles for wacky background\n  function createParticles() {\n    const arr = [];\n    for (let i = 0; i < 20; i++) {\n      arr.push({\n        x: Math.random() * WIDTH,\n        y: Math.random() * HEIGHT,\n        r: 6 + Math.random() * 18,\n        vx: (Math.random() - 0.5) * 0.1,\n        vy: (Math.random() - 0.5) * 0.1,\n        hue: 180 + Math.random() * 80\n      });\n    }\n    return arr;\n  }\n\n  // Drawing functions\n  function drawBackground(ctx) {\n    // soft gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#f6fbff');\n    g.addColorStop(1, '#e8f6ff');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // wavy wires and coils\n    ctx.save();\n    try {\n      for (let i = 0; i < 6; i++) {\n        ctx.beginPath();\n        const y = 100 + i * 60;\n        ctx.moveTo(0, y);\n        for (let x = 0; x <= WIDTH; x += 20) {\n          ctx.lineTo(x, y + Math.sin((x * 0.02) + i * 0.8 + performance.now() * 0.001) * 12);\n        }\n        ctx.strokeStyle = `hsla(${200 + i * 10},60%,60%,0.08)`;\n        ctx.lineWidth = 14 - i * 1.6;\n        ctx.stroke();\n      }\n    } catch (e) {\n      console.warn('Background draw error:', e);\n    }\n    ctx.restore();\n\n    // floating particles\n    ctx.save();\n    for (const p of particles) {\n      p.x += p.vx;\n      p.y += p.vy;\n      if (p.x < -50) p.x = WIDTH + 50;\n      if (p.x > WIDTH + 50) p.x = -50;\n      if (p.y < -50) p.y = HEIGHT + 50;\n      if (p.y > HEIGHT + 50) p.y = -50;\n      ctx.beginPath();\n      ctx.fillStyle = `hsla(${p.hue},70%,60%,0.06)`;\n      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function drawTopBar(ctx) {\n    ctx.save();\n    ctx.fillStyle = '#ffffffaa';\n    ctx.fillRect(0, 0, WIDTH, 64);\n    ctx.strokeStyle = '#cde6ff';\n    ctx.strokeRect(0, 0, WIDTH, 64);\n\n    // Title and characters\n    ctx.fillStyle = '#0b2447';\n    ctx.font = 'bold 20px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Sparky\\'s Power-Up: Addition Adventure', 16, 28);\n\n    // Dr. Current micro-portrait (guide)\n    const gx = WIDTH - 160;\n    ctx.save();\n    ctx.translate(gx, 8);\n    // plaque\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0, 4, 150, 52);\n    ctx.strokeStyle = '#c6e6ff';\n    ctx.strokeRect(0, 4, 150, 52);\n    // face\n    ctx.beginPath();\n    ctx.arc(26, 30, 16, 0, Math.PI * 2);\n    ctx.fillStyle = '#ffdca8';\n    ctx.fill();\n    ctx.strokeStyle = '#d6b08a';\n    ctx.stroke();\n    // glasses\n    ctx.strokeStyle = '#444';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(18, 30, 6, 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(34, 30, 6, 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(24, 30);\n    ctx.lineTo(28, 30);\n    ctx.stroke();\n    // name\n    ctx.fillStyle = '#333';\n    ctx.font = '12px sans-serif';\n    ctx.fillText('Dr. Current', 54, 26);\n    ctx.fillStyle = '#666';\n    ctx.font = '11px sans-serif';\n    ctx.fillText('Guide & Spark Expert', 54, 42);\n    ctx.restore();\n\n    // sound indicator (visual cue)\n    ctx.fillStyle = audioEnabled ? '#2b8a3e' : '#b23a3a';\n    ctx.beginPath();\n    ctx.moveTo(WIDTH - 32, 22);\n    ctx.lineTo(WIDTH - 22, 16);\n    ctx.lineTo(WIDTH - 22, 28);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.fillStyle = '#fff';\n    ctx.font = '10px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(audioEnabled ? 'Sound On' : 'Sound Off', WIDTH - 80, 22);\n\n    ctx.restore();\n  }\n\n  function drawInstructions(ctx) {\n    ctx.save();\n    ctx.font = '12px sans-serif';\n    ctx.fillStyle = '#234';\n    ctx.textAlign = 'left';\n    ctx.fillText('Drag numbered sparks into bulbs so the sum equals the bulb\\'s number.', 16, 46);\n    ctx.fillText('Keyboard: Tab focus -> Arrow keys move, Space pick up/drop, Q/E cycle, Enter drop into bulb.', 16, 60);\n    ctx.restore();\n  }\n\n  // Render loop\n  function render(now) {\n    const dt = now - lastTime;\n    lastTime = now;\n    // update\n    for (const s of sparks) s.update(dt);\n    for (const b of bulbs) b.update(dt);\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawBackground(ctx);\n    drawTopBar(ctx);\n    drawInstructions(ctx);\n\n    // draw bulbs\n    for (const b of bulbs) b.draw(ctx);\n\n    // wires from bulbs to bottom area (for charm)\n    ctx.save();\n    ctx.strokeStyle = '#b8d6ff';\n    ctx.lineWidth = 4;\n    for (const b of bulbs) {\n      ctx.beginPath();\n      ctx.moveTo(b.x - 12, b.y + 34);\n      ctx.bezierCurveTo(b.x - 30, b.y + 90, b.x - 200, HEIGHT - 40, 40, HEIGHT - 20);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // draw sparks (z-order: sparks over wires)\n    for (let i = 0; i < sparks.length; i++) {\n      sparks[i].draw(ctx);\n    }\n\n    // HUD - selected spark info\n    ctx.save();\n    ctx.fillStyle = '#0b2447';\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'left';\n    const sel = sparks[selectedIndex];\n    if (sel && sel.visible) {\n      ctx.fillText(`Selected spark: ${sel.value} (use Q/E to cycle)`, 16, HEIGHT - 52);\n    } else {\n      ctx.fillText('No spark selected', 16, HEIGHT - 52);\n    }\n    ctx.fillText(`Score: ${score}`, WIDTH - 120, HEIGHT - 52);\n    ctx.restore();\n\n    // overlay start\n    if (showStartOverlay) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(6,30,55,0.85)';\n      ctx.fillRect(60, 100, WIDTH - 120, HEIGHT - 200);\n      ctx.fillStyle = '#fff';\n      ctx.textAlign = 'center';\n      ctx.font = 'bold 28px sans-serif';\n      ctx.fillText('Sparky\\'s Power-Up!', WIDTH / 2, 160);\n      ctx.font = '16px sans-serif';\n      ctx.fillText('Combine sparks to match bulb energy numbers.', WIDTH / 2, 200);\n      ctx.fillText('Click here or press Enter to begin and enable sound (optional).', WIDTH / 2, 240);\n      ctx.font = '12px sans-serif';\n      ctx.fillText('Mouse/touch: drag and drop. Keyboard: Tab -> arrow keys, space, Q/E, Enter', WIDTH / 2, 270);\n      ctx.restore();\n    }\n\n    // tooltip\n    if (tooltip) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.strokeStyle = '#9cc7ff';\n      ctx.fillRect(16, HEIGHT - 110, 220, 36);\n      ctx.strokeRect(16, HEIGHT - 110, 220, 36);\n      ctx.fillStyle = '#022';\n      ctx.font = '12px sans-serif';\n      ctx.textAlign = 'left';\n      ctx.fillText(tooltip, 26, HEIGHT - 86);\n      ctx.restore();\n    }\n\n    requestAnimationFrame(render);\n  }\n\n  // Start the render loop\n  requestAnimationFrame(render);\n\n  // Interaction handling\n  function screenToCanvas(evt) {\n    const rect = canvas.getBoundingClientRect();\n    const x = (evt.clientX !== undefined ? evt.clientX : evt.touches[0].clientX) - rect.left;\n    const y = (evt.clientY !== undefined ? evt.clientY : evt.touches[0].clientY) - rect.top;\n    return { x, y };\n  }\n\n  canvas.addEventListener('mousedown', (evt) => {\n    container.focus();\n    mouseDown = true;\n    const p = screenToCanvas(evt);\n    // start audio context on first user gesture if possible\n    if (!audioCtx) {\n      tryCreateAudioContext();\n    }\n    // If start overlay visible, clicking starts the game\n    if (showStartOverlay) {\n      showStartOverlay = false;\n      audioEnabled = true;\n      // resume context if needed\n      if (audioCtx && audioCtx.state === 'suspended') {\n        audioCtx.resume().then(() => {\n          startBackgroundHum();\n        }).catch(() => {});\n      } else {\n        startBackgroundHum();\n      }\n      updateAria('Game started. Use mouse or keyboard to play.');\n      initLevel(levelIndex);\n      return;\n    }\n    // hit test sparks (topmost first)\n    for (let i = sparks.length - 1; i >= 0; i--) {\n      if (sparks[i].visible && sparks[i].containsPoint(p.x, p.y)) {\n        heldSpark = sparks[i];\n        heldSpark.dragging = true;\n        heldSpark.picked = true;\n        tooltip = 'Drag to a bulb to add energy. Release to drop.';\n        updateAria(`Picked spark ${heldSpark.value}. Drag it into a bulb.`);\n        break;\n      }\n    }\n  });\n\n  canvas.addEventListener('mousemove', (evt) => {\n    const p = screenToCanvas(evt);\n    hoverSpark = null;\n    for (let i = sparks.length - 1; i >= 0; i--) {\n      if (sparks[i].visible && sparks[i].containsPoint(p.x, p.y)) {\n        hoverSpark = sparks[i];\n        break;\n      }\n    }\n    if (heldSpark && heldSpark.dragging) {\n      heldSpark.x = p.x;\n      heldSpark.y = p.y;\n    }\n  });\n\n  canvas.addEventListener('mouseup', (evt) => {\n    mouseDown = false;\n    if (heldSpark) {\n      heldSpark.dragging = false;\n      // check if over a bulb\n      const p = screenToCanvas(evt);\n      let droppedOnBulb = null;\n      for (const b of bulbs) {\n        if (b.containsPoint(p.x, p.y)) {\n          droppedOnBulb = b;\n          break;\n        }\n      }\n      if (droppedOnBulb) {\n        const result = droppedOnBulb.addSparkValue(heldSpark.value);\n        if (result.success && result.exact) {\n          // success: remove spark, light bulb, play sound\n          heldSpark.visible = false;\n          score += 10;\n          playChord(true);\n          updateAria(`Great! Bulb ${droppedOnBulb.id + 1} is powered. Score ${score}.`);\n          checkLevelComplete();\n        } else if (result.success && !result.exact) {\n          // partial add: hide spark, keep bulb unlit\n          heldSpark.visible = false;\n          score += 2;\n          playTone({ freq: 560, duration: 0.14, type: 'sine', volume: 0.09 });\n          updateAria(`Added ${heldSpark.value} to bulb ${droppedOnBulb.id + 1}. Current ${droppedOnBulb.current} of ${droppedOnBulb.target}.`);\n        } else {\n          // wrong (over)\n          // revert spark to visible position, flash bulb\n          playChord(false);\n          // subtract value (revert) to keep game fair\n          droppedOnBulb.current -= heldSpark.value;\n          if (droppedOnBulb.current < 0) droppedOnBulb.current = 0;\n          updateAria('Oops! Too much energy. Try a smaller spark.');\n          // small visual shake\n          // push spark away\n          heldSpark.x = 360;\n          heldSpark.y = 360;\n        }\n      } else {\n        // dropped on ground - reposition slightly\n        heldSpark.x += Math.random() * 20 - 10;\n        heldSpark.y += Math.random() * 20 - 10;\n        updateAria('Spark dropped. Try again.');\n      }\n      // unpick\n      heldSpark.picked = false;\n      heldSpark = null;\n      tooltip = '';\n    } else {\n      // if click empty space and overlay hidden, maybe pick a nearest spark\n      if (!showStartOverlay) {\n        const p = screenToCanvas(evt);\n        for (let i = 0; i < sparks.length; i++) {\n          if (sparks[i].visible && sparks[i].containsPoint(p.x, p.y)) {\n            selectedIndex = i;\n            updateAria(`Selected spark ${sparks[selectedIndex].value}.`);\n            break;\n          }\n        }\n      }\n    }\n  });\n\n  // Touch events for mobile\n  canvas.addEventListener('touchstart', (evt) => {\n    evt.preventDefault();\n    const touch = evt.touches[0];\n    const fakeEvt = { clientX: touch.clientX, clientY: touch.clientY };\n    canvas.dispatchEvent(new MouseEvent('mousedown', fakeEvt));\n  }, { passive: false });\n\n  canvas.addEventListener('touchmove', (evt) => {\n    evt.preventDefault();\n    const touch = evt.touches[0];\n    const fakeEvt = { clientX: touch.clientX, clientY: touch.clientY };\n    canvas.dispatchEvent(new MouseEvent('mousemove', fakeEvt));\n  }, { passive: false });\n\n  canvas.addEventListener('touchend', (evt) => {\n    evt.preventDefault();\n    canvas.dispatchEvent(new MouseEvent('mouseup', {}));\n  }, { passive: false });\n\n  // Keyboard controls\n  container.addEventListener('keydown', (evt) => {\n    if (showStartOverlay && (evt.key === 'Enter' || evt.key === ' ')) {\n      showStartOverlay = false;\n      audioEnabled = true;\n      if (audioCtx && audioCtx.state === 'suspended') {\n        audioCtx.resume().then(() => startBackgroundHum()).catch(() => {});\n      }\n      initLevel(levelIndex);\n      return;\n    }\n    if (showStartOverlay) return;\n    const key = evt.key.toLowerCase();\n    const sel = sparks[selectedIndex];\n    if (key === 'q') {\n      // cycle left\n      for (let i = 1; i <= sparks.length; i++) {\n        const idx = (selectedIndex - i + sparks.length) % sparks.length;\n        if (sparks[idx].visible) { selectedIndex = idx; break; }\n      }\n      updateAria(`Selected spark ${sparks[selectedIndex].value}.`);\n      evt.preventDefault();\n    } else if (key === 'e') {\n      // cycle right\n      for (let i = 1; i <= sparks.length; i++) {\n        const idx = (selectedIndex + i) % sparks.length;\n        if (sparks[idx].visible) { selectedIndex = idx; break; }\n      }\n      updateAria(`Selected spark ${sparks[selectedIndex].value}.`);\n      evt.preventDefault();\n    } else if (key === ' ' || key === 'enter') {\n      // pick up or drop\n      if (heldSpark) {\n        // drop into nearest bulb if intersects\n        let droppedOnBulb = null;\n        for (const b of bulbs) {\n          if (b.containsPoint(heldSpark.x, heldSpark.y)) {\n            droppedOnBulb = b;\n            break;\n          }\n        }\n        if (droppedOnBulb) {\n          const result = droppedOnBulb.addSparkValue(heldSpark.value);\n          if (result.success && result.exact) {\n            heldSpark.visible = false;\n            score += 10;\n            playChord(true);\n            updateAria(`Bulb ${droppedOnBulb.id + 1} powered!`);\n            checkLevelComplete();\n          } else if (result.success && !result.exact) {\n            heldSpark.visible = false;\n            score += 2;\n            playTone({ freq: 560, duration: 0.14, type: 'sine', volume: 0.09 });\n            updateAria('Added spark. Keep going.');\n          } else {\n            droppedOnBulb.current -= heldSpark.value;\n            if (droppedOnBulb.current < 0) droppedOnBulb.current = 0;\n            playChord(false);\n            updateAria('Too much energy! Try a different spark.');\n            heldSpark.x = 360;\n            heldSpark.y = 360;\n          }\n        }\n        heldSpark.picked = false;\n        heldSpark.dragging = false;\n        heldSpark = null;\n      } else {\n        // pick up selected\n        if (sel && sel.visible) {\n          heldSpark = sel;\n          heldSpark.picked = true;\n          updateAria(`Picked spark ${heldSpark.value}. Use arrow keys to move.`);\n        } else {\n          updateAria('No spark to pick. Select another.');\n        }\n      }\n      evt.preventDefault();\n      return;\n    } else if (['arrowleft', 'a'].includes(evt.key.toLowerCase())) {\n      if (heldSpark) { heldSpark.x = Math.max(12, heldSpark.x - 12); }\n      else {\n        // cycle selection left\n        for (let i = 1; i <= sparks.length; i++) {\n          const idx = (selectedIndex - i + sparks.length) % sparks.length;\n          if (sparks[idx].visible) { selectedIndex = idx; break; }\n        }\n      }\n      evt.preventDefault();\n    } else if (['arrowright', 'd'].includes(evt.key.toLowerCase())) {\n      if (heldSpark) { heldSpark.x = Math.min(WIDTH - 12, heldSpark.x + 12); }\n      else {\n        for (let i = 1; i <= sparks.length; i++) {\n          const idx = (selectedIndex + i) % sparks.length;\n          if (sparks[idx].visible) { selectedIndex = idx; break; }\n        }\n      }\n      evt.preventDefault();\n    } else if (['arrowup', 'w'].includes(evt.key.toLowerCase())) {\n      if (heldSpark) { heldSpark.y = Math.max(80, heldSpark.y - 12); }\n      evt.preventDefault();\n    } else if (['arrowdown', 's'].includes(evt.key.toLowerCase())) {\n      if (heldSpark) { heldSpark.y = Math.min(HEIGHT - 12, heldSpark.y + 12); }\n      evt.preventDefault();\n    } else if (key === 'tab') {\n      // allow tabbing through for screen readers: cycle selection\n      for (let i = 1; i <= sparks.length; i++) {\n        const idx = (selectedIndex + i) % sparks.length;\n        if (sparks[idx].visible) { selectedIndex = idx; break; }\n      }\n      updateAria(`Selected spark ${sparks[selectedIndex].value}.`);\n      evt.preventDefault();\n    }\n  });\n\n  // Update aria live region\n  function updateAria(text) {\n    try {\n      srInstructions.textContent = text;\n    } catch (e) {\n      console.warn('ARIA update failed', e);\n    }\n  }\n\n  // Check level completion\n  function checkLevelComplete() {\n    if (bulbs.every(b => b.lit)) {\n      playChord(true);\n      updateAria('Level complete! Moving to next level.');\n      levelIndex++;\n      // small celebration: spawn particles\n      setTimeout(() => {\n        initLevel(levelIndex);\n      }, 1200);\n    }\n  }\n\n  // Start/Stop audio toggle clickable in canvas\n  canvas.addEventListener('dblclick', (evt) => {\n    // toggle audio\n    if (!audioCtx) tryCreateAudioContext();\n    audioEnabled = !audioEnabled;\n    if (audioEnabled) {\n      if (audioCtx && audioCtx.state === 'suspended') {\n        audioCtx.resume().then(() => startBackgroundHum()).catch(() => {});\n      } else {\n        startBackgroundHum();\n      }\n      updateAria('Sound enabled.');\n    } else {\n      stopBackgroundHum();\n      updateAria('Sound disabled.');\n    }\n  });\n\n  // Initial state: overlay shown, waiting for user\n  showStartOverlay = true;\n  // Provide initial placeholder level data so UI doesn't break\n  initLevel(0);\n\n  // Accessibility: announce focus and basic help when container is focused\n  container.addEventListener('focus', () => {\n    updateAria('Game focused. Press Enter to start. After starting, drag sparks into bulbs or use keyboard controls.');\n  });\n\n  // Error handling: catch global errors in animation and interactions\n  window.addEventListener('error', (e) => {\n    console.error('Game error caught:', e.message, e.error);\n    updateAria('An unexpected error occurred. Please refresh the page.');\n  });\n\n  // Expose a minimal debugging API on container for dev (non-intrusive)\n  container.gameDebug = {\n    toggleSound: () => {\n      audioEnabled = !audioEnabled;\n      if (audioEnabled) {\n        startBackgroundHum();\n      } else {\n        stopBackgroundHum();\n      }\n      return audioEnabled;\n    },\n    getState: () => ({ sparks, bulbs, levelIndex, score })\n  };\n})();\n---\n",
  "improve_response_tokens": 20445,
  "formatted_code": true,
  "formatting_response_tokens": 21785,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}