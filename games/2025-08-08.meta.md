# Game of the Day - 2025-08-08

## Metadata
- **Generated Date:** 2025-08-08
- **Generated Time:** 2025-08-08T00:23:21.985369
- **Model:** gpt-4.1-mini
- **Theme:** open world exploration
- **Game File:** 2025-08-08.js
- **File Size:** 20383 bytes
- **Tokens Used:** 5914

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: open world exploration

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-4.1-mini model with the theme: "open world exploration".

## Files Generated
- `2025-08-08.js` - The playable game
- `2025-08-08.meta.json` - Machine-readable metadata
- `2025-08-08.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 13757

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 16022

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(() => {
  // Strict mode for best practices
  "use strict";

  // Constants for canvas size
  const WIDTH = 720;
  const HEIGHT = 480;

  // Get the container element
  const container = document.getElementById("game-of-the-day-stage");

  if (!container) {
    console.error("Container with ID 'game-of-the-day-stage' not found.");
    return;
  }

  // Clear container and create canvas
  container.innerHTML = "";
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make canvas focusable for keyboard control
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");

  // === Audio Setup ===
  let audioCtx;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  } catch (e) {
    console.error("Web Audio API is not supported in this browser");
  }

  // Sound manager with simple oscillator sounds for feedback
  const SoundManager = (() => {
    const playTone = (freq, duration = 300, type = "sine", volume = 0.2) => {
      if (!audioCtx) return;
      try {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.type = type;
        oscillator.frequency.value = freq;
        gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.start();
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration / 1000);
        oscillator.stop(audioCtx.currentTime + duration / 1000);
      } catch (e) {
        console.warn("Audio play error:", e);
      }
    };

    // Background gentle sound using noise buffer passed through filter
    let bgGainNode;
    let noiseSource;
    const startBackground = () => {
      if (!audioCtx) return;
      try {
        const bufferSize = 2 * audioCtx.sampleRate;
        const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          output[i] = (Math.random() * 2 - 1) * 0.1;
        }
        noiseSource = audioCtx.createBufferSource();
        noiseSource.buffer = noiseBuffer;
        noiseSource.loop = true;

        const filter = audioCtx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.setValueAtTime(400, audioCtx.currentTime);

        bgGainNode = audioCtx.createGain();
        bgGainNode.gain.setValueAtTime(0.07, audioCtx.currentTime);

        noiseSource.connect(filter);
        filter.connect(bgGainNode);
        bgGainNode.connect(audioCtx.destination);
        noiseSource.start();
      } catch (e) {
        console.warn("Background audio error:", e);
      }
    };

    const stopBackground = () => {
      if (noiseSource) {
        noiseSource.stop();
      }
    };

    return {
      playCorrect: () => playTone(523.25, 250, "triangle", 0.3), // C5 triangle wave for correct
      playIncorrect: () => playTone(196, 350, "sawtooth", 0.3), // G3 sawtooth wave for incorrect
      startBackground,
      stopBackground,
    };
  })();

  // === Game Variables ===

  // Exploration math concept: child explores a wacky island collecting numeric treasures.
  // They solve addition problems to unlock paths and reach new areas.

  // Characters - quirky explorer and animal friends
  class Character {
    constructor(name, color, x, y) {
      this.name = name;
      this.color = color;
      this.x = x;
      this.y = y;
      this.radius = 22;
    }
    draw(ctx) {
      // Draw a quirky round body with goofy eyes and smile
      ctx.save();
      ctx.translate(this.x, this.y);
      // Body
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(0, 0, this.radius, this.radius * 1.3, Math.sin(Date.now()/500) * 0.1, 0, 2 * Math.PI);
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(-8, -5, 6, 0, 2 * Math.PI);
      ctx.arc(8, -5, 6, 0, 2 * Math.PI);
      ctx.fill();

      // Pupils
      ctx.fillStyle = "#000";
      const pupilOffsetX = Math.sin(Date.now() / 400) * 2;
      const pupilOffsetY = Math.cos(Date.now() / 400) * 1.5;
      ctx.beginPath();
      ctx.arc(-8 + pupilOffsetX, -5 + pupilOffsetY, 3, 0, 2 * Math.PI);
      ctx.arc(8 + pupilOffsetX, -5 + pupilOffsetY, 3, 0, 2 * Math.PI);
      ctx.fill();

      // Smile
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 10, 12, 0, Math.PI, false);
      ctx.stroke();

      ctx.restore();
    }
  }

  // Friendly island critters with wild colors
  class Critter {
    constructor(name, color, x, y) {
      this.name = name;
      this.color = color;
      this.x = x;
      this.y = y;
      this.size = 16;
      this.wigglePhase = Math.random() * Math.PI * 2;
    }
    update(deltaTime) {
      this.wigglePhase += deltaTime * 0.01;
      this.y += Math.sin(this.wigglePhase) * 0.15;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      // Body is star with wacky eyes
      ctx.fillStyle = this.color;
      const points = 5;
      const outerRadius = this.size;
      const innerRadius = this.size / 2.5;
      ctx.beginPath();
      for (let i = 0; i < points * 2; i++) {
        const r = (i % 2 === 0) ? outerRadius : innerRadius;
        const angle = (Math.PI / points) * i;
        ctx.lineTo(r * Math.cos(angle), r * Math.sin(angle));
      }
      ctx.closePath();
      ctx.fill();

      // Eyes with pupil animation
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(-6, -3, 5, 0, 2 * Math.PI);
      ctx.arc(6, -3, 5, 0, 2 * Math.PI);
      ctx.fill();

      ctx.fillStyle = "#000";
      const pupilXOffset = Math.sin(Date.now() / 300) * 1.5;
      const pupilYOffset = Math.cos(Date.now() / 300) * 1;
      ctx.beginPath();
      ctx.arc(-6 + pupilXOffset, -3 + pupilYOffset, 2.5, 0, 2 * Math.PI);
      ctx.arc(6 + pupilXOffset, -3 + pupilYOffset, 2.5, 0, 2 * Math.PI);
      ctx.fill();

      ctx.restore();
    }
  }

  // Treasure chests contain math problems to unlock
  class Treasure {
    constructor(x, y, a, b) {
      this.x = x;
      this.y = y;
      this.width = 50;
      this.height = 40;
      this.a = a; // number one in addition
      this.b = b; // number two in addition
      this.opened = false;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);

      // Box base
      ctx.fillStyle = this.opened ? "#ffd24d" : "#8b5e3c";
      ctx.strokeStyle = "#533d1a";
      ctx.lineWidth = 3;
      ctx.fillRect(0, 0, this.width, this.height);
      ctx.strokeRect(0, 0, this.width, this.height);

      // Lid
      ctx.fillStyle = this.opened ? "#fffa9e" : "#6b4728";
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(this.width / 2, -this.height / 2);
      ctx.lineTo(this.width, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      if (!this.opened) {
        // Show the math prompt "a + b = ?"
        ctx.fillStyle = "#fff";
        ctx.font = "bold 18px Comic Sans MS, cursive, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`${this.a} + ${this.b} = ?`, this.width / 2, this.height + 20);
      } else {
        ctx.fillStyle = "#553700";
        ctx.font = "bold 22px Comic Sans MS, cursive, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`✔️ ${this.a + this.b}`, this.width / 2, this.height / 2 + 7);
      }

      ctx.restore();
    }

    containsPoint(px, py) {
      return (
        px >= this.x &&
        px <= this.x + this.width &&
        py >= this.y &&
        py <= this.y + this.height
      );
    }
  }

  // Map with multiple spots
  // Player moves across a colorful "island" with wide grassy fields and wacky plants.

  // Background drawing function - calm pastel colors with quirky trees
  function drawBackground(ctx) {
    // Sky gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    skyGrad.addColorStop(0, "#c8e7f9");
    skyGrad.addColorStop(1, "#90caf9");
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft rolling hills
    const hillColors = ["#97c997", "#81b581", "#6a9f6a"];
    const hillBaseY = HEIGHT - 120;
    for (let i = 0; i < 4; i++) {
      ctx.fillStyle = hillColors[i % hillColors.length];
      ctx.beginPath();
      ctx.moveTo(i * 180 - 90, HEIGHT);
      for (let x = i * 180 - 90; x <= (i + 1) * 180 + 90; x++) {
        const y = hillBaseY + 40 * Math.sin((x / 180 + i) * Math.PI) * 0.6;
        ctx.lineTo(x, y);
      }
      ctx.lineTo((i + 1) * 180 + 90, HEIGHT);
      ctx.closePath();
      ctx.fill();
    }

    // Wacky tree drawing
    function drawWackyTree(x, y, scale) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);

      // Trunk
      ctx.fillStyle = "#6a3e1a";
      ctx.fillRect(-8, 0, 16, 70);

      // Leaves - multiple pastel blob shapes layered
      const leafColors = ["#a1e3a1", "#76d676", "#5ec35e"];
      for (let i = 0; i < 5; i++) {
        ctx.fillStyle = leafColors[i % leafColors.length];
        ctx.beginPath();
        const angle = (i * Math.PI/3);
        const lx = 20 * Math.cos(angle);
        const ly = -30 + 20 * Math.sin(angle);
        ctx.ellipse(lx, ly, 25, 40, angle * 0.9, 0, 2 * Math.PI);
        ctx.fill();
      }
      ctx.restore();
    }

    // Scatter wacky trees
    drawWackyTree(90, HEIGHT - 160, 1.2);
    drawWackyTree(200, HEIGHT - 140, 1.0);
    drawWackyTree(470, HEIGHT - 170, 1.4);
    drawWackyTree(610, HEIGHT - 150, 1.1);
  }

  // === Game State ===
  let lastTimestamp = 0;
  let keysPressed = {};
  let treasures = [];
  let critters = [];
  let player;
  let currentTreasure = null; // treasure currently interacted with
  let mathAnswerInput = ""; // player input for math problem
  let showingInstructions = true;
  let feedbackMessage = "";
  let feedbackTimer = 0;
  let bgMusicStarted = false;

  // UI Colors
  const uiTextColor = "#333";
  const uiBackgroundColor = "rgba(255,255,255,0.8)";

  // Initialize game state
  function init() {
    // Create player in starting position
    player = new Character("Explorer Ella", "#ed7d31", WIDTH / 8, HEIGHT - 160);

    // Add critters (friends)
    critters = [
      new Critter("Ziggy", "#d65f5f", 350, HEIGHT - 120),
      new Critter("Bloop", "#4da6ff", 590, HEIGHT - 130),
      new Critter("Mimi", "#ff90e8", 500, HEIGHT - 110),
    ];

    // Add treasures with simple addition problems - spaced across map
    treasures = [
      new Treasure(250, HEIGHT - 140, 3, 6),
      new Treasure(420, HEIGHT - 130, 5, 4),
      new Treasure(600, HEIGHT - 140, 7, 2),
    ];

    currentTreasure = null;
    mathAnswerInput = "";
    feedbackMessage = "";
    feedbackTimer = 0;
    showingInstructions = true;
  }

  // Draw instructions overlay
  function drawInstructions(ctx) {
    ctx.save();
    ctx.fillStyle = uiBackgroundColor;
    ctx.fillRect(40, 50, WIDTH - 80, HEIGHT - 100);

    ctx.fillStyle = uiTextColor;
    ctx.font = "22px Comic Sans MS, cursive, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Welcome Explorer!", WIDTH / 2, 100);
    ctx.font = "18px Comic Sans MS, cursive, sans-serif";
    ctx.fillText("Help Explorer Ella collect treasures on the island.", WIDTH / 2, 140);
    ctx.fillText("Solve the addition problems to unlock each treasure chest.", WIDTH / 2, 170);
    ctx.fillText("Use arrow keys or WASD to move.", WIDTH / 2, 200);
    ctx.fillText("Press Enter to answer when near a treasure.", WIDTH / 2, 230);
    ctx.fillText("Type your answer, then press Enter to submit.", WIDTH / 2, 260);
    ctx.fillText("Press Escape to close this help.", WIDTH / 2, 290);

    // Visual cue for keyboard (simple)
    ctx.fillStyle = "#666";
    ctx.font = "14px monospace";
    ctx.fillText("↑ W | ↓ S | ← A | → D | Enter | Escape", WIDTH / 2, 320);

    ctx.restore();
  }

  // Draw feedback message box
  function drawFeedback(ctx) {
    if (!feedbackMessage) return;
    ctx.save();
    ctx.fillStyle = uiBackgroundColor;
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 2;
    const boxWidth = 360;
    const boxHeight = 70;
    const x = WIDTH / 2 - boxWidth / 2;
    const y = HEIGHT / 2 - boxHeight / 2;
    ctx.fillRect(x, y, boxWidth, boxHeight);
    ctx.strokeRect(x, y, boxWidth, boxHeight);

    ctx.fillStyle = "#222";
    ctx.font = "bold 22px Comic Sans MS, cursive, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(feedbackMessage, WIDTH / 2, y + boxHeight / 2 + 8);
    ctx.restore();
  }

  // Draw all game elements
  function draw(deltaTime) {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    drawBackground(ctx);

    // Draw treasures first (behind player)
    treasures.forEach(t => t.draw(ctx));

    // Draw friendly critters
    critters.forEach(c => c.draw(ctx));

    // Draw player
    player.draw(ctx);

    // Draw UI panel bottom
    ctx.save();
    ctx.fillStyle = "#e2f4e5";
    ctx.fillRect(0, HEIGHT - 60, WIDTH, 60);

    ctx.fillStyle = "#2d5031";
    ctx.font = "bold 20px Comic Sans MS, cursive, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Explorer Ella", 12, HEIGHT - 30);

    // If interacting with treasure, show problem and input
    if (currentTreasure) {
      ctx.textAlign = "center";

      // Draw input box
      const boxX = WIDTH / 2 - 110;
      const boxY = HEIGHT - 55;
      const boxW = 220;
      const boxH = 45;
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#2d5031";
      ctx.lineWidth = 3;
      ctx.fillRect(boxX, boxY, boxW, boxH);
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      ctx.fillStyle = "#000";
      ctx.font = "20px Comic Sans MS, cursive, sans-serif";
      ctx.fillText(
        `What is ${currentTreasure.a} + ${currentTreasure.b}?`,
        WIDTH / 2,
        boxY + 24
      );

      ctx.font = "bold 26px monospace";
      ctx.fillText(
        mathAnswerInput || "_",
        WIDTH / 2,
        boxY + 43
      );

      // Accessibility info
      ctx.font = "14px Comic Sans MS, cursive, sans-serif";
      ctx.fillStyle = "#444";
      ctx.fillText(
        "Type answer, press Enter to submit, Esc to cancel",
        WIDTH/2,
        boxY + boxH + 18
      );
    } else {
      ctx.font = "16px Comic Sans MS, cursive, sans-serif";
      ctx.fillText("Move near a treasure and press Enter to solve the addition problem!", WIDTH/2, HEIGHT - 30);
      ctx.textAlign = "right";
      ctx.fillText("Press H for help", WIDTH - 12, HEIGHT - 30);
    }

    ctx.restore();

    // Draw feedback message if shown
    drawFeedback(ctx);

    // Draw audio visual cue (simple speaker icon)
    ctx.save();
    ctx.fillStyle = "#2d5031";
    ctx.font = "20px monospace";
    ctx.textAlign = "right";
    ctx.fillText("🎵", WIDTH - 12, 28);
    ctx.restore();

    // If showing instructions overlay
    if (showingInstructions) {
      drawInstructions(ctx);
    }
  }

  // === Input Handling ===
  canvas.addEventListener("keydown", (e) => {
    e.preventDefault();
    const key = e.key.toLowerCase();
    if (showingInstructions) {
      // Close instructions on Escape or Enter
      if (key === "escape" || key === "enter") {
        showingInstructions = false;
      }
      return;
    }

    if (currentTreasure) {
      // Currently typing an answer
      if (key === "escape") {
        // Cancel input
        currentTreasure = null;
        mathAnswerInput = "";
        feedbackMessage = "Answer cancelled";
        feedbackTimer = Date.now();
      } else if (key === "enter") {
        // Submit answer
        if (mathAnswerInput.length === 0) {
          feedbackMessage = "Please type an answer before submitting.";
          feedbackTimer = Date.now();
        } else {
          const playerAnswer = parseInt(mathAnswerInput);
          if (playerAnswer === currentTreasure.a + currentTreasure.b) {
            // Correct
            currentTreasure.opened = true;
            feedbackMessage = "Correct! Treasure unlocked!";
            SoundManager.playCorrect();
            currentTreasure = null;
            mathAnswerInput = "";
          } else {
            // Incorrect
            feedbackMessage = "Oops! Try again.";
            SoundManager.playIncorrect();
            mathAnswerInput = "";
          }
          feedbackTimer = Date.now();
        }
      } else if (/^[0-9]$/.test(key)) {
        if (mathAnswerInput.length < 3) {
          mathAnswerInput += key;
        }
      } else if (key === "backspace") {
        mathAnswerInput = mathAnswerInput.slice(0, -1);
      }
      return;
    }

    // Movement keys
    if (key === "arrowleft" || key === "a") keysPressed.left = true;
    if (key === "arrowright" || key === "d") keysPressed.right = true;
    if (key === "arrowup" || key === "w") keysPressed.up = true;
    if (key === "arrowdown" || key === "s") keysPressed.down = true;

    // Interact with treasure - Enter key
    if (key === "enter") {
      // See if near any unopened treasure
      let found = false;
      treasures.forEach(t => {
        if (!t.opened) {
          const distX = player.x - (t.x + t.width / 2);
          const distY = player.y - (t.y + t.height / 2);
          const dist = Math.sqrt(distX * distX + distY * distY);
          if (dist < 60) {
            currentTreasure = t;
            mathAnswerInput = "";
            feedbackMessage = "";
            found = true;
          }
        }
      });
      if (!found) {
        feedbackMessage = "No treasure nearby to open.";
        feedbackTimer = Date.now();
      }
    }

    // Show instructions
    if (key === "h") {
      showingInstructions = true;
    }
  });

  canvas.addEventListener("keyup", (e) => {
    const key = e.key.toLowerCase();
    if (key === "arrowleft" || key === "a") keysPressed.left = false;
    if (key === "arrowright" || key === "d") keysPressed.right = false;
    if (key === "arrowup" || key === "w") keysPressed.up = false;
    if (key === "arrowdown" || key === "s") keysPressed.down = false;
  });

  // For accessibility, allow canvas to be focused by clicking
  canvas.addEventListener("click", () => {
    canvas.focus();
  });

  // === Game Update ===
  function update(deltaTime) {
    if (showingInstructions) {
      // Don't update gameplay if showing instructions
      if (!bgMusicStarted) {
        SoundManager.startBackground();
        bgMusicStarted = true;
      }
      return;
    }

    if (!bgMusicStarted) {
      SoundManager.startBackground();
      bgMusicStarted = true;
    }

    // Update critters (wiggle)
    critters.forEach(c => c.update(deltaTime));

    // Chase movement only if not answering math
    if (!currentTreasure) {
      let speed = 120; // pixels per second
      let dx = 0;
      let dy = 0;
      if (keysPressed.left) dx -= 1;
      if (keysPressed.right) dx += 1;
      if (keysPressed.up) dy -= 1;
      if (keysPressed.down) dy += 1;

      if (dx !== 0 || dy !== 0) {
        // Normalize diagonal movement speed
        const length = Math.sqrt(dx * dx + dy * dy);
        dx /= length;
        dy /= length;
      }

      player.x += dx * speed * (deltaTime / 1000);
      player.y += dy * speed * (deltaTime / 1000);

      // Boundary clamp
      player.x = Math.min(Math.max(player.radius, player.x), WIDTH - player.radius);
      player.y = Math.min(Math.max(player.radius + 25, player.y), HEIGHT - player.radius - 50);
    }

    // Feedback message timeout
    if (feedbackMessage) {
      if (Date.now() - feedbackTimer > 3000) {
        feedbackMessage = "";
      }
    }
  }

  // === Main Game Loop ===
  function gameLoop(timestamp = 0) {
    if (!lastTimestamp) lastTimestamp = timestamp;
    const deltaTime = timestamp - lastTimestamp;
    lastTimestamp = timestamp;

    update(deltaTime);
    draw(deltaTime);

    window.requestAnimationFrame(gameLoop);
  }

  // Initialize and start game
  init();
  gameLoop();

  // Accessibility focus instructions for screen readers
  if (container) {
    container.setAttribute("role", "application");
    container.setAttribute("aria-label", "Math exploration game: Move Explorer Ella using arrow keys or WASD. Approach treasure chests and press Enter to solve addition problems.");
  }
})();
---

