{
  "generated_date": "2025-08-23",
  "generated_timestamp": "2025-08-23T00:21:08.651108",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9329,
  "game_filename": "2025-08-23.js",
  "game_size_bytes": 25561,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Electricity Math Game for ages 7-9\n// Renders inside element with id \"game-of-the-day-stage\"\n// Canvas 720x480, all visuals drawn with canvas, sounds generated with Web Audio API\n// Keyboard & mouse/touch accessible, audio initialization with error handling\n\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container #game-of-the-day-stage not found.');\n    return;\n  }\n\n  // Clear and prepare container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Electric addition game. Use left and right arrow keys to move Spark and catch the correct falling number to power the bulb. Press S to toggle sound.');\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.style.display = 'block';\n  canvas.style.margin = '0 auto';\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // Audio variables\n  let audioCtx = null;\n  let masterGain = null;\n  let bgOsc = null;\n  let soundEnabled = false;\n  let audioAllowed = false;\n  let audioError = null;\n\n  function initAudio() {\n    if (audioCtx) return;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) {\n        throw new Error('Web Audio API not supported.');\n      }\n      audioCtx = new AC();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.18;\n      masterGain.connect(audioCtx.destination);\n\n      // Gentle hum background\n      bgOsc = audioCtx.createOscillator();\n      const bgGain = audioCtx.createGain();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 60; // low hum\n      bgGain.gain.value = 0.03;\n      bgOsc.connect(bgGain);\n      bgGain.connect(masterGain);\n      bgOsc.start();\n\n      audioAllowed = true;\n      soundEnabled = true;\n    } catch (err) {\n      console.warn('Audio initialization failed:', err);\n      audioError = err;\n      audioCtx = null;\n      soundEnabled = false;\n      audioAllowed = false;\n    }\n  }\n\n  // Play short sound effects using WebAudio\n  function playCorrect() {\n    if (!audioAllowed || !soundEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = 'triangle';\n      o.frequency.setValueAtTime(880, audioCtx.currentTime);\n      o.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.12);\n      g.gain.value = 0.001;\n      g.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.35);\n      o.connect(g);\n      g.connect(masterGain);\n      o.start();\n      o.stop(audioCtx.currentTime + 0.4);\n    } catch (err) {\n      console.warn('playCorrect error', err);\n    }\n  }\n\n  function playIncorrect() {\n    if (!audioAllowed || !soundEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const f = audioCtx.createBiquadFilter();\n      const g = audioCtx.createGain();\n      o.type = 'square';\n      o.frequency.value = 160;\n      f.type = 'highpass';\n      f.frequency.value = 600;\n      g.gain.value = 0.0001;\n      g.gain.exponentialRampToValueAtTime(0.08, audioCtx.currentTime + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.25);\n      o.connect(f);\n      f.connect(g);\n      g.connect(masterGain);\n      o.start();\n      o.stop(audioCtx.currentTime + 0.28);\n    } catch (err) {\n      console.warn('playIncorrect error', err);\n    }\n  }\n\n  function playZap() {\n    if (!audioAllowed || !soundEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = 'sawtooth';\n      o.frequency.setValueAtTime(1200, audioCtx.currentTime);\n      o.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.07);\n      g.gain.value = 0.001;\n      g.gain.exponentialRampToValueAtTime(0.14, audioCtx.currentTime + 0.005);\n      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.12);\n      o.connect(g);\n      g.connect(masterGain);\n      o.start();\n      o.stop(audioCtx.currentTime + 0.12);\n    } catch (err) {\n      console.warn('playZap error', err);\n    }\n  }\n\n  // Accessibility visuals: show when sound is off/on via icon\n  function drawSoundIcon(x, y) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = 'rgba(255,255,255,0.12)';\n    ctx.fillRect(-20, -16, 40, 32);\n    ctx.strokeStyle = '#222';\n    ctx.lineWidth = 2;\n    ctx.fillStyle = '#FFDD57';\n    // Speaker\n    ctx.beginPath();\n    ctx.moveTo(-14, -8);\n    ctx.lineTo(-6, -8);\n    ctx.lineTo(-2, -12);\n    ctx.lineTo(-2, 12);\n    ctx.lineTo(-6, 8);\n    ctx.lineTo(-14, 8);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    // Waves or X\n    ctx.strokeStyle = '#222';\n    ctx.lineWidth = 2;\n    if (soundEnabled) {\n      ctx.beginPath();\n      ctx.arc(6, 0, 8, -0.6, 0.6);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(6, 0, 12, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      ctx.beginPath();\n      ctx.moveTo(6, -8);\n      ctx.lineTo(14, 8);\n      ctx.moveTo(14, -8);\n      ctx.lineTo(6, 8);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Game state\n  const player = {\n    x: WIDTH / 2,\n    y: HEIGHT - 90,\n    w: 60,\n    h: 50,\n    vx: 0,\n    speed: 3.8,\n    color: '#FF7BAC',\n    bob: 0,\n    name: 'Spark the Squirrel'\n  };\n\n  let problemsSolved = 0;\n  let score = 0;\n  let lives = 3;\n  let level = 1;\n  let timeElapsed = 0;\n  let lastSpawn = 0;\n  let spawnInterval = 1400; // ms\n  let electrons = []; // falling numbers\n  let particles = []; // visual sparks\n\n  function randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Current math problem (addition or subtraction)\n  let currentProblem = generateProblem(level);\n\n  function generateProblem(lvl) {\n    // For ages 7-9, primarily add/sub within 20. Level increases size.\n    const op = Math.random() < 0.6 ? '+' : '-';\n    const max = Math.min(20 + lvl * 3, 40);\n    let a = randomInt(1, Math.max(1, Math.floor(max * 0.6)));\n    let b = randomInt(1, Math.max(1, Math.floor(max * 0.6)));\n    if (op === '-' && a < b) [a, b] = [b, a];\n    const solution = op === '+' ? a + b : a - b;\n    return { a, b, op, solution };\n  }\n\n  // Spawn electrons with numbers around current solution\n  function spawnElectron() {\n    // Determine number of spawned per wave depends on level\n    const variantCount = Math.min(5 + level, 8);\n    // Create one correct and several wrong ones\n    const correctIndex = randomInt(0, variantCount - 1);\n    const startX = 60;\n    const endX = WIDTH - 60;\n    for (let i = 0; i < variantCount; i++) {\n      const x = startX + ((endX - startX) * i) / (variantCount - 1);\n      const jitter = randomInt(-30, 30);\n      const value =\n        i === correctIndex\n          ? currentProblem.solution\n          : currentProblem.solution + randomInt(-6 - level, 6 + level);\n      const e = {\n        id: Math.random().toString(36).slice(2),\n        x: Math.max(32, Math.min(WIDTH - 32, x + jitter)),\n        y: -randomInt(10, 90),\n        vy: 1.1 + Math.random() * 0.6 + level * 0.12,\n        value,\n        radius: 24 + (Math.random() * 8 - 4),\n        wobble: Math.random() * Math.PI * 2,\n        color: value === currentProblem.solution ? '#6EE7B7' : '#FFD19A'\n      };\n      electrons.push(e);\n    }\n  }\n\n  // Keyboard controls\n  const keys = {};\n  window.addEventListener('keydown', (e) => {\n    if (e.repeat) return;\n    keys[e.key] = true;\n    if (!audioAllowed && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ' || e.key === 's' || e.key === 'S')) {\n      // Try to initialize audio on first gesture\n      try {\n        initAudio();\n      } catch (err) {\n        // ignore\n      }\n    }\n    if ((e.key === 's' || e.key === 'S')) {\n      // Toggle sound\n      if (!audioAllowed) {\n        initAudio();\n      } else {\n        soundEnabled = !soundEnabled;\n      }\n    }\n  });\n  window.addEventListener('keyup', (e) => {\n    keys[e.key] = false;\n  });\n\n  // Mouse / touch controls: tap left/right half to move\n  canvas.addEventListener('mousedown', (e) => {\n    const r = canvas.getBoundingClientRect();\n    const cx = e.clientX - r.left;\n    if (!audioAllowed) {\n      initAudio();\n    }\n    if (cx < WIDTH / 2) {\n      keys.ArrowLeft = true;\n      setTimeout(() => (keys.ArrowLeft = false), 180);\n    } else {\n      keys.ArrowRight = true;\n      setTimeout(() => (keys.ArrowRight = false), 180);\n    }\n  });\n\n  canvas.addEventListener('touchstart', (e) => {\n    e.preventDefault();\n    const touch = e.touches[0];\n    const r = canvas.getBoundingClientRect();\n    const cx = touch.clientX - r.left;\n    if (!audioAllowed) {\n      initAudio();\n    }\n    if (cx < WIDTH / 2) {\n      keys.ArrowLeft = true;\n      setTimeout(() => (keys.ArrowLeft = false), 180);\n    } else {\n      keys.ArrowRight = true;\n      setTimeout(() => (keys.ArrowRight = false), 180);\n    }\n  }, { passive: false });\n\n  // Collision detection\n  function checkCollisions() {\n    for (let i = electrons.length - 1; i >= 0; i--) {\n      const e = electrons[i];\n      const dx = e.x - player.x;\n      const dy = e.y - player.y + 6;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < e.radius + 16) {\n        // Collected\n        if (e.value === currentProblem.solution) {\n          score += 10;\n          problemsSolved += 1;\n          spawnParticles(e.x, e.y, '#6EE7B7', 12);\n          playCorrect();\n          // Power lightbulb visual quick flash\n          flashBulb();\n          // Increase difficulty a bit\n          if (problemsSolved % 3 === 0) {\n            level += 1;\n            spawnInterval = Math.max(650, spawnInterval - 120);\n          }\n          // New problem after a short delay\n          setTimeout(() => {\n            currentProblem = generateProblem(level);\n          }, 220);\n        } else {\n          // Wrong\n          lives -= 1;\n          spawnParticles(e.x, e.y, '#FF6B6B', 10);\n          playIncorrect();\n          // Slight knockback\n          player.vx = dx > 0 ? -2.5 : 2.5;\n          if (lives <= 0) {\n            // game over\n            gameOver();\n          }\n        }\n        // Remove the electron\n        electrons.splice(i, 1);\n      }\n    }\n  }\n\n  // Particles for visual feedback\n  function spawnParticles(x, y, color, count) {\n    for (let i = 0; i < count; i++) {\n      particles.push({\n        x,\n        y,\n        vx: (Math.random() - 0.5) * 3,\n        vy: (Math.random() - 0.9) * 3,\n        life: 30 + Math.random() * 30,\n        color,\n        size: Math.random() * 4 + 2\n      });\n    }\n  }\n\n  function updateParticles() {\n    for (let i = particles.length - 1; i >= 0; i--) {\n      const p = particles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.08;\n      p.life -= 1;\n      if (p.life <= 0) particles.splice(i, 1);\n    }\n  }\n\n  // Bulb flash state\n  let bulbFlash = 0;\n  function flashBulb() {\n    bulbFlash = 28;\n    if (audioAllowed && soundEnabled) playZap();\n  }\n\n  // Game over state\n  let isGameOver = false;\n  function gameOver() {\n    isGameOver = true;\n    // Stop background oscillation nicely\n    if (bgOsc && audioAllowed) {\n      try {\n        const now = audioCtx.currentTime;\n        masterGain.gain.exponentialRampToValueAtTime(0.02, now + 0.6);\n      } catch (err) {\n        // ignore\n      }\n    }\n  }\n\n  function restartGame() {\n    // Reset state\n    problemsSolved = 0;\n    score = 0;\n    lives = 3;\n    level = 1;\n    timeElapsed = 0;\n    lastSpawn = 0;\n    spawnInterval = 1400;\n    electrons = [];\n    particles = [];\n    currentProblem = generateProblem(level);\n    isGameOver = false;\n    if (audioAllowed) {\n      try {\n        masterGain.gain.setValueAtTime(0.18, audioCtx.currentTime);\n      } catch (err) {}\n    }\n  }\n\n  // Draw utilities\n  function drawBackground() {\n    // Sky gradient with whimsical swirls\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#E8F3FF');\n    g.addColorStop(0.5, '#FDF6F2');\n    g.addColorStop(1, '#F7FFF6');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft wavy hills\n    ctx.fillStyle = '#D7FFEE';\n    ctx.beginPath();\n    ctx.moveTo(0, HEIGHT * 0.6);\n    for (let x = 0; x <= WIDTH; x += 20) {\n      const y = HEIGHT * 0.6 + Math.sin(x * 0.02 + timeElapsed * 0.007) * 16;\n      ctx.lineTo(x, y);\n    }\n    ctx.lineTo(WIDTH, HEIGHT);\n    ctx.lineTo(0, HEIGHT);\n    ctx.closePath();\n    ctx.fill();\n\n    // Floating capacitor clouds (wacky)\n    for (let i = 0; i < 4; i++) {\n      ctx.save();\n      const cx = 100 + i * 160 + Math.sin(timeElapsed * 0.002 + i) * 18;\n      const cy = 70 + Math.cos(timeElapsed * 0.0012 + i) * 10;\n      ctx.globalAlpha = 0.85;\n      ctx.fillStyle = '#FFF8EA';\n      ctx.beginPath();\n      ctx.ellipse(cx, cy, 48, 26, Math.sin(i) * 0.2, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = '#F1ECD8';\n      ctx.stroke();\n      ctx.restore();\n    }\n  }\n\n  function drawWire() {\n    // central wavy wire\n    ctx.save();\n    ctx.lineWidth = 8;\n    ctx.strokeStyle = '#444058';\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    const y = HEIGHT - 120;\n    for (let x = 0; x <= WIDTH; x += 8) {\n      const yy = y + Math.sin((x + timeElapsed * 0.2) * 0.03) * 6;\n      if (x === 0) ctx.moveTo(x, yy);\n      else ctx.lineTo(x, yy);\n    }\n    ctx.stroke();\n\n    // small glowing sparks along the wire\n    for (let i = 0; i < 8; i++) {\n      const tx = (i / 7) * WIDTH;\n      const ty = y + Math.sin((tx + timeElapsed * 0.4) * 0.03) * 6;\n      ctx.beginPath();\n      const rk = (Math.sin(timeElapsed * 0.03 + i) + 1) / 2;\n      ctx.fillStyle = `rgba(255,${180 + rk * 60},${80},${0.6})`;\n      ctx.arc(tx, ty - 6, 5 + rk * 3, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function drawPlayer() {\n    // Cute \"Spark the Squirrel\" made from shapes\n    ctx.save();\n    player.bob += 0.08;\n    const bobY = Math.sin(player.bob) * 4;\n    const x = player.x;\n    const y = player.y + bobY;\n    // shadow\n    ctx.beginPath();\n    ctx.ellipse(x, y + 30, 28, 8, 0, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(0,0,0,0.12)';\n    ctx.fill();\n\n    // body\n    ctx.fillStyle = player.color;\n    ctx.beginPath();\n    ctx.ellipse(x, y, 28, 20, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // cheeks and belly\n    ctx.fillStyle = '#FFD1E6';\n    ctx.beginPath();\n    ctx.ellipse(x - 6, y + 4, 12, 8, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // ears\n    ctx.fillStyle = '#FFB7D8';\n    ctx.beginPath();\n    ctx.ellipse(x - 14, y - 18, 8, 10, -0.3, 0, Math.PI * 2);\n    ctx.ellipse(x + 6, y - 20, 8, 10, 0.2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // tail\n    ctx.save();\n    ctx.translate(x + 22, y - 2);\n    ctx.rotate(Math.sin(timeElapsed * 0.01) * 0.25);\n    const tailGrad = ctx.createLinearGradient(-20, -10, 20, 10);\n    tailGrad.addColorStop(0, '#FFB7D8');\n    tailGrad.addColorStop(1, '#FF7BAC');\n    ctx.fillStyle = tailGrad;\n    ctx.beginPath();\n    ctx.ellipse(0, 0, 14, 26, 0.6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // eyes\n    ctx.fillStyle = '#222';\n    ctx.beginPath();\n    ctx.arc(x - 6, y - 2, 3.5, 0, Math.PI * 2);\n    ctx.arc(x + 6, y - 2, 3.5, 0, Math.PI * 2);\n    ctx.fill();\n    // smile\n    ctx.strokeStyle = '#441';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(x - 0, y + 6, 8, 0.2, Math.PI - 0.2);\n    ctx.stroke();\n\n    // name banner\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.strokeStyle = '#222';\n    ctx.lineWidth = 1;\n    ctx.fillRect(x - 42, y + 36, 84, 18);\n    ctx.strokeRect(x - 42, y + 36, 84, 18);\n    ctx.fillStyle = '#555';\n    ctx.font = '12px Verdana';\n    ctx.textAlign = 'center';\n    ctx.fillText(player.name, x, y + 50);\n    ctx.restore();\n  }\n\n  function drawElectrons() {\n    for (const e of electrons) {\n      ctx.save();\n      ctx.translate(e.x, e.y);\n      const wob = Math.sin(e.wobble + timeElapsed * 0.02) * 6;\n      // glow\n      ctx.beginPath();\n      ctx.arc(0, wob, e.radius + 8, 0, Math.PI * 2);\n      ctx.fillStyle = e.value === currentProblem.solution ? 'rgba(110,231,183,0.12)' : 'rgba(255,209,154,0.08)';\n      ctx.fill();\n\n      // orb\n      const orbGrad = ctx.createRadialGradient(-e.radius*0.3, -e.radius*0.3, 2, 0, 0, e.radius);\n      orbGrad.addColorStop(0, '#FFFFFF');\n      orbGrad.addColorStop(0.3, e.color);\n      orbGrad.addColorStop(1, '#C7B6FF');\n      ctx.fillStyle = orbGrad;\n      ctx.beginPath();\n      ctx.arc(0, wob, e.radius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // label\n      ctx.fillStyle = '#222';\n      ctx.font = 'bold 16px Verdana';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(e.value), 0, wob);\n      ctx.restore();\n    }\n  }\n\n  // Bulb and panel showing problem\n  function drawPanel() {\n    // Left: battery and professor ohm\n    ctx.save();\n    // Battery\n    ctx.fillStyle = '#6C8EFF';\n    ctx.fillRect(32, HEIGHT - 190, 60, 120);\n    ctx.fillStyle = '#EDF0FF';\n    ctx.fillRect(44, HEIGHT - 170, 36, 80);\n    // Professor Ohm\n    ctx.beginPath();\n    ctx.fillStyle = '#F0D68B';\n    ctx.arc(120, HEIGHT - 130, 28, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#3C2F2F';\n    ctx.fillRect(106, HEIGHT - 124, 28, 6); // glasses bar\n    ctx.fillStyle = '#E3A1A1';\n    ctx.fillRect(100, HEIGHT - 100, 40, 36);\n    ctx.fillStyle = '#553';\n    ctx.fillText('Prof. Ohm', 120, HEIGHT - 58);\n\n    // Central problem card\n    ctx.fillStyle = 'rgba(255,255,255,0.95)';\n    ctx.strokeStyle = '#CCDAFF';\n    ctx.lineWidth = 3;\n    ctx.fillRect(WIDTH / 2 - 160, 24, 320, 84);\n    ctx.strokeRect(WIDTH / 2 - 160, 24, 320, 84);\n    ctx.fillStyle = '#123';\n    ctx.font = '20px Verdana';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    const problemText = `${currentProblem.a} ${currentProblem.op} ${currentProblem.b} = ?`;\n    ctx.fillText('Help Spark! Catch the right answer', WIDTH / 2, 36);\n    ctx.font = '34px Verdana';\n    ctx.fillText(problemText, WIDTH / 2, 36 + 42);\n    ctx.restore();\n\n    // Right: Glowy the Lightbulb\n    ctx.save();\n    const bx = WIDTH - 100;\n    const by = HEIGHT - 160;\n    // bulb light\n    const bulbGlow = 0.5 + (bulbFlash > 0 ? 0.7 : 0) * (bulbFlash / 28);\n    const radial = ctx.createRadialGradient(bx, by - 40, 6, bx, by - 40, 70);\n    radial.addColorStop(0, `rgba(255,238,130,${0.9 * bulbGlow})`);\n    radial.addColorStop(1, `rgba(255,238,130,${0.02 * bulbGlow})`);\n    ctx.fillStyle = radial;\n    ctx.beginPath();\n    ctx.ellipse(bx, by - 40, 70, 90, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // bulb glass\n    ctx.fillStyle = '#fff8d6';\n    ctx.beginPath();\n    ctx.ellipse(bx, by - 40, 28, 36, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#C7B47A';\n    ctx.stroke();\n\n    // filament\n    ctx.beginPath();\n    ctx.moveTo(bx - 6, by - 48);\n    ctx.quadraticCurveTo(bx, by - 36, bx + 6, by - 48);\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = '#FFAA00';\n    ctx.stroke();\n\n    // base\n    ctx.fillStyle = '#B3B3B3';\n    ctx.fillRect(bx - 12, by - 16, 24, 20);\n    ctx.strokeRect(bx - 12, by - 16, 24, 20);\n    ctx.restore();\n\n    // Draw HUD: score & lives\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.fillRect(14, 12, 140, 56);\n    ctx.strokeStyle = '#E2EAF9';\n    ctx.strokeRect(14, 12, 140, 56);\n    ctx.fillStyle = '#333';\n    ctx.font = '14px Verdana';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Score: ${score}`, 24, 34);\n    ctx.fillText(`Level: ${level}`, 24, 54);\n    // Lives hearts\n    for (let i = 0; i < 3; i++) {\n      const hx = 120 + i * 18;\n      const hy = 34;\n      ctx.beginPath();\n      ctx.fillStyle = i < lives ? '#FF5D5D' : '#EEE';\n      ctx.moveTo(hx, hy);\n      ctx.arc(hx - 6, hy - 2, 6, 0, Math.PI * 2);\n      ctx.arc(hx + 6, hy - 2, 6, 0, Math.PI * 2);\n      ctx.lineTo(hx, hy + 10);\n      ctx.closePath();\n      ctx.fill();\n      ctx.strokeStyle = '#C84D4D';\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Sound icon\n    drawSoundIcon(WIDTH - 36, 36);\n  }\n\n  function drawParticles() {\n    for (const p of particles) {\n      ctx.beginPath();\n      ctx.fillStyle = p.color;\n      ctx.globalAlpha = Math.max(0, p.life / 60);\n      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n  }\n\n  // Update function\n  let lastTime = performance.now();\n  function update(now) {\n    const dt = now - lastTime;\n    lastTime = now;\n    timeElapsed += dt;\n\n    if (!isGameOver) {\n      // Player movement\n      if (keys.ArrowLeft || keys.a || keys.A) {\n        player.vx = -player.speed;\n      } else if (keys.ArrowRight || keys.d || keys.D) {\n        player.vx = player.speed;\n      } else {\n        // slow down\n        player.vx *= 0.86;\n        if (Math.abs(player.vx) < 0.06) player.vx = 0;\n      }\n      player.x += player.vx;\n      // Boundary\n      player.x = Math.max(44, Math.min(WIDTH - 44, player.x));\n\n      // Spawn electrons over time\n      lastSpawn += dt;\n      if (lastSpawn > spawnInterval) {\n        spawnElectron();\n        lastSpawn = 0;\n      }\n\n      // Move electrons\n      for (let i = electrons.length - 1; i >= 0; i--) {\n        const e = electrons[i];\n        e.y += e.vy;\n        e.wobble += 0.04;\n        if (e.y > HEIGHT + 60) {\n          // Missed: if the correct one is missed, penalize slightly\n          if (e.value === currentProblem.solution) {\n            lives -= 1;\n            spawnParticles(e.x, HEIGHT - 80, '#FFB0B0', 10);\n            playIncorrect();\n            if (lives <= 0) {\n              gameOver();\n            }\n            // New problem\n            currentProblem = generateProblem(level);\n          }\n          electrons.splice(i, 1);\n        }\n      }\n\n      // Particles update\n      updateParticles();\n\n      // Collisions\n      checkCollisions();\n\n      if (bulbFlash > 0) bulbFlash -= 1;\n\n      // Slight background hum frequency drift for calming effect\n      if (audioAllowed && bgOsc) {\n        try {\n          bgOsc.frequency.setValueAtTime(60 + Math.sin(timeElapsed * 0.0019) * 4, audioCtx.currentTime);\n        } catch (err) {}\n      }\n    }\n    draw();\n    requestAnimationFrame(update);\n  }\n\n  // Draw everything\n  function draw() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawBackground();\n    drawWire();\n    drawElectrons();\n    drawPlayer();\n    drawPanel();\n    drawParticles();\n\n    // On-screen instructions & visual accessibility cues\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    ctx.fillRect(12, HEIGHT - 48, 260, 36);\n    ctx.strokeStyle = '#E3E3E3';\n    ctx.strokeRect(12, HEIGHT - 48, 260, 36);\n    ctx.fillStyle = '#333';\n    ctx.font = '13px Verdana';\n    ctx.textAlign = 'left';\n    ctx.fillText('Use \u2190 \u2192 keys or tap sides to move. Press S to toggle sound. Catch the correct number!', 20, HEIGHT - 24);\n    ctx.restore();\n\n    // If audio error, show textual indicator\n    if (audioError) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,200,200,0.95)';\n      ctx.fillRect(WIDTH - 280, HEIGHT - 60, 268, 44);\n      ctx.fillStyle = '#650000';\n      ctx.font = '12px Verdana';\n      ctx.textAlign = 'left';\n      ctx.fillText('Audio unavailable in this browser. Sound disabled.', WIDTH - 268, HEIGHT - 36);\n      ctx.restore();\n    }\n\n    // If game over, overlay\n    if (isGameOver) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(12, 12, 20, 0.6)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = '#fff';\n      ctx.textAlign = 'center';\n      ctx.font = '36px Verdana';\n      ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 40);\n      ctx.font = '20px Verdana';\n      ctx.fillText(`Score: ${score}`, WIDTH / 2, HEIGHT / 2 - 8);\n      ctx.fillText('Tap or press R to restart', WIDTH / 2, HEIGHT / 2 + 26);\n      ctx.restore();\n    }\n  }\n\n  // Input for restart\n  window.addEventListener('keydown', (e) => {\n    if ((e.key === 'r' || e.key === 'R') && isGameOver) {\n      restartGame();\n    }\n    // space to try to collect nearest electron (optional)\n    if (e.key === ' ' && !isGameOver) {\n      // move player quickly upward to \"reach\" slightly earlier\n      player.vx *= 1.2;\n    }\n  });\n\n  // Also allow clicking overlay to restart\n  canvas.addEventListener('click', (e) => {\n    if (isGameOver) {\n      restartGame();\n    }\n  });\n\n  // Kick off animation\n  requestAnimationFrame(update);\n\n  // Small friendly console message\n  console.info('Electric Math Game loaded. Use arrow keys to move Spark and S to toggle sound.');\n\n  // Safety: attempt to init audio on first user gesture on canvas\n  function gestureInit() {\n    if (!audioAllowed) {\n      initAudio();\n    }\n    canvas.removeEventListener('pointerdown', gestureInit);\n  }\n  canvas.addEventListener('pointerdown', gestureInit);\n\n  // Expose some state for testing (non-intrusive)\n  window.__electricMathGame = {\n    restart: restartGame,\n    toggleSound: () => {\n      if (!audioAllowed) initAudio();\n      soundEnabled = !soundEnabled;\n    },\n    status: () => ({ score, lives, level, problemsSolved, soundEnabled, audioAllowed, audioError })\n  };\n\n  // Ensure size and focusability for accessibility\n  canvas.tabIndex = 0;\n  canvas.addEventListener('focus', () => {\n    // Draw a subtle focus ring\n    ctx.save();\n    ctx.strokeStyle = '#6EA6FF';\n    ctx.lineWidth = 4;\n    ctx.strokeRect(4, 4, WIDTH - 8, HEIGHT - 8);\n    ctx.restore();\n  });\n\n})();\n---\n",
  "improve_response_tokens": 19308,
  "formatted_code": true,
  "formatting_response_tokens": 20757,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}