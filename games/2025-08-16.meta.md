# Game of the Day - 2025-08-16

## Metadata
- **Generated Date:** 2025-08-16
- **Generated Time:** 2025-08-16T00:21:35.753213
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-16.js
- **File Size:** 26678 bytes
- **Tokens Used:** 9639

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-16.js` - The playable game
- `2025-08-16.meta.json` - Machine-readable metadata
- `2025-08-16.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17972

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 18748

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Electricity Math Game for ages 7-9
// Renders into element with id "game-of-the-day-stage"
// Canvas-based visuals and Web Audio API for sounds
// Accessible: keyboard controls, text alternatives, audio toggle, and clear instructions

(() => {
  // Ensure container exists
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.width = '720px';
  container.style.height = '480px';
  container.style.outline = 'none';

  // Create hidden accessible instructions (for screen readers)
  const sr = document.createElement('div');
  sr.setAttribute('aria-live', 'polite');
  sr.setAttribute('role', 'status');
  sr.style.position = 'absolute';
  sr.style.left = '-10000px';
  sr.style.top = 'auto';
  sr.style.width = '1px';
  sr.style.height = '1px';
  sr.style.overflow = 'hidden';
  container.appendChild(sr);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.setAttribute('tabindex', '0'); // make focusable
  canvas.style.display = 'block';
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.style.cursor = 'crosshair';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Game constants
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;
  const GRID_COLS = 5;
  const GRID_ROWS = 3;
  const NODE_RADIUS = 28;
  const MARGIN_X = 80;
  const MARGIN_Y = 140;
  const SPACING_X = (WIDTH - 2 * MARGIN_X) / (GRID_COLS - 1);
  const SPACING_Y = 90;
  const MAX_ROUNDS = 8;

  // Game state
  let nodes = []; // {col,row,x,y,value,lit,used}
  let spark = {col: 2, row: 1, x: 0, y: 0}; // starts center-ish
  let selected = []; // list of selected node indexes
  let targetSum = 10;
  let score = 0;
  let round = 1;
  let message = 'Welcome to Spark Circuit! Use arrows to move. Press Space to pick.';
  let showHelp = true;
  let audioEnabled = true;
  let audioCtx = null;
  let audioAllowed = true;
  let bgHum = null;
  let lastMoveSoundTime = 0;
  let animTick = 0;
  let locked = false; // prevents input during animations

  // Accessibility helper
  function announce(text) {
    sr.textContent = text;
  }

  // Initialize audio context with error handling
  function initAudio() {
    if (audioCtx) return;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) {
        audioAllowed = false;
        console.warn('Web Audio API not supported in this browser.');
        return;
      }
      audioCtx = new AudioContext();
      // create gentle background hum
      try {
        bgHum = audioCtx.createOscillator();
        const humGain = audioCtx.createGain();
        humGain.gain.value = 0.0025; // very gentle
        bgHum.type = 'sine';
        bgHum.frequency.value = 120;
        bgHum.connect(humGain);
        humGain.connect(audioCtx.destination);
        bgHum.start();
      } catch (e) {
        console.warn('Background hum failed to start:', e);
      }
    } catch (e) {
      audioAllowed = false;
      console.warn('Failed to create AudioContext:', e);
    }
  }

  // Ensure audio resumed on first user gesture (for browsers that require gesture)
  function tryUnlockAudio() {
    if (!audioCtx) initAudio();
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch(e => console.warn('Audio resume failed:', e));
    }
  }

  // Sound utilities using oscillators
  function playBeep(freq = 880, duration = 0.12, type = 'sine') {
    if (!audioAllowed || !audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.05, now + 0.01);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.stop(now + duration + 0.02);
    } catch (e) {
      console.warn('playBeep error:', e);
    }
  }

  function playSuccess() {
    if (!audioAllowed || !audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      // ascending triad
      [660, 880, 990].forEach((f, i) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'triangle';
        o.frequency.value = f;
        o.connect(g);
        g.connect(audioCtx.destination);
        const t = now + i * 0.09;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.06, t + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.14);
        o.start(t);
        o.stop(t + 0.16);
      });
    } catch (e) {
      console.warn('playSuccess error:', e);
    }
  }

  function playBuzz() {
    if (!audioAllowed || !audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const f = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      o.type = 'sawtooth';
      o.frequency.value = 160;
      f.type = 'lowpass';
      f.frequency.value = 500;
      g.gain.value = 0.0001;
      o.connect(f);
      f.connect(g);
      g.connect(audioCtx.destination);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.06, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
      o.start(now);
      o.stop(now + 0.26);
    } catch (e) {
      console.warn('playBuzz error:', e);
    }
  }

  // Game logic helpers
  function nodeIndex(col, row) {
    return row * GRID_COLS + col;
  }

  function createNodes() {
    nodes = [];
    for (let r = 0; r < GRID_ROWS; r++) {
      for (let c = 0; c < GRID_COLS; c++) {
        const x = MARGIN_X + c * SPACING_X;
        const y = MARGIN_Y + r * SPACING_Y + Math.sin((c + r) * 0.8) * 6;
        nodes.push({
          col: c,
          row: r,
          x,
          y,
          value: 0,
          lit: false,
          used: false
        });
      }
    }
  }

  // Generate values ensuring at least one pair sums to target
  function generateRound() {
    locked = false;
    // choose target between 5 and 18
    targetSum = Math.floor(Math.random() * 14) + 5;
    // Generate values ensuring at least one valid pair
    createNodes();
    // pick a pair indices for guaranteed solution
    const idxA = Math.floor(Math.random() * nodes.length);
    let idxB = idxA;
    while (idxB === idxA) idxB = Math.floor(Math.random() * nodes.length);
    const valA = Math.floor(Math.random() * Math.min(9, targetSum - 1)) + 1; // at least 1
    const valB = targetSum - valA;
    // Fill values: place the pair
    nodes[idxA].value = valA;
    nodes[idxB].value = valB;
    // Fill others randomly but avoid accidental extra trivial pairs? It's okay to have more pairs.
    for (let i = 0; i < nodes.length; i++) {
      if (i === idxA || i === idxB) continue;
      let v = Math.floor(Math.random() * 12) + 1; // 1..12
      // avoid making any number exceed 20 or negative
      v = Math.max(1, Math.min(12, v));
      nodes[i].value = v;
      nodes[i].lit = false;
      nodes[i].used = false;
    }
    // Reset spark to central-ish position
    spark.col = 2;
    spark.row = 1;
    const idx = nodeIndex(spark.col, spark.row);
    spark.x = nodes[idx].x;
    spark.y = nodes[idx].y;
    selected = [];
    message = `Round ${round}: Help Spark find two numbers that add to ${targetSum}.`;
    announce(message);
  }

  // Input handling: Movement and selection
  function moveSpark(dx, dy) {
    if (locked) return;
    const newCol = Math.max(0, Math.min(GRID_COLS - 1, spark.col + dx));
    const newRow = Math.max(0, Math.min(GRID_ROWS - 1, spark.row + dy));
    if (newCol === spark.col && newRow === spark.row) return;
    spark.col = newCol;
    spark.row = newRow;
    const idx = nodeIndex(spark.col, spark.row);
    // animate movement by setting target x,y; we'll ease in update loop
    // play small move sound, limit rapid retriggering
    const now = performance.now();
    if (now - lastMoveSoundTime > 80) {
      playBeep(880, 0.08, 'square');
      lastMoveSoundTime = now;
    }
  }

  function selectCurrentNode() {
    if (locked) return;
    const idx = nodeIndex(spark.col, spark.row);
    if (selected.length === 1 && selected[0] === idx) {
      // deselect if pressing same node again
      selected = [];
      message = 'Selection cleared.';
      announce(message);
      return;
    }
    if (selected.length === 2) {
      // ignore until evaluation completes
      return;
    }
    if (nodes[idx].used) {
      message = 'This node already used. Try another.';
      announce(message);
      playBuzz();
      return;
    }
    selected.push(idx);
    playBeep(1100, 0.09, 'sine');
    message = `Picked ${nodes[idx].value}.`;
    announce(message);
    if (selected.length === 2) {
      evaluateSelection();
    }
  }

  function evaluateSelection() {
    locked = true;
    const a = nodes[selected[0]].value;
    const b = nodes[selected[1]].value;
    if (a + b === targetSum) {
      // success
      nodes[selected[0]].lit = true;
      nodes[selected[1]].lit = true;
      nodes[selected[0]].used = true;
      nodes[selected[1]].used = true;
      score += 10;
      playSuccess();
      message = `Great! ${a} + ${b} = ${targetSum}. Bulb lit! Score: ${score}`;
      announce(message);
      // small celebration animation and next round after timeout
      setTimeout(() => {
        round++;
        if (round > MAX_ROUNDS) {
          message = `Amazing! You finished with ${score} points. Play again? Press R.`;
          announce(message);
          locked = false;
        } else {
          generateRound();
        }
      }, 900);
    } else {
      // incorrect
      playBuzz();
      message = `Oops! ${a} + ${b} = ${a + b} not ${targetSum}. Try again.`;
      announce(message);
      // flash nodes and reset selection
      const bad = [...selected];
      // animate flash by marking lit temporarily
      bad.forEach(i => nodes[i].lit = true);
      setTimeout(() => {
        bad.forEach(i => (nodes[i].lit = false));
        selected = [];
        locked = false;
      }, 700);
    }
  }

  // Click handling: click on node to move spark there and/or select
  canvas.addEventListener('pointerdown', (ev) => {
    tryUnlockAudio();
    const rect = canvas.getBoundingClientRect();
    const px = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const py = (ev.clientY - rect.top) * (canvas.height / rect.height);
    // check if clicked on speaker icon top-right
    if (px > WIDTH - 64 && px < WIDTH - 12 && py > 12 && py < 48) {
      audioEnabled = !audioEnabled;
      message = audioEnabled ? 'Audio on.' : 'Audio off.';
      announce(message);
      if (audioEnabled && audioAllowed) tryUnlockAudio();
      return;
    }
    // check clicked on help area toggle bottom-left
    if (px < 160 && py > HEIGHT - 64) {
      showHelp = !showHelp;
      message = showHelp ? 'Help shown.' : 'Help hidden.';
      announce(message);
      return;
    }
    // find nearest node click
    let clickedIndex = -1;
    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i];
      const dx = px - n.x;
      const dy = py - n.y;
      if (dx * dx + dy * dy <= NODE_RADIUS * NODE_RADIUS * 1.4) {
        clickedIndex = i;
        break;
      }
    }
    if (clickedIndex >= 0) {
      // move spark to that node (instant) and select
      spark.col = nodes[clickedIndex].col;
      spark.row = nodes[clickedIndex].row;
      const idx = nodeIndex(spark.col, spark.row);
      // single click selects
      selectCurrentNode();
    } else {
      // click elsewhere moves spark to nearest grid position
      // find nearest col/row
      let nearestCol = 0;
      let nearestRow = 0;
      let minDist = Infinity;
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          const n = nodes[nodeIndex(c, r)];
          const d = (px - n.x) ** 2 + (py - n.y) ** 2;
          if (d < minDist) {
            minDist = d;
            nearestCol = c;
            nearestRow = r;
          }
        }
      }
      spark.col = nearestCol;
      spark.row = nearestRow;
      playBeep(700, 0.08, 'triangle');
    }
  });

  // Keyboard controls
  window.addEventListener('keydown', (e) => {
    if (!document.activeElement || document.activeElement !== canvas) {
      // only respond if canvas focused to avoid interference
      return;
    }
    tryUnlockAudio();
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      moveSpark(-1, 0);
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      moveSpark(1, 0);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      moveSpark(0, -1);
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      moveSpark(0, 1);
    } else if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      selectCurrentNode();
    } else if (e.key.toLowerCase() === 'r') {
      e.preventDefault();
      round = 1;
      score = 0;
      generateRound();
    } else if (e.key.toLowerCase() === 'm') {
      e.preventDefault();
      audioEnabled = !audioEnabled;
      message = audioEnabled ? 'Audio on.' : 'Audio off.';
      announce(message);
      if (audioEnabled && audioAllowed) tryUnlockAudio();
    } else if (e.key.toLowerCase() === 'h') {
      e.preventDefault();
      showHelp = !showHelp;
      message = showHelp ? 'Help shown.' : 'Help hidden.';
      announce(message);
    }
  });

  // Determine nearest node index from coordinates
  function findNodeAt(x, y) {
    for (let i = 0; i < nodes.length; i++) {
      const dx = x - nodes[i].x;
      const dy = y - nodes[i].y;
      if (dx * dx + dy * dy <= NODE_RADIUS * NODE_RADIUS) return i;
    }
    return -1;
  }

  // Drawing routines
  function drawBackground() {
    // soft gradient background like soft circuit board
    const g = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
    g.addColorStop(0, '#0f2b3d');
    g.addColorStop(0.5, '#0d394a');
    g.addColorStop(1, '#083a2e');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // wacky floating electric swirls (glow)
    for (let i = 0; i < 6; i++) {
      ctx.beginPath();
      const x = (i / 6) * WIDTH + (Math.sin(animTick * 0.02 + i) * 30);
      const y = 60 + (i % 2) * 120 + Math.cos(animTick * 0.03 + i) * 18;
      ctx.fillStyle = `rgba(200,230,255,0.02)`;
      ctx.arc(x, y, 120, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawBulb() {
    // bulb sits at top center as the mission target. It lights when correct picks
    const bulbX = WIDTH / 2;
    const bulbY = 64;
    // bulb glass
    ctx.beginPath();
    const glow = (selected.length === 2 && nodes[selected[0]].lit && nodes[selected[1]].lit) ? 0.9 : 0.15 + Math.sin(animTick * 0.12) * 0.05;
    const bulbGrad = ctx.createRadialGradient(bulbX - 10, bulbY - 12, 12, bulbX, bulbY, 80);
    bulbGrad.addColorStop(0, `rgba(255, 255, 160, ${0.9 * glow})`);
    bulbGrad.addColorStop(1, `rgba(255, 220, 90, ${0.05 * glow})`);
    ctx.fillStyle = bulbGrad;
    ctx.ellipse(bulbX, bulbY, 60, 46, 0, 0, Math.PI * 2);
    ctx.fill();

    // glass outline
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,200,0.8)';
    ctx.lineWidth = 2;
    ctx.ellipse(bulbX, bulbY, 60, 46, 0, 0, Math.PI * 2);
    ctx.stroke();

    // filament (wavy)
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 230, 120, 0.9)';
    ctx.lineWidth = 3;
    const p1 = {x: bulbX - 14, y: bulbY + 2};
    const p2 = {x: bulbX - 4, y: bulbY - 6 + Math.sin(animTick * 0.2) * 3};
    const p3 = {x: bulbX + 6, y: bulbY + 2};
    ctx.moveTo(p1.x, p1.y);
    ctx.quadraticCurveTo(p2.x, p2.y, p3.x, p3.y);
    ctx.stroke();

    // base
    ctx.fillStyle = '#666';
    ctx.fillRect(bulbX - 28, bulbY + 28, 56, 18);
    ctx.fillStyle = '#444';
    ctx.fillRect(bulbX - 18, bulbY + 46, 36, 6);

    // text: target
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Target: ${targetSum}`, bulbX, bulbY - 56);

    // fun bulb buddy character next to bulb
    drawGlimmer(bulbX + 110, bulbY - 10);
  }

  function drawGlimmer(x, y) {
    // Glimmer: a friendly bulb-bird that reacts when lit
    const glow = (selected.length === 2 && nodes[selected[0]].lit && nodes[selected[1]].lit) ? 1 : 0.2;
    // body
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,240,120,${0.9 * glow + 0.1})`;
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();
    // eye
    ctx.beginPath();
    ctx.fillStyle = '#222';
    ctx.arc(x - 4, y - 4, 3, 0, Math.PI * 2);
    ctx.fill();
    // beak
    ctx.beginPath();
    ctx.fillStyle = '#ff9a3c';
    ctx.moveTo(x + 6, y);
    ctx.lineTo(x + 12, y - 4);
    ctx.lineTo(x + 12, y + 4);
    ctx.fill();
    // tiny lightning halo
    ctx.beginPath();
    ctx.strokeStyle = `rgba(255,255,180,${0.5 + 0.5 * glow})`;
    ctx.lineWidth = 2;
    ctx.moveTo(x - 22, y - 18);
    ctx.lineTo(x - 10, y - 6);
    ctx.lineTo(x - 18, y - 6);
    ctx.stroke();
  }

  function drawWires() {
    ctx.lineWidth = 3;
    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i];
      // connect to right neighbor
      if (n.col < GRID_COLS - 1) {
        const n2 = nodes[nodeIndex(n.col + 1, n.row)];
        drawWireSegment(n, n2);
      }
      // connect to bottom neighbor
      if (n.row < GRID_ROWS - 1) {
        const n2 = nodes[nodeIndex(n.col, n.row + 1)];
        drawWireSegment(n, n2);
      }
      // diagonal wacky connector to make it interesting
      if (n.col < GRID_COLS - 1 && n.row < GRID_ROWS - 1) {
        const n2 = nodes[nodeIndex(n.col + 1, n.row + 1)];
        drawWireSegment(n, n2, true);
      }
    }
  }

  function drawWireSegment(a, b, diagonal = false) {
    // wire color glows if connected to a lit node
    const lit = a.lit || b.lit;
    const base = lit ? 'rgba(255,220,120,0.9)' : 'rgba(200,240,255,0.18)';
    // wacky line using quadratic curve with slight sine offset based on animTick
    const midX = (a.x + b.x) / 2 + Math.sin((a.x + b.x + animTick) * 0.01) * 6;
    const midY = (a.y + b.y) / 2 + Math.cos((a.y + b.y + animTick) * 0.01) * 6;
    ctx.beginPath();
    ctx.strokeStyle = base;
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.moveTo(a.x, a.y);
    ctx.quadraticCurveTo(midX, midY, b.x, b.y);
    ctx.stroke();

    // tiny highlight line
    ctx.beginPath();
    ctx.strokeStyle = lit ? 'rgba(255,255,200,0.6)' : 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1.2;
    ctx.moveTo(a.x, a.y);
    ctx.quadraticCurveTo(midX, midY, b.x, b.y);
    ctx.stroke();
  }

  function drawNodes() {
    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i];
      // base circle
      ctx.beginPath();
      // shadow
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.arc(n.x + 4, n.y + 6, NODE_RADIUS + 6, 0, Math.PI * 2);
      ctx.fill();

      // glow if lit
      if (n.lit) {
        const g = ctx.createRadialGradient(n.x - 6, n.y - 8, 6, n.x, n.y, NODE_RADIUS + 20);
        g.addColorStop(0, 'rgba(255,250,180,0.9)');
        g.addColorStop(1, 'rgba(255,200,80,0.06)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(n.x, n.y, NODE_RADIUS + 20, 0, Math.PI * 2);
        ctx.fill();
      }

      // node body
      ctx.beginPath();
      ctx.fillStyle = n.used ? '#4a4a4a' : '#0f4c5e';
      ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI * 2);
      ctx.fill();

      // rim
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(200,255,255,0.12)';
      ctx.stroke();

      // numeric label
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(n.value), n.x, n.y);

      // if selected highlight
      const idx = i;
      if (selected.includes(idx)) {
        ctx.beginPath();
        ctx.lineWidth = 4;
        ctx.strokeStyle = 'rgba(255,240,140,0.95)';
        ctx.arc(n.x, n.y, NODE_RADIUS + 6, 0, Math.PI * 2);
        ctx.stroke();
      }

      // tiny spark sprite on nodes that are available and not used
      if (!n.used) {
        ctx.beginPath();
        const littleX = n.x + Math.cos((i + animTick) * 0.12) * 6;
        const littleY = n.y + Math.sin((i + animTick) * 0.11) * 4;
        ctx.fillStyle = 'rgba(255,230,160,0.9)';
        ctx.arc(littleX, littleY, 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  function drawSpark() {
    // Ease spark position toward node center for smooth movement
    const target = nodes[nodeIndex(spark.col, spark.row)];
    if (!target) return;
    spark.x += (target.x - spark.x) * 0.32;
    spark.y += (target.y - spark.y) * 0.32;

    ctx.save();
    // animated electric trail
    const grad = ctx.createRadialGradient(spark.x, spark.y, 2, spark.x, spark.y, 40);
    grad.addColorStop(0, 'rgba(255,250,190,0.95)');
    grad.addColorStop(1, 'rgba(255,200,90,0.03)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(spark.x, spark.y, 18 + Math.sin(animTick * 0.1) * 3, 0, Math.PI * 2);
    ctx.fill();

    // main spark body
    ctx.beginPath();
    ctx.fillStyle = '#fffab0';
    ctx.arc(spark.x, spark.y, 10, 0, Math.PI * 2);
    ctx.fill();

    // face
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.arc(spark.x - 3, spark.y - 2, 1.7, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(spark.x + 4, spark.y - 2, 1.7, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.beginPath();
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1.6;
    ctx.arc(spark.x + 0, spark.y + 2, 4, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.stroke();

    // small electric flicker
    ctx.restore();
  }

  function drawUI() {
    // top-left score
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(12, 12, 180, 42);
    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 22, 34);
    ctx.fillStyle = '#fff';
    ctx.font = '13px Arial';
    ctx.fillText(`Round: ${round}/${MAX_ROUNDS}`, 22, 50);

    // speaker icon top-right
    ctx.beginPath();
    const spX = WIDTH - 48;
    const spY = 28;
    ctx.fillStyle = audioEnabled ? '#ffd56b' : '#777';
    ctx.fillRect(spX - 18, spY - 12, 14, 24);
    ctx.beginPath();
    ctx.moveTo(spX - 4, spY - 14);
    ctx.lineTo(spX + 10, spY - 6);
    ctx.lineTo(spX + 10, spY + 6);
    ctx.lineTo(spX - 4, spY + 14);
    ctx.closePath();
    ctx.fill();
    // waves if enabled
    if (audioEnabled) {
      ctx.beginPath();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.arc(spX + 10, spY, 10, -0.5, 0.5);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 3;
      ctx.moveTo(spX + 6, spY - 9);
      ctx.lineTo(spX + 14, spY + 9);
      ctx.stroke();
    }
    // small accessible hint text
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    ctx.fillText('Press M to mute', WIDTH - 22, 50);

    // bottom-left help toggle
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(12, HEIGHT - 64, 220, 52);
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('H: Help  |  R: Restart', 22, HEIGHT - 36);
    ctx.fillText('Arrows: Move  Space/Enter: Pick', 22, HEIGHT - 18);

    // message box centered bottom
    ctx.fillStyle = 'rgba(0,0,0,0.36)';
    ctx.fillRect(WIDTH / 2 - 300, HEIGHT - 64, 600, 48);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 15px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(message, WIDTH / 2, HEIGHT - 36);

    // visual cue for selected picks
    ctx.fillStyle = '#fff';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    if (selected.length > 0) {
      const a = nodes[selected[0]].value;
      ctx.fillText(`Picked: ${a}${selected.length === 2 ? '' : '  (pick another)'}`, WIDTH / 2, HEIGHT - 18);
    } else {
      ctx.fillText('No selection yet', WIDTH / 2, HEIGHT - 18);
    }

    // small characters description for narrative
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = 'bold 34px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Spark Circuit', 18, 110);
  }

  // Main render loop
  function render() {
    animTick++;
    drawBackground();
    drawBulb();
    drawWires();
    drawNodes();
    drawSpark();
    drawUI();

    // update spark position smoothing already done in drawSpark
    requestAnimationFrame(render);
  }

  // Initialization
  function startGame() {
    initAudio();
    if (!audioAllowed) {
      audioEnabled = false;
      message = 'Audio not available. Using visual feedback.';
      announce(message);
    }
    createNodes();
    // set initial spark coords to center node
    const idx = nodeIndex(spark.col, spark.row);
    spark.x = nodes[idx].x;
    spark.y = nodes[idx].y;

    generateRound();
    render();

    // initial instruction announcement
    const helpText = `Spark Circuit: Move Spark (arrow keys) to nodes and press Space to pick two numbers that add to the target.
    Click nodes or use keyboard. Toggle audio with M. Toggle help with H. Restart with R.`;
    announce(helpText);
  }

  // Make sure canvas receives focus on click for keyboard controls
  canvas.addEventListener('click', () => {
    canvas.focus();
  });

  // Focus outline for accessibility
  canvas.addEventListener('focus', () => {
    canvas.style.outline = '3px solid rgba(255,255,180,0.2)';
  });
  canvas.addEventListener('blur', () => {
    canvas.style.outline = 'none';
  });

  // Start game when user interacts first time (to create audio on gesture)
  function userGestureInit() {
    tryUnlockAudio();
    // remove listeners after first gesture
    window.removeEventListener('pointerdown', userGestureInit);
    window.removeEventListener('keydown', userGestureInit);
  }
  window.addEventListener('pointerdown', userGestureInit, {passive: true});
  window.addEventListener('keydown', userGestureInit);

  // Kick off
  startGame();

  // Expose a small debug function to container for testing (non-essential)
  container.debug = {
    getState: () => ({score, round, targetSum, nodes, selected})
  };
})();
---

