{
  "generated_date": "2025-08-07",
  "generated_timestamp": "2025-08-07T00:23:38.289747",
  "model": "gpt-4.1-mini",
  "theme": "open world exploration",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: open world exploration\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 6132,
  "game_filename": "2025-08-07.js",
  "game_size_bytes": 21249,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(() => {\n  // SETUP AND CONSTANTS\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  // Math Concept: Number Bonds and Addition up to 20\n  // Theme: Open World Exploration in a colorful forest where the player helps quirky creatures by collecting correct \"number fruits\".\n\n  // Accessible keyboard controls:\n  // Arrow keys to move explorer\n  // Space / Enter to select fruit to deliver math bond answers\n  // Instructions on screen, visual cues for sound on/off\n\n  // GLOBAL VARIABLES\n  let canvas, ctx;\n  let audioCtx, gainNode;\n  let gameState = {\n    explorer: { x: WIDTH / 2, y: HEIGHT / 2, size: 40, speed: 4 },\n    fruits: [],\n    creatures: [],\n    currentBond: null,\n    score: 0,\n    message: \"Use arrow keys to move; Space to select fruit\",\n    selectedFruitIndex: 0,\n    soundOn: true,\n    keysPressed: {},\n    frame: 0,\n  };\n\n  // COLORS WIBGYOR + extras for calming but wacky vibe\n  const COLORS = {\n    background: \"#c7f0db\",\n    explorer: \"#055a8c\",\n    fruits: [\"#ff6f61\", \"#f7d154\", \"#6bc5a9\", \"#9d7fed\", \"#ef8a92\", \"#ffcc5c\"],\n    creatures: [\"#684b6c\", \"#a1c3d1\", \"#f9f4e7\"],\n    outline: \"#2e2e2e\",\n    text: \"#2e2e2e\",\n    selectedFruitOutline: \"#ffd700\",\n    hudBg: \"rgba(255, 255, 255, 0.8)\",\n  };\n\n  // SOUND UTILS\n  function createAudioContext() {\n    try {\n      const context = new (window.AudioContext || window.webkitAudioContext)();\n      return context;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function playTone(freq, duration, type = \"sine\", volume = 0.3) {\n    if (!audioCtx || !gameState.soundOn) return;\n    try {\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n\n      osc.type = type;\n      osc.frequency.value = freq;\n\n      gain.gain.setValueAtTime(volume, audioCtx.currentTime);\n      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);\n\n      osc.connect(gain);\n      gain.connect(audioCtx.destination);\n\n      osc.start();\n      osc.stop(audioCtx.currentTime + duration);\n    } catch {\n      // fail silently\n    }\n  }\n\n  function playCorrectSound() {\n    playTone(880, 0.15, \"triangle\", 0.25);\n    setTimeout(() => playTone(1100, 0.12, \"triangle\", 0.25), 150);\n  }\n\n  function playWrongSound() {\n    playTone(220, 0.3, \"sawtooth\", 0.3);\n  }\n\n  function playBackgroundHum() {\n    if (!audioCtx || !gameState.soundOn) return;\n    try {\n      if (gameState._bgOsc) return; // already playing\n\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n\n      osc.type = \"sine\";\n      osc.frequency.setValueAtTime(220, audioCtx.currentTime);\n\n      gain.gain.setValueAtTime(0.03, audioCtx.currentTime);\n\n      osc.connect(gain);\n      gain.connect(audioCtx.destination);\n\n      osc.start();\n\n      gameState._bgOsc = osc;\n      gameState._bgGain = gain;\n    } catch {\n      // fail silently\n    }\n  }\n\n  function stopBackgroundHum() {\n    if (gameState._bgOsc) {\n      try {\n        gameState._bgGain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.7);\n        setTimeout(() => {\n          if (gameState._bgOsc) {\n            gameState._bgOsc.stop();\n            gameState._bgOsc.disconnect();\n            gameState._bgGain.disconnect();\n            gameState._bgOsc = null;\n            gameState._bgGain = null;\n          }\n        }, 800);\n      } catch {\n        // fail silently\n      }\n    }\n  }\n\n  // GAME DATA GENERATION\n  // Generate number bonds whose parts add up to between 5 and 20.\n  function generateNumberBond() {\n    // Pick total between 7 and 20\n    const total = 7 + Math.floor(Math.random() * 14); // 7..20\n    // Pick a part (1..total-1)\n    const part1 = 1 + Math.floor(Math.random() * (total - 1));\n    const part2 = total - part1;\n    return { total, part1, part2 };\n  }\n\n  // Generate fruit with number and a color from the palette - fruits represent numbers to pick.\n  function createFruit(num, x, y, color) {\n    return {\n      num,\n      x,\n      y,\n      size: 30,\n      color,\n      isSelected: false,\n      collected: false,\n    };\n  }\n\n  // Creature represents the wacky forest character needing a number bond answer delivered.\n  function createCreature(x, y) {\n    return {\n      x,\n      y,\n      size: 60,\n      happy: false,\n      // Says the total that needs to be matched by sum of fruits delivered\n      currentBond: generateNumberBond(),\n      deliveredNums: [],\n    };\n  }\n\n  // Initialize fruits & creatures placed around the map/world\n  function initializeGameObjects() {\n    gameState.fruits = [];\n    const fruitNumbers = [];\n    // Creating abundant fruits numbered 1 to 15 so child can choose\n    for (let n = 1; n <= 15; n++) {\n      // Position fruits randomly but within borders\n      const fx = 60 + Math.random() * (WIDTH - 120);\n      const fy = 60 + Math.random() * (HEIGHT - 140);\n      const c = COLORS.fruits[n % COLORS.fruits.length];\n      const fruit = createFruit(n, fx, fy, c);\n      gameState.fruits.push(fruit);\n    }\n\n    // Creatures at fixed interesting wacky spots\n    gameState.creatures = [\n      createCreature(120, 120),\n      createCreature(WIDTH - 140, 140),\n      createCreature(140, HEIGHT - 120),\n      createCreature(WIDTH - 160, HEIGHT - 150),\n    ];\n  }\n\n  // DRAWING UTILITIES\n\n  function drawRoundedRect(ctx, x, y, w, h, r, fillColor, strokeColor) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.lineTo(x + w - r, y);\n    ctx.quadraticCurveTo(x + w, y, x + w, y + r);\n    ctx.lineTo(x + w, y + h - r);\n    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);\n    ctx.lineTo(x + r, y + h);\n    ctx.quadraticCurveTo(x, y + h, x, y + h - r);\n    ctx.lineTo(x, y + r);\n    ctx.quadraticCurveTo(x, y, x + r, y);\n    if (fillColor) {\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n    }\n    if (strokeColor) {\n      ctx.strokeStyle = strokeColor;\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n  }\n\n  // DRAW CREATURE: large body with quirky eyes and smile\n  function drawCreature(ctx, creature) {\n    const { x, y, size, happy } = creature;\n    ctx.save();\n\n    // Body: Blob shape with wobble\n    ctx.fillStyle = COLORS.creatures[0];\n    const wobble = 4 * Math.sin(gameState.frame / 15);\n    ctx.beginPath();\n    ctx.ellipse(x, y, size + wobble, size * 0.75 + wobble / 2, 0, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.strokeStyle = COLORS.outline;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // Face features\n    // Eyes: Big, spaced, wacky pupils\n    ctx.fillStyle = \"#fff\";\n    ctx.beginPath();\n    ctx.ellipse(x - size / 3, y - size / 6, 14, 18, 0, 0, 2 * Math.PI);\n    ctx.ellipse(x + size / 3, y - size / 6, 14, 18, 0, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n\n    // Pupils move slightly with frame for life\n    const pupilOffset = 3 * Math.sin(gameState.frame / 10);\n    ctx.fillStyle = happy ? \"#4CAF50\" : \"#000\";\n    ctx.beginPath();\n    ctx.ellipse(x - size / 3 + pupilOffset / 2, y - size / 6, 6, 10, 0, 0, 2 * Math.PI);\n    ctx.ellipse(x + size / 3 + pupilOffset / 2, y - size / 6 + Math.cos(gameState.frame / 12), 6, 10, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Mouth: smile or straight line\n    ctx.beginPath();\n    if (happy) {\n      ctx.strokeStyle = \"#4CAF50\";\n      ctx.lineWidth = 3;\n      ctx.arc(x, y + size / 6, size / 3, 0, Math.PI, false);\n    } else {\n      ctx.strokeStyle = COLORS.outline;\n      ctx.lineWidth = 3;\n      ctx.moveTo(x - size / 3, y + size / 6);\n      ctx.lineTo(x + size / 3, y + size / 6);\n    }\n    ctx.stroke();\n\n    // Display the bond question above the creature\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"bold 18px Comic Sans MS, cursive, sans-serif\";\n    const bond = creature.currentBond;\n    if (bond) {\n      const text = `Help me: ? + ? = ${bond.total}`;\n      ctx.textAlign = \"center\";\n      ctx.fillText(text, x, y - size - 20);\n    }\n\n    ctx.restore();\n  }\n\n  // DRAW FRUIT: circle with number inside and little leaves for wackiness\n  function drawFruit(ctx, fruit, isSelected = false) {\n    const { x, y, size, color, num, collected } = fruit;\n    if (collected) return; // Don't draw collected fruits\n\n    ctx.save();\n    // Fruit body\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.shadowColor = \"rgba(0,0,0,0.15)\";\n    ctx.shadowBlur = 6;\n    ctx.arc(x, y, size, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.shadowBlur = 0;\n    ctx.strokeStyle = COLORS.outline;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // Leaves - two arcs on top\n    ctx.beginPath();\n    ctx.strokeStyle = \"#4b7f1a\";\n    ctx.lineWidth = 3;\n    ctx.moveTo(x - size / 2, y - size / 2);\n    ctx.quadraticCurveTo(x - size / 3, y - size, x - size / 6, y - size / 2);\n    ctx.moveTo(x + size / 2, y - size / 2);\n    ctx.quadraticCurveTo(x + size / 3, y - size, x + size / 6, y - size / 2);\n    ctx.stroke();\n\n    // Number on fruit\n    ctx.fillStyle = \"#fff\";\n    ctx.font = `${size}px Comic Sans MS, cursive, sans-serif`;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(num, x, y);\n\n    // Selection highlight\n    if (isSelected) {\n      ctx.strokeStyle = COLORS.selectedFruitOutline;\n      ctx.lineWidth = 4;\n      ctx.beginPath();\n      ctx.arc(x, y, size + 6, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  // DRAW EXPLORER: a little explorer with backpack and hat, who moves around controlling the game\n  function drawExplorer(ctx, explorer) {\n    const { x, y, size } = explorer;\n    ctx.save();\n\n    // Body: rectangle torso\n    ctx.fillStyle = COLORS.explorer;\n    drawRoundedRect(ctx, x - size / 2, y - size / 2 + 10, size, size * 0.6, 10, COLORS.explorer, COLORS.outline);\n\n    // Head: circle\n    ctx.beginPath();\n    ctx.fillStyle = \"#f1c27d\";\n    ctx.arc(x, y - size / 3, size / 2.5, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.strokeStyle = COLORS.outline;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // Eyes\n    ctx.fillStyle = \"#000\";\n    ctx.beginPath();\n    ctx.arc(x - size / 8, y - size / 3, size / 20, 0, 2 * Math.PI);\n    ctx.arc(x + size / 8, y - size / 3, size / 20, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Mouth\n    ctx.beginPath();\n    ctx.strokeStyle = \"#6a3d00\";\n    ctx.lineWidth = 2;\n    ctx.arc(x, y - size / 4, size / 10, 0, Math.PI, false);\n    ctx.stroke();\n\n    // Backpack: rounded rectangle behind torso\n    ctx.fillStyle = \"#716aca\";\n    drawRoundedRect(ctx, x - size / 2 - 8, y - size / 2 + 15, 18, size * 0.7, 5, \"#716aca\", COLORS.outline);\n\n    // Hat: triangle on top\n    ctx.beginPath();\n    ctx.fillStyle = \"#a52a2a\";\n    ctx.moveTo(x - size / 2, y - size / 2.8);\n    ctx.lineTo(x + size / 2, y - size / 2.8);\n    ctx.lineTo(x, y - size);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  // DRAW HUD & TEXTS - score, instructions, messages\n  function drawHUD(ctx) {\n    ctx.save();\n\n    // Background panel\n    ctx.fillStyle = COLORS.hudBg;\n    ctx.fillRect(0, HEIGHT - 60, WIDTH, 60);\n    ctx.strokeStyle = COLORS.outline;\n    ctx.lineWidth = 2;\n    ctx.strokeRect(0, HEIGHT - 60, WIDTH, 60);\n\n    // Score\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"20px Comic Sans MS, cursive, sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(`Score: ${gameState.score}`, 15, HEIGHT - 30);\n\n    // Message / instruction\n    ctx.textAlign = \"center\";\n    ctx.fillText(gameState.message, WIDTH / 2, HEIGHT - 30);\n\n    // Sound toggle indicator with text + icon\n    ctx.textAlign = \"right\";\n    ctx.fillText(gameState.soundOn ? \"\ud83d\udd0a Sound On (S)\" : \"\ud83d\udd07 Sound Off (S)\", WIDTH - 15, HEIGHT - 30);\n\n    ctx.restore();\n  }\n\n  // CLEAR WHOLE CANVAS\n  function clearCanvas() {\n    ctx.fillStyle = COLORS.background;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  // LOGIC HELPERS\n\n  // Distance squared between two points for collision detection\n  function distSq(x1, y1, x2, y2) {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n    return dx * dx + dy * dy;\n  }\n\n  // Check if explorer overlaps with fruit (for \"picking up\" fruits)\n  function checkExplorerFruitCollision() {\n    const ex = gameState.explorer.x;\n    const ey = gameState.explorer.y;\n\n    // Selected fruit index corresponds to fruit in fruits array, but only those NOT collected\n    // Space or Enter to pick the selected fruit and attempt to deliver to nearest creature.\n\n    // The player picks a fruit by space or enter and then moves close to a creature to deliver.\n\n    // Only allow pickup of the selected fruit if close enough to explorer\n\n    // On selection, check if explorer collides with fruit to \"grab\" it\n\n    const fruit = gameState.fruits[gameState.selectedFruitIndex];\n    if (!fruit || fruit.collected) return;\n\n    const ds = distSq(ex, ey, fruit.x, fruit.y);\n    if (ds < (gameState.explorer.size / 2 + fruit.size) ** 2) {\n      return fruit;\n    }\n\n    return null;\n  }\n\n  // Check if explorer is close enough to any creature to deliver a selected fruit as part of the bond\n  function getNearbyCreature() {\n    const ex = gameState.explorer.x;\n    const ey = gameState.explorer.y;\n    for (const creature of gameState.creatures) {\n      const ds = distSq(ex, ey, creature.x, creature.y);\n      if (ds < (gameState.explorer.size / 2 + creature.size) ** 2) {\n        return creature;\n      }\n    }\n    return null;\n  }\n\n  // Check if delivery of fruit fits the current bond parts for a creature\n  // The creature must receive two numbers that sum to the total.\n  // Delivery order does not matter.\n\n  // Returns:\n  // 0 - not ready (need more numbers)\n  // 1 - success (sum to total)\n  // 2 - wrong (sum not total)\n  function checkDelivery(creature) {\n    const nums = creature.deliveredNums;\n    const total = creature.currentBond.total;\n    if (nums.length < 2) return 0;\n    const sum = nums.reduce((a, b) => a + b, 0);\n    if (sum === total) return 1;\n    return 2;\n  }\n\n  // PROCESS DELIVERY: after the player selects fruit and is near creature\n  function processDelivery(fruit, creature) {\n    if (!fruit || !creature) {\n      gameState.message = \"Move close to a creature to deliver fruit\";\n      playWrongSound();\n      return;\n    }\n\n    if (fruit.collected) {\n      gameState.message = \"That fruit is already used!\";\n      playWrongSound();\n      return;\n    }\n\n    creature.deliveredNums.push(fruit.num);\n    fruit.collected = true;\n\n    const result = checkDelivery(creature);\n    if (result === 0) {\n      gameState.message = `Delivered ${fruit.num}. One more fruit to go!`;\n      playTone(600, 0.12, \"triangle\");\n    } else if (result === 1) {\n      // Success! Creature becomes happy\n      gameState.score += 5;\n      creature.happy = true;\n      gameState.message = \"Yay! The creature is happy and thanks you!\";\n      playCorrectSound();\n      // Reset for next bond after delay\n      setTimeout(() => {\n        creature.happy = false;\n        creature.currentBond = generateNumberBond();\n        creature.deliveredNums = [];\n      }, 4000);\n    } else {\n      // Wrong sum\n      gameState.score = Math.max(0, gameState.score - 3);\n      gameState.message = `Oops! The sum doesn't match ${creature.currentBond.total}. Try again!`;\n      playWrongSound();\n      // Reset deliveries and collected fruits used by this delivery attempt (only the last 2)\n      creature.deliveredNums = [];\n      // Mark all fruits again unused to retry (simple way)\n      gameState.fruits.forEach(f => (f.collected = false));\n    }\n  }\n\n  // PLAYER MOVEMENT AND CONTROLS\n\n  function updateExplorerPosition() {\n    const s = gameState.explorer.speed;\n    if (gameState.keysPressed[\"ArrowUp\"]) {\n      gameState.explorer.y = Math.max(gameState.explorer.size / 2, gameState.explorer.y - s);\n    }\n    if (gameState.keysPressed[\"ArrowDown\"]) {\n      gameState.explorer.y = Math.min(HEIGHT - gameState.explorer.size / 2, gameState.explorer.y + s);\n    }\n    if (gameState.keysPressed[\"ArrowLeft\"]) {\n      gameState.explorer.x = Math.max(gameState.explorer.size / 2, gameState.explorer.x - s);\n    }\n    if (gameState.keysPressed[\"ArrowRight\"]) {\n      gameState.explorer.x = Math.min(WIDTH - gameState.explorer.size / 2, gameState.explorer.x + s);\n    }\n  }\n\n  // Cycle selection index for fruit when the player presses Q or E keys\n  function cycleSelectedFruit(forward = true) {\n    if (forward) {\n      gameState.selectedFruitIndex++;\n      if (gameState.selectedFruitIndex >= gameState.fruits.length) {\n        gameState.selectedFruitIndex = 0;\n      }\n    } else {\n      gameState.selectedFruitIndex--;\n      if (gameState.selectedFruitIndex < 0) {\n        gameState.selectedFruitIndex = gameState.fruits.length - 1;\n      }\n    }\n    gameState.message = `Selected fruit ${gameState.fruits[gameState.selectedFruitIndex].num}`;\n    playTone(440, 0.08, \"square\");\n  }\n\n  // EVENT HANDLERS\n\n  function onKeyDown(e) {\n    if (e.repeat) return; // no repeats for sustain\n\n    switch (e.code) {\n      case \"ArrowUp\":\n      case \"ArrowDown\":\n      case \"ArrowLeft\":\n      case \"ArrowRight\":\n        gameState.keysPressed[e.code] = true;\n        break;\n      case \"Space\":\n      case \"Enter\":\n        e.preventDefault();\n        // Select fruit if accessible and try to deliver if near creature\n        if (!audioCtx) {\n          try {\n            audioCtx = createAudioContext();\n            if (audioCtx) {\n              playBackgroundHum();\n            }\n          } catch {}\n        }\n        const fruit = gameState.fruits[gameState.selectedFruitIndex];\n        const explorer = gameState.explorer;\n        // Check distance to fruit to pick it up\n        if (!fruit.collected && distSq(explorer.x, explorer.y, fruit.x, fruit.y) < (explorer.size / 2 + fruit.size) ** 2) {\n          // Pick fruit and try to deliver to a creature nearby\n          const creature = getNearbyCreature();\n          if (creature) {\n            processDelivery(fruit, creature);\n          } else {\n            gameState.message = \"Move close to a creature to deliver fruit\";\n            playWrongSound();\n          }\n        } else {\n          gameState.message = \"Move closer to the selected fruit first\";\n          playWrongSound();\n        }\n        break;\n      case \"KeyQ\":\n        cycleSelectedFruit(false);\n        break;\n      case \"KeyE\":\n        cycleSelectedFruit(true);\n        break;\n      case \"KeyS\":\n        // Toggle sound\n        gameState.soundOn = !gameState.soundOn;\n        if (gameState.soundOn) {\n          if (audioCtx && audioCtx.state === \"suspended\") {\n            audioCtx.resume();\n          }\n          playBackgroundHum();\n          gameState.message = \"Sound turned ON\";\n        } else {\n          stopBackgroundHum();\n          gameState.message = \"Sound turned OFF\";\n        }\n        break;\n    }\n  }\n\n  function onKeyUp(e) {\n    if (e.repeat) return;\n    if (\n      e.code === \"ArrowUp\" ||\n      e.code === \"ArrowDown\" ||\n      e.code === \"ArrowLeft\" ||\n      e.code === \"ArrowRight\"\n    ) {\n      delete gameState.keysPressed[e.code];\n    }\n  }\n\n  // GAME LOOP\n\n  function update() {\n    updateExplorerPosition();\n  }\n\n  // DRAW ALL GAME ELEMENTS\n  function draw() {\n    clearCanvas();\n\n    // Draw creatures first (background layer)\n    for (const creature of gameState.creatures) {\n      drawCreature(ctx, creature);\n    }\n\n    // Draw fruits, highlight selected\n    gameState.fruits.forEach((fruit, i) => {\n      drawFruit(ctx, fruit, i === gameState.selectedFruitIndex && !fruit.collected);\n    });\n\n    // Draw explorer on top\n    drawExplorer(ctx, gameState.explorer);\n\n    // HUD overlay\n    drawHUD(ctx);\n  }\n\n  // MAIN ANIMATION FRAME\n  function gameLoop() {\n    gameState.frame++;\n    update();\n    draw();\n    requestAnimationFrame(gameLoop);\n  }\n\n  // INITIALIZE\n  function init() {\n    try {\n      const container = document.getElementById(\"game-of-the-day-stage\");\n      if (!container) {\n        console.error(\"Error: Container element with id 'game-of-the-day-stage' not found.\");\n        return;\n      }\n      container.tabIndex = 0; // Make focusable for keyboard controls\n      container.style.outline = \"none\";\n\n      canvas = document.createElement(\"canvas\");\n      canvas.width = WIDTH;\n      canvas.height = HEIGHT;\n      canvas.setAttribute(\"role\", \"img\");\n      canvas.setAttribute(\"aria-label\", \"Open World Math Exploration Game. Use arrow keys to move, space to interact.\");\n      container.innerHTML = \"\";\n      container.appendChild(canvas);\n\n      ctx = canvas.getContext(\"2d\");\n      ctx.font = \"20px Comic Sans MS, cursive, sans-serif\";\n\n      // Audio context setup\n      audioCtx = createAudioContext();\n      if (!audioCtx) {\n        gameState.message = \"Audio not supported in this browser.\";\n      } else {\n        gainNode = audioCtx.createGain();\n        gainNode.connect(audioCtx.destination);\n        playBackgroundHum();\n      }\n\n      initializeGameObjects();\n\n      container.focus();\n\n      container.addEventListener(\"keydown\", onKeyDown);\n      container.addEventListener(\"keyup\", onKeyUp);\n      container.addEventListener(\"blur\", () => {\n        gameState.keysPressed = {};\n      });\n\n      gameState.message = \"Welcome! Use arrow keys to move, Q/E to select fruit, Space to deliver fruit.\";\n      gameLoop();\n    } catch (err) {\n      console.error(\"Initialization error:\", err);\n      alert(\"Failed to initialize the game. Your browser might not support required features.\");\n    }\n  }\n\n  window.addEventListener(\"load\", init);\n})();\n---\n",
  "improve_response_tokens": 14181,
  "formatted_code": true,
  "formatting_response_tokens": 16422,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}