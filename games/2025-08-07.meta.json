{
  "generated_date": "2025-08-07",
  "generated_timestamp": "2025-08-07T22:27:24.355045",
  "model": "gpt-5",
  "theme": "open world exploration",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: open world exploration\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 15732,
  "game_filename": "2025-08-07.js",
  "game_size_bytes": 39676,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  \"use strict\";\n\n  // Constants\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const WORLD_W = 1440;\n  const WORLD_H = 960;\n  const TARGET_STARS = 5;\n  const PLAYER_SPEED = 2.5;\n  const PLAYER_RADIUS = 14;\n  const INTERACT_DIST = 34;\n  const BG_COLOR = \"#0b2540\";\n  const ISLAND_COLOR = \"#133c55\";\n  const TEXT_COLOR = \"#ffffff\";\n\n  // DOM setup\n  const stage = document.getElementById(\"game-of-the-day-stage\");\n  if (!stage) {\n    console.error(\"game-of-the-day-stage element not found.\");\n    return;\n  }\n\n  // Clear stage and set ARIA attributes\n  stage.innerHTML = \"\";\n  stage.setAttribute(\"role\", \"application\");\n  stage.setAttribute(\"aria-label\", \"Open world math exploration game for ages 7 to 9. Use arrow keys to move. Press Enter near a character to solve a friendly math riddle.\");\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = \"block\";\n  canvas.style.outline = \"none\";\n  canvas.tabIndex = 0;\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // ARIA live region for announcements (hidden)\n  const live = document.createElement(\"div\");\n  live.setAttribute(\"aria-live\", \"polite\");\n  live.style.position = \"absolute\";\n  live.style.left = \"-9999px\";\n  live.style.top = \"-9999px\";\n  stage.appendChild(live);\n\n  // Utility\n  const rand = (min, max) => Math.random() * (max - min) + min;\n  const randInt = (min, max) => Math.floor(rand(min, max + 1));\n  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));\n  const dist2 = (x1, y1, x2, y2) => {\n    const dx = x2 - x1, dy = y2 - y1;\n    return dx * dx + dy * dy;\n  };\n\n  // Audio system\n  const Audio = {\n    ctx: null,\n    master: null,\n    ambient: { noise: null, noiseGain: null, drone: null, droneGain: null, lfo: null, lfoGain: null },\n    enabled: true,\n    supported: true,\n    started: false,\n  };\n\n  function initAudio() {\n    if (Audio.ctx || !Audio.enabled) return;\n    try {\n      const Ctx = window.AudioContext || window.webkitAudioContext;\n      if (!Ctx) {\n        Audio.supported = false;\n        return;\n      }\n      Audio.ctx = new Ctx();\n      Audio.master = Audio.ctx.createGain();\n      Audio.master.gain.value = 0.6;\n      Audio.master.connect(Audio.ctx.destination);\n      Audio.started = true;\n      startAmbient();\n    } catch (e) {\n      console.warn(\"Audio init failed:\", e);\n      Audio.supported = false;\n      Audio.enabled = false;\n    }\n  }\n\n  function ensureAudioUnlocked() {\n    if (!Audio.enabled || !Audio.supported) return;\n    if (!Audio.ctx) {\n      initAudio();\n    }\n    if (Audio.ctx && Audio.ctx.state === \"suspended\") {\n      Audio.ctx.resume().catch(() => {});\n    }\n  }\n\n  function startAmbient() {\n    if (!Audio.ctx) return;\n    // Gentle ocean-like noise\n    const bufferSize = 2 * Audio.ctx.sampleRate;\n    const noiseBuffer = Audio.ctx.createBuffer(1, bufferSize, Audio.ctx.sampleRate);\n    const output = noiseBuffer.getChannelData(0);\n    for (let i = 0; i < bufferSize; i++) {\n      output[i] = (Math.random() * 2 - 1) * 0.3;\n    }\n    const noise = Audio.ctx.createBufferSource();\n    noise.buffer = noiseBuffer;\n    noise.loop = true;\n\n    const filter = Audio.ctx.createBiquadFilter();\n    filter.type = \"lowpass\";\n    filter.frequency.value = 800;\n\n    const noiseGain = Audio.ctx.createGain();\n    noiseGain.gain.value = 0.05;\n\n    noise.connect(filter);\n    filter.connect(noiseGain);\n    noiseGain.connect(Audio.master);\n\n    // Slow soothing drone with LFO tremolo\n    const drone = Audio.ctx.createOscillator();\n    drone.type = \"sine\";\n    drone.frequency.value = 180;\n\n    const droneGain = Audio.ctx.createGain();\n    droneGain.gain.value = 0.02;\n\n    const lfo = Audio.ctx.createOscillator();\n    lfo.type = \"sine\";\n    lfo.frequency.value = 0.1;\n\n    const lfoGain = Audio.ctx.createGain();\n    lfoGain.gain.value = 0.015;\n\n    lfo.connect(lfoGain);\n    lfoGain.connect(droneGain.gain);\n\n    drone.connect(droneGain);\n    droneGain.connect(Audio.master);\n\n    noise.start();\n    drone.start();\n    lfo.start();\n\n    Audio.ambient.noise = noise;\n    Audio.ambient.noiseGain = noiseGain;\n    Audio.ambient.drone = drone;\n    Audio.ambient.droneGain = droneGain;\n    Audio.ambient.lfo = lfo;\n    Audio.ambient.lfoGain = lfoGain;\n  }\n\n  function stopAmbient() {\n    const a = Audio.ambient;\n    try {\n      if (a.noise) a.noise.stop();\n      if (a.drone) a.drone.stop();\n    } catch (e) {}\n    Audio.ambient = { noise: null, noiseGain: null, drone: null, droneGain: null, lfo: null, lfoGain: null };\n  }\n\n  function setMuted(muted) {\n    Audio.enabled = !muted;\n    if (!Audio.supported) return;\n    if (Audio.enabled) {\n      initAudio();\n      if (Audio.master) Audio.master.gain.value = 0.6;\n    } else {\n      if (Audio.master) Audio.master.gain.value = 0.0;\n    }\n  }\n\n  function playTone(freq, duration = 0.2, type = \"sine\", volume = 0.15) {\n    if (!Audio.enabled || !Audio.ctx) return;\n    try {\n      const t = Audio.ctx.currentTime;\n      const osc = Audio.ctx.createOscillator();\n      const gain = Audio.ctx.createGain();\n      osc.type = type;\n      osc.frequency.value = freq;\n      gain.gain.setValueAtTime(0, t);\n      gain.gain.linearRampToValueAtTime(volume, t + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, t + duration);\n      osc.connect(gain);\n      gain.connect(Audio.master);\n      osc.start(t);\n      osc.stop(t + duration + 0.05);\n    } catch (e) {}\n  }\n\n  function playCorrect() {\n    if (!Audio.enabled || !Audio.ctx) return;\n    // pleasant ascending chime\n    const base = 523.25; // C5\n    [base, base * 1.25, base * 1.5].forEach((f, i) => {\n      setTimeout(() => playTone(f, 0.15, \"sine\", 0.2), i * 120);\n    });\n    visualFeedback.queue.push({ type: \"correct\", t: performance.now() });\n    announce(\"Correct! Gate opens and a Star Seed appears.\");\n  }\n\n  function playWrong() {\n    if (!Audio.enabled || !Audio.ctx) return;\n    const base = 392.0; // G4\n    [base * 1.25, base, base * 0.75].forEach((f, i) => {\n      setTimeout(() => playTone(f, 0.12, \"triangle\", 0.17), i * 90);\n    });\n    // soft noise thud\n    try {\n      const o = Audio.ctx.createOscillator();\n      const g = Audio.ctx.createGain();\n      o.type = \"sawtooth\";\n      o.frequency.value = 80;\n      const t = Audio.ctx.currentTime;\n      g.gain.setValueAtTime(0.2, t);\n      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);\n      o.connect(g);\n      g.connect(Audio.master);\n      o.start(t);\n      o.stop(t + 0.2);\n    } catch (e) {}\n    visualFeedback.queue.push({ type: \"wrong\", t: performance.now() });\n    announce(\"Try again. That's not quite right.\");\n  }\n\n  function playPickup() {\n    if (!Audio.enabled || !Audio.ctx) return;\n    const base = 659.25; // E5\n    [0, 80, 160, 240].forEach((delay, i) => {\n      setTimeout(() => playTone(base * (1 + i * 0.12), 0.12, \"sine\", 0.22), delay);\n    });\n    visualFeedback.queue.push({ type: \"pickup\", t: performance.now() });\n    announce(\"Star Seed collected!\");\n  }\n\n  // Visual feedback badges queue\n  const visualFeedback = {\n    queue: [],\n    draw(ctx) {\n      const now = performance.now();\n      for (let i = this.queue.length - 1; i >= 0; i--) {\n        const fx = this.queue[i];\n        const age = (now - fx.t) / 1000;\n        if (age > 1.0) {\n          this.queue.splice(i, 1);\n          continue;\n        }\n        const alpha = 1 - age;\n        ctx.save();\n        ctx.globalAlpha = alpha;\n        let text = \"\";\n        let color = \"\";\n        if (fx.type === \"correct\") {\n          text = \"\u2713\";\n          color = \"#42e66c\";\n        } else if (fx.type === \"wrong\") {\n          text = \"\u2717\";\n          color = \"#ff6b6b\";\n        } else if (fx.type === \"pickup\") {\n          text = \"\u2605\";\n          color = \"#ffd166\";\n        }\n        ctx.fillStyle = color;\n        ctx.font = \"48px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(text, WIDTH - 40, 40 + age * -20);\n        ctx.restore();\n      }\n    }\n  };\n\n  // Game state\n  const keys = {};\n  let mouse = { x: 0, y: 0, down: false };\n  let gameState = \"title\"; // title, playing, puzzle, win\n  let lastTime = 0;\n\n  const camera = { x: 0, y: 0 };\n\n  const player = {\n    x: WORLD_W / 2,\n    y: WORLD_H / 2,\n    r: PLAYER_RADIUS,\n    speed: PLAYER_SPEED,\n    color: \"#ffd166\",\n    hatAngle: 0\n  };\n\n  let obstacles = []; // array of {x,y,w,h, color, openableId?}\n  let interactables = []; // array of NPC/Gate/Sprout\n  let stars = []; // array of star collectibles\n  let starsCollected = 0;\n\n  // Puzzles\n  let activePuzzle = null; // { ownerId, character, prompt, choices, correctIndex, tip, solved }\n  let activeChoiceIndex = 0;\n\n  function announce(text) {\n    live.textContent = text;\n  }\n\n  // World creation\n  function createWorld() {\n    obstacles = [];\n    interactables = [];\n    stars = [];\n    starsCollected = 0;\n\n    // Large island boundaries walls (keep within world edges)\n    // Perimeter walls\n    obstacles.push({ x: 0, y: 0, w: WORLD_W, h: 40, color: \"#0e2a45\" });\n    obstacles.push({ x: 0, y: WORLD_H - 40, w: WORLD_W, h: 40, color: \"#0e2a45\" });\n    obstacles.push({ x: 0, y: 0, w: 40, h: WORLD_H, color: \"#0e2a45\" });\n    obstacles.push({ x: WORLD_W - 40, y: 0, w: 40, h: WORLD_H, color: \"#0e2a45\" });\n\n    // Some fun winding walls (forest patches)\n    const forestColor = \"#0f4c5c\";\n    const rockColor = \"#1b3b5a\";\n    // central lake\n    obstacles.push({ x: WORLD_W / 2 - 220, y: WORLD_H / 2 - 150, w: 440, h: 40, color: forestColor });\n    obstacles.push({ x: WORLD_W / 2 - 220, y: WORLD_H / 2 + 110, w: 440, h: 40, color: forestColor });\n    obstacles.push({ x: WORLD_W / 2 - 220, y: WORLD_H / 2 - 150, w: 40, h: 300, color: forestColor });\n    obstacles.push({ x: WORLD_W / 2 + 180, y: WORLD_H / 2 - 150, w: 40, h: 300, color: forestColor });\n\n    // West maze\n    obstacles.push({ x: 160, y: 160, w: 300, h: 30, color: rockColor });\n    obstacles.push({ x: 160, y: 160, w: 30, h: 280, color: rockColor });\n    obstacles.push({ x: 160, y: 410, w: 240, h: 30, color: rockColor });\n    obstacles.push({ x: 400, y: 190, w: 30, h: 250, color: rockColor });\n\n    // East cliffs\n    obstacles.push({ x: WORLD_W - 490, y: 160, w: 300, h: 30, color: rockColor });\n    obstacles.push({ x: WORLD_W - 220, y: 160, w: 30, h: 280, color: rockColor });\n    obstacles.push({ x: WORLD_W - 460, y: 410, w: 270, h: 30, color: rockColor });\n\n    // South grove\n    obstacles.push({ x: WORLD_W / 2 - 330, y: WORLD_H - 260, w: 660, h: 30, color: forestColor });\n    obstacles.push({ x: WORLD_W / 2 - 330, y: WORLD_H - 260, w: 30, h: 180, color: forestColor });\n    obstacles.push({ x: WORLD_W / 2 + 300, y: WORLD_H - 260, w: 30, h: 180, color: forestColor });\n    obstacles.push({ x: WORLD_W / 2 - 300, y: WORLD_H - 110, w: 330, h: 30, color: forestColor });\n\n    // Gates (openable obstacles)\n    // Gate North - Moss the Turtle (missing addend)\n    const gateNorth = { x: WORLD_W / 2 - 30, y: 40, w: 60, h: 30, color: \"#2b2d42\", openableId: \"gateNorth\", open: false };\n    obstacles.push(gateNorth);\n    interactables.push({\n      id: \"moss\",\n      type: \"gate\",\n      name: \"Moss the Turtle\",\n      description: \"Bridge to the Lagoon\",\n      character: \"moss\",\n      x: WORLD_W / 2, y: 100,\n      gateId: \"gateNorth\",\n      puzzle: createPuzzle(\"missing\"),\n      solved: false\n    });\n\n    // Gate West - Rumble the Rock (addition)\n    const gateWest = { x: 190, y: 290, w: 30, h: 60, color: \"#2b2d42\", openableId: \"gateWest\", open: false };\n    obstacles.push(gateWest);\n    interactables.push({\n      id: \"rumble\",\n      type: \"gate\",\n      name: \"Rumble the Rock\",\n      description: \"Craggy Pass\",\n      character: \"rumble\",\n      x: 240, y: 320,\n      gateId: \"gateWest\",\n      puzzle: createPuzzle(\"sum\"),\n      solved: false\n    });\n\n    // Gate East - Comet the Fox (subtraction)\n    const gateEast = { x: WORLD_W - 220, y: 290, w: 30, h: 60, color: \"#2b2d42\", openableId: \"gateEast\", open: false };\n    obstacles.push(gateEast);\n    interactables.push({\n      id: \"comet\",\n      type: \"gate\",\n      name: \"Comet the Fox\",\n      description: \"Sunbeam Path\",\n      character: \"comet\",\n      x: WORLD_W - 260, y: 320,\n      gateId: \"gateEast\",\n      puzzle: createPuzzle(\"diff\"),\n      solved: false\n    });\n\n    // Gate South - Luma the Jelly (sum)\n    const gateSouth = { x: WORLD_W / 2 - 30, y: WORLD_H - 110, w: 60, h: 30, color: \"#2b2d42\", openableId: \"gateSouth\", open: false };\n    obstacles.push(gateSouth);\n    interactables.push({\n      id: \"luma\",\n      type: \"gate\",\n      name: \"Luma the Jelly\",\n      description: \"Glow Grove\",\n      character: \"luma\",\n      x: WORLD_W / 2, y: WORLD_H - 160,\n      gateId: \"gateSouth\",\n      puzzle: createPuzzle(\"sum\"),\n      solved: false\n    });\n\n    // Blip the Jelly Sprout - free roaming quiz that spawns star\n    interactables.push({\n      id: \"blip\",\n      type: \"npc\",\n      name: \"Blip the Jelly\",\n      description: \"Jelly Sprout Riddle\",\n      character: \"blip\",\n      x: WORLD_W / 2 + 40, y: WORLD_H / 2 - 200,\n      puzzle: createPuzzle(\"missing\"),\n      solved: false\n    });\n\n    // Place star rewards behind gates and at random spots\n    // We'll spawn stars when puzzles solved. Predefine spawn points:\n    starSpawns = {\n      gateNorth: { x: WORLD_W / 2, y: 70 },\n      gateWest: { x: 170, y: 320 },\n      gateEast: { x: WORLD_W - 170, y: 320 },\n      gateSouth: { x: WORLD_W / 2, y: WORLD_H - 85 },\n      blip: { x: WORLD_W / 2 + 110, y: WORLD_H / 2 - 230 }\n    };\n  }\n\n  let starSpawns = {};\n\n  function createPuzzle(type) {\n    // Returns a fresh puzzle object with prompt, choices, tip\n    // Types: \"sum\", \"diff\", \"missing\"\n    if (type === \"sum\") {\n      // a + b = ?\n      const a = randInt(4, 12);\n      const b = randInt(3, 9);\n      const answer = a + b;\n      const choices = generateChoices(answer, 3, 0, 30);\n      return {\n        type,\n        prompt: `Add to help: ${a} + ${b} = ?`,\n        tip: \"Tip: Try making a ten. For example: (a + b) = (a + toTen) + (rest).\",\n        choices: choices.map(x => String(x)),\n        correctIndex: choices.indexOf(answer)\n      };\n    } else if (type === \"diff\") {\n      // a - b = ?\n      const a = randInt(10, 20);\n      const b = randInt(1, Math.min(9, a - 1));\n      const answer = a - b;\n      const choices = generateChoices(answer, 3, 0, 20);\n      return {\n        type,\n        prompt: `Subtract to help: ${a} \u2212 ${b} = ?`,\n        tip: \"Tip: Count back by ones or jump to the nearest ten.\",\n        choices: choices.map(x => String(x)),\n        correctIndex: choices.indexOf(answer)\n      };\n    } else {\n      // missing addend: a + ? = s\n      const a = randInt(4, 12);\n      const s = randInt(a + 4, Math.min(20, a + 10));\n      const answer = s - a;\n      const choices = generateChoices(answer, 3, 0, 15);\n      return {\n        type,\n        prompt: `Find the missing number: ${a} + ? = ${s}`,\n        tip: \"Tip: How much do we add to reach the total?\",\n        choices: choices.map(x => String(x)),\n        correctIndex: choices.indexOf(answer)\n      };\n    }\n  }\n\n  function generateChoices(correct, count, min, max) {\n    const set = new Set();\n    set.add(correct);\n    while (set.size < count) {\n      let delta = randInt(-3, 3);\n      if (delta === 0) delta = randInt(1, 3);\n      let candidate = correct + delta;\n      candidate = clamp(candidate, min, max);\n      set.add(candidate);\n    }\n    // shuffle\n    const arr = Array.from(set);\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  // Drawing helpers\n  function drawWorld() {\n    // Background water gradient\n    drawWater();\n\n    // Island wavy edges as subtle dots\n    drawIsland();\n\n    // Decorative floating jelly blobs\n    drawJellies();\n\n    // Obstacles\n    for (const o of obstacles) {\n      ctx.fillStyle = o.color || \"#173953\";\n      ctx.fillRect(o.x, o.y, o.w, o.h);\n      if (o.openableId && !o.open) {\n        // draw gate arch and sign\n        drawGateDecoration(o);\n      }\n    }\n\n    // Stars\n    for (const s of stars) {\n      drawStar(s.x, s.y, s.r, s.phase);\n    }\n\n    // Interactables characters\n    for (const it of interactables) {\n      drawCharacter(it);\n    }\n\n    // Player\n    drawPlayer();\n  }\n\n  function drawWater() {\n    const g = ctx.createLinearGradient(0, 0, 0, WORLD_H);\n    g.addColorStop(0, \"#082032\");\n    g.addColorStop(1, \"#0b2540\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WORLD_W, WORLD_H);\n    // gentle sparkles\n    const t = performance.now() * 0.001;\n    ctx.globalAlpha = 0.08;\n    for (let i = 0; i < 40; i++) {\n      const x = (i * 123.45 + t * 33) % WORLD_W;\n      const y = (i * 67.89 + t * 21) % WORLD_H;\n      ctx.fillStyle = i % 2 ? \"#0f3a5a\" : \"#0d3250\";\n      ctx.fillRect(x, y, 80, 2);\n    }\n    ctx.globalAlpha = 1;\n  }\n\n  function drawIsland() {\n    // Main land area approximated by a big rounded rectangle inside the world margins\n    ctx.fillStyle = ISLAND_COLOR;\n    ctx.beginPath();\n    const pad = 60;\n    ctx.moveTo(pad, pad + 20);\n    ctx.lineTo(WORLD_W - pad, pad);\n    ctx.lineTo(WORLD_W - pad, WORLD_H - pad);\n    ctx.lineTo(pad, WORLD_H - pad);\n    ctx.closePath();\n    ctx.globalAlpha = 0.9;\n    ctx.fill();\n    ctx.globalAlpha = 1;\n\n    // Patterns on island\n    ctx.globalAlpha = 0.15;\n    ctx.fillStyle = \"#a7c957\";\n    for (let i = 0; i < 80; i++) {\n      const x = (i * 137) % (WORLD_W - 2 * pad) + pad;\n      const y = ((i * 53) % (WORLD_H - 2 * pad)) + pad;\n      ctx.beginPath();\n      ctx.arc(x, y, 6 + (i % 3), 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.globalAlpha = 1;\n  }\n\n  function drawJellies() {\n    const t = performance.now() * 0.001;\n    for (let i = 0; i < 12; i++) {\n      const x = 100 + (i * 110) % (WORLD_W - 200);\n      const y = 120 + ((i * 70) % (WORLD_H - 240));\n      const bob = Math.sin(t * (0.8 + i * 0.07) + i) * 6;\n      const r = 10 + (i % 3) * 4;\n      ctx.save();\n      ctx.translate(x, y + bob);\n      ctx.fillStyle = i % 2 ? \"#98c1d9\" : \"#9d4edd\";\n      ctx.globalAlpha = 0.2;\n      ctx.beginPath();\n      ctx.arc(0, 0, r, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n      ctx.restore();\n    }\n  }\n\n  function drawGateDecoration(o) {\n    // Stone arch above gate\n    ctx.save();\n    ctx.fillStyle = \"#3b3d5b\";\n    ctx.strokeStyle = \"#202235\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.rect(o.x - 5, o.y - 10, o.w + 10, 10);\n    ctx.fill();\n    ctx.stroke();\n    // little shinies\n    ctx.fillStyle = \"#8d99ae\";\n    for (let i = 0; i < 3; i++) {\n      ctx.fillRect(o.x + 10 + i * 15, o.y - 8, 6, 4);\n    }\n    ctx.restore();\n  }\n\n  function drawStar(x, y, r, phase) {\n    const t = performance.now() * 0.001 + (phase || 0);\n    const scale = 1 + Math.sin(t * 3) * 0.1;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.scale(scale, scale);\n    ctx.beginPath();\n    const spikes = 5;\n    const outer = r;\n    const inner = r * 0.5;\n    let rot = Math.PI / 2 * 3;\n    let cx = 0, cy = 0;\n    ctx.moveTo(0, -outer);\n    for (let i = 0; i < spikes; i++) {\n      cx = Math.cos(rot) * outer;\n      cy = Math.sin(rot) * outer;\n      ctx.lineTo(cx, cy);\n      rot += Math.PI / spikes;\n      cx = Math.cos(rot) * inner;\n      cy = Math.sin(rot) * inner;\n      ctx.lineTo(cx, cy);\n      rot += Math.PI / spikes;\n    }\n    ctx.lineTo(0, -outer);\n    ctx.closePath();\n    const g = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);\n    g.addColorStop(0, \"#ffe66d\");\n    g.addColorStop(1, \"#f4a261\");\n    ctx.fillStyle = g;\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawCharacter(it) {\n    const t = performance.now() * 0.001;\n    const bob = Math.sin(t * 2 + it.x * 0.01) * 3;\n\n    ctx.save();\n    ctx.translate(it.x, it.y + bob);\n\n    // Interaction ring highlight\n    if (nearInteractable(it)) {\n      ctx.strokeStyle = \"#ffe66d\";\n      ctx.lineWidth = 3;\n      ctx.globalAlpha = 0.7;\n      ctx.beginPath();\n      ctx.arc(0, 0, 28, 0, Math.PI * 2);\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n\n    // Draw character based on type\n    if (it.character === \"moss\") {\n      // Turtle\n      ctx.fillStyle = \"#2a9d8f\";\n      ctx.beginPath();\n      ctx.arc(0, 0, 18, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = \"#264653\";\n      ctx.fillRect(-16, -8, 32, 16);\n      ctx.fillStyle = \"#e9c46a\";\n      ctx.fillRect(-4, -14, 8, 8);\n    } else if (it.character === \"comet\") {\n      // Fox\n      ctx.fillStyle = \"#e76f51\";\n      ctx.beginPath();\n      ctx.arc(0, 0, 16, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = \"#2a9d8f\";\n      ctx.beginPath();\n      ctx.moveTo(-16, 0);\n      ctx.lineTo(-30, -8);\n      ctx.lineTo(-16, -2);\n      ctx.closePath();\n      ctx.fill();\n      ctx.fillStyle = \"#fff\";\n      ctx.fillRect(-6, -6, 12, 6);\n    } else if (it.character === \"rumble\") {\n      // Rock spirit\n      ctx.fillStyle = \"#6c757d\";\n      ctx.beginPath();\n      ctx.arc(0, 0, 18, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = \"#343a40\";\n      ctx.fillRect(-10, -6, 20, 3);\n    } else if (it.character === \"luma\") {\n      // Jelly\n      ctx.fillStyle = \"#9d4edd\";\n      ctx.beginPath();\n      ctx.arc(0, 0, 16, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = \"#ffd6ff\";\n      ctx.fillRect(-10, 6, 20, 4);\n    } else if (it.character === \"blip\") {\n      ctx.fillStyle = \"#00b4d8\";\n      ctx.beginPath();\n      ctx.arc(0, 0, 14, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = \"#caf0f8\";\n      ctx.fillRect(-8, 4, 16, 4);\n    } else {\n      // default sign\n      ctx.fillStyle = \"#ced4da\";\n      ctx.fillRect(-10, -20, 20, 40);\n    }\n\n    // Name tag\n    ctx.font = \"12px sans-serif\";\n    ctx.fillStyle = \"#ffffff\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(it.name, 0, -28);\n\n    ctx.restore();\n  }\n\n  function drawPlayer() {\n    const t = performance.now() * 0.001;\n    const bob = Math.sin(t * 6) * 1.5;\n\n    ctx.save();\n    ctx.translate(player.x, player.y + bob);\n\n    // body\n    ctx.beginPath();\n    ctx.fillStyle = player.color;\n    ctx.arc(0, 0, player.r, 0, Math.PI * 2);\n    ctx.fill();\n\n    // hat\n    ctx.save();\n    player.hatAngle += 0.02;\n    ctx.rotate(Math.sin(player.hatAngle) * 0.1);\n    ctx.fillStyle = \"#2b2d42\";\n    ctx.fillRect(-player.r * 0.7, -player.r - 6, player.r * 1.4, 6);\n    ctx.fillStyle = \"#8d99ae\";\n    ctx.fillRect(-player.r * 0.3, -player.r - 14, player.r * 0.6, 8);\n    ctx.restore();\n\n    // eyes\n    ctx.fillStyle = \"#000\";\n    ctx.beginPath();\n    ctx.arc(-4, -3, 2, 0, Math.PI * 2);\n    ctx.arc(4, -3, 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  // Camera\n  function updateCamera() {\n    camera.x = clamp(player.x - WIDTH / 2, 0, WORLD_W - WIDTH);\n    camera.y = clamp(player.y - HEIGHT / 2, 0, WORLD_H - HEIGHT);\n    ctx.setTransform(1, 0, 0, 1, -camera.x, -camera.y);\n  }\n\n  // Collision\n  function resolveCollisions(px, py, r) {\n    let x = px, y = py;\n    for (const o of obstacles) {\n      if (o.openableId && o.open) continue;\n      const closestX = clamp(x, o.x, o.x + o.w);\n      const closestY = clamp(y, o.y, o.y + o.h);\n      const dx = x - closestX;\n      const dy = y - closestY;\n      const d2 = dx * dx + dy * dy;\n      if (d2 < r * r) {\n        const d = Math.sqrt(d2) || 0.0001;\n        const nx = dx / d;\n        const ny = dy / d;\n        const overlap = r - d;\n        x += nx * overlap;\n        y += ny * overlap;\n      }\n    }\n    return { x, y };\n  }\n\n  function nearInteractable(it) {\n    return dist2(player.x, player.y, it.x, it.y) <= (INTERACT_DIST * INTERACT_DIST);\n  }\n\n  // Puzzle UI\n  function openPuzzleFor(interactable) {\n    activePuzzle = {\n      ownerId: interactable.id,\n      gateId: interactable.gateId || null,\n      character: interactable.name,\n      prompt: interactable.puzzle.prompt,\n      tip: interactable.puzzle.tip,\n      choices: interactable.puzzle.choices.slice(),\n      correctIndex: interactable.puzzle.correctIndex,\n      solved: false\n    };\n    activeChoiceIndex = 0;\n    gameState = \"puzzle\";\n  }\n\n  function answerPuzzle(choiceIndex) {\n    const correct = choiceIndex === activePuzzle.correctIndex;\n    if (correct) {\n      activePuzzle.solved = true;\n      // Mark interactable solved, open gates, spawn star\n      const it = interactables.find(i => i.id === activePuzzle.ownerId);\n      if (it) it.solved = true;\n      if (activePuzzle.gateId) {\n        const gate = obstacles.find(o => o.openableId === activePuzzle.gateId);\n        if (gate) {\n          gate.open = true;\n        }\n      }\n      // Spawn star at designated spot if exists\n      const spawnKey = activePuzzle.gateId || activePuzzle.ownerId;\n      const spawn = starSpawns[spawnKey];\n      if (spawn) {\n        stars.push({ x: spawn.x, y: spawn.y, r: 12, phase: Math.random() * 10, taken: false });\n      }\n      playCorrect();\n    } else {\n      playWrong();\n    }\n    // Refresh puzzle for repeat if wrong\n    if (!correct) {\n      // Provide a slight variation on choices\n      const it = interactables.find(i => i.id === activePuzzle.ownerId);\n      if (it) {\n        it.puzzle = createPuzzle(it.puzzle.type);\n        activePuzzle.prompt = it.puzzle.prompt;\n        activePuzzle.tip = it.puzzle.tip;\n        activePuzzle.choices = it.puzzle.choices.slice();\n        activePuzzle.correctIndex = it.puzzle.correctIndex;\n      }\n    } else {\n      // Close puzzle on success\n      setTimeout(() => {\n        activePuzzle = null;\n        gameState = \"playing\";\n      }, 600);\n    }\n  }\n\n  // UI overlays\n  function drawTitle() {\n    ctx.setTransform(1,0,0,1,0,0);\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Title art\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#14213d\");\n    g.addColorStop(1, \"#1b4965\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    ctx.fillStyle = \"#ffe66d\";\n    ctx.font = \"28px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Jelly Isles: Open Math Explorer\", WIDTH / 2, 80);\n\n    ctx.fillStyle = \"#e0fbfc\";\n    ctx.font = \"16px sans-serif\";\n    ctx.fillText(\"A playful open-world about addition and subtraction (ages 7-9)\", WIDTH / 2, 112);\n\n    // Characters preview\n    const cx = WIDTH / 2;\n    const cy = 200;\n\n    // Draw circle with mini characters\n    ctx.save();\n    ctx.translate(cx, cy);\n    const names = [\n      { char: \"moss\", name: \"Moss\" },\n      { char: \"comet\", name: \"Comet\" },\n      { char: \"rumble\", name: \"Rumble\" },\n      { char: \"luma\", name: \"Luma\" },\n      { char: \"blip\", name: \"Blip\" },\n    ];\n    names.forEach((n, i) => {\n      const angle = (i / names.length) * Math.PI * 2;\n      const x = Math.cos(angle) * 120;\n      const y = Math.sin(angle) * 60;\n      drawCharacter({ x: cx + x, y: cy + y, name: n.name, character: n.char });\n    });\n    ctx.restore();\n\n    // Instructions\n    ctx.fillStyle = \"#e0fbfc\";\n    ctx.textAlign = \"left\";\n    const lines = [\n      \"How to play:\",\n      \"\u2022 Explore the island with Arrow Keys or WASD.\",\n      \"\u2022 Walk up to friendly creatures. Press Enter to talk.\",\n      \"\u2022 Solve their math riddle to open gates and spawn Star Seeds.\",\n      \"\u2022 Collect 5 Star Seeds to win!\",\n      \"Controls: Enter = Interact/Confirm, 1-3 = Answer, M = Mute, H = Help\",\n      \"Accessibility: All puzzles are keyboard accessible. Visual cues show feedback.\",\n      \"Press Enter to begin.\"\n    ];\n    ctx.font = \"14px sans-serif\";\n    let y = 280;\n    for (const line of lines) {\n      ctx.fillText(line, 60, y);\n      y += 20;\n    }\n\n    // Speaker indicator\n    drawSpeakerIcon(WIDTH - 40, 40, Audio.enabled);\n  }\n\n  function drawHelpOverlay() {\n    ctx.save();\n    ctx.setTransform(1,0,0,1,0,0);\n    ctx.globalAlpha = 0.85;\n    ctx.fillStyle = \"#000\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.globalAlpha = 1;\n\n    ctx.fillStyle = \"#ffffff\";\n    ctx.font = \"20px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Help & Tips\", WIDTH / 2, 60);\n    ctx.font = \"14px sans-serif\";\n    const text = [\n      \"\u2022 Move with Arrow Keys or WASD\",\n      \"\u2022 Press Enter to talk and confirm answers\",\n      \"\u2022 Use 1, 2, or 3 to choose an answer\",\n      \"\u2022 Press M to mute/unmute sounds\",\n      \"\u2022 Press H to close this help\",\n      \"Math Tips:\",\n      \"\u2022 Making 10 helps addition: 8 + 6 = 8 + 2 + 4 = 10 + 4\",\n      \"\u2022 For subtraction, hop back on a number line: 14 \u2212 5 = 14 \u2192 10 (\u22124) \u2192 9 (\u22121) = 9\"\n    ];\n    let y = 100;\n    for (const l of text) {\n      ctx.fillText(l, WIDTH / 2, y);\n      y += 22;\n    }\n    ctx.restore();\n  }\n\n  function drawPuzzleOverlay() {\n    ctx.setTransform(1,0,0,1,0,0);\n    ctx.save();\n    ctx.globalAlpha = 0.85;\n    ctx.fillStyle = \"#1d3557\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.globalAlpha = 1;\n\n    // Character badge\n    ctx.fillStyle = \"#e63946\";\n    ctx.fillRect(40, 40, 80, 80);\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(activePuzzle.character, 80, 98);\n\n    // Title and prompt\n    ctx.fillStyle = \"#a8dadc\";\n    ctx.font = \"18px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Riddle:\", 140, 60);\n    ctx.fillStyle = \"#f1faee\";\n    ctx.font = \"22px sans-serif\";\n    wrapText(ctx, activePuzzle.prompt, 140, 90, WIDTH - 180, 26);\n\n    // Choices\n    const baseY = 200;\n    const boxes = [];\n    for (let i = 0; i < activePuzzle.choices.length; i++) {\n      const x = 140;\n      const y = baseY + i * 64;\n      const w = WIDTH - 280;\n      const h = 48;\n      boxes.push({ x, y, w, h });\n      // background box\n      ctx.fillStyle = i === activeChoiceIndex ? \"#2a9d8f\" : \"#457b9d\";\n      ctx.fillRect(x, y, w, h);\n      ctx.strokeStyle = \"#1d3557\";\n      ctx.lineWidth = 3;\n      ctx.strokeRect(x, y, w, h);\n\n      // label\n      ctx.fillStyle = \"#f1faee\";\n      ctx.font = \"20px sans-serif\";\n      ctx.textAlign = \"left\";\n      ctx.fillText(`${i + 1}. ${activePuzzle.choices[i]}`, x + 12, y + 30);\n    }\n\n    // Tip\n    ctx.fillStyle = \"#a8dadc\";\n    ctx.font = \"14px sans-serif\";\n    wrapText(ctx, activePuzzle.tip, 140, baseY + activePuzzle.choices.length * 64 + 30, WIDTH - 180, 20);\n\n    // Instruction\n    ctx.fillStyle = \"#f1faee\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Press 1, 2, or 3 to answer. Enter confirms. Esc to cancel.\", WIDTH / 2, HEIGHT - 24);\n\n    // Speaker\n    drawSpeakerIcon(WIDTH - 40, 40, Audio.enabled);\n\n    // store clickable regions for mouse\n    puzzleBoxes = boxes;\n    ctx.restore();\n  }\n\n  let puzzleBoxes = [];\n\n  function drawHUD() {\n    ctx.setTransform(1,0,0,1,0,0);\n    // HUD bar\n    ctx.globalAlpha = 0.9;\n    ctx.fillStyle = \"rgba(0,0,0,0.35)\";\n    ctx.fillRect(0, 0, WIDTH, 40);\n    ctx.globalAlpha = 1;\n\n    // Stars collected\n    for (let i = 0; i < TARGET_STARS; i++) {\n      const x = 12 + i * 22;\n      const y = 20;\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.scale(0.6, 0.6);\n      ctx.globalAlpha = i < starsCollected ? 1 : 0.4;\n      drawStar(0, 0, 12, i * 0.3);\n      ctx.restore();\n    }\n    ctx.fillStyle = \"#ffffff\";\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Stars: ${starsCollected}/${TARGET_STARS}`, 12 + TARGET_STARS * 22 + 8, 26);\n\n    // Instructions snippet\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Move: Arrows/WASD \u2022 Enter: Talk \u2022 H: Help \u2022 M: Mute\", WIDTH / 2, 26);\n\n    drawSpeakerIcon(WIDTH - 24, 20, Audio.enabled);\n  }\n\n  function drawSpeakerIcon(x, y, on) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = on ? \"#80ed99\" : \"#adb5bd\";\n    ctx.beginPath();\n    ctx.moveTo(-12, -6);\n    ctx.lineTo(-6, -6);\n    ctx.lineTo(0, -12);\n    ctx.lineTo(0, 12);\n    ctx.lineTo(-6, 6);\n    ctx.lineTo(-12, 6);\n    ctx.closePath();\n    ctx.fill();\n    if (on) {\n      ctx.strokeStyle = \"#80ed99\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(2, 0, 6, -0.8, 0.8);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(4, 0, 10, -0.8, 0.8);\n      ctx.stroke();\n    } else {\n      ctx.strokeStyle = \"#ff6b6b\";\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(-14, -12);\n      ctx.lineTo(14, 12);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function wrapText(context, text, x, y, maxWidth, lineHeight) {\n    const words = text.split(\" \");\n    let line = \"\";\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + \" \";\n      const metrics = context.measureText(testLine);\n      if (metrics.width > maxWidth && n > 0) {\n        context.fillText(line, x, y);\n        line = words[n] + \" \";\n        y += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    context.fillText(line, x, y);\n  }\n\n  // Update\n  function update(dt) {\n    if (gameState !== \"playing\") return;\n\n    let dx = 0, dy = 0;\n    if (keys[\"ArrowLeft\"] || keys[\"a\"]) dx -= 1;\n    if (keys[\"ArrowRight\"] || keys[\"d\"]) dx += 1;\n    if (keys[\"ArrowUp\"] || keys[\"w\"]) dy -= 1;\n    if (keys[\"ArrowDown\"] || keys[\"s\"]) dy += 1;\n\n    const length = Math.hypot(dx, dy) || 1;\n    dx = (dx / length) * player.speed;\n    dy = (dy / length) * player.speed;\n\n    let nx = player.x + dx;\n    let ny = player.y + dy;\n\n    // Collide with world obstacles\n    const pos = resolveCollisions(nx, ny, player.r);\n    player.x = pos.x;\n    player.y = pos.y;\n\n    // Collect stars\n    for (const s of stars) {\n      if (s.taken) continue;\n      const d2s = dist2(player.x, player.y, s.x, s.y);\n      if (d2s <= (player.r + s.r) * (player.r + s.r)) {\n        s.taken = true;\n        starsCollected += 1;\n        playPickup();\n        if (starsCollected >= TARGET_STARS) {\n          setTimeout(() => {\n            gameState = \"win\";\n            announce(\"You collected all Star Seeds! Well done, Explorer!\");\n          }, 400);\n        }\n      }\n    }\n  }\n\n  // Main loop\n  function loop(ts) {\n    const dt = (ts - lastTime) / 1000 || 0;\n    lastTime = ts;\n\n    if (gameState === \"title\") {\n      drawTitle();\n    } else if (gameState === \"playing\") {\n      update(dt);\n      updateCamera();\n      drawWorld();\n      // Reset transform to screen space for HUD\n      drawHUD();\n      visualFeedback.draw(ctx);\n    } else if (gameState === \"puzzle\") {\n      drawPuzzleOverlay();\n      visualFeedback.draw(ctx);\n    } else if (gameState === \"win\") {\n      drawWin();\n    }\n\n    requestAnimationFrame(loop);\n  }\n\n  function drawWin() {\n    ctx.setTransform(1,0,0,1,0,0);\n    ctx.fillStyle = \"#14213d\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    // Confetti\n    for (let i = 0; i < 60; i++) {\n      ctx.fillStyle = [\"#ffd166\", \"#06d6a0\", \"#ef476f\", \"#118ab2\"][i % 4];\n      const x = (i * 91) % WIDTH;\n      const y = (i * 53 + performance.now() * 0.1) % HEIGHT;\n      ctx.fillRect(x, y, 6, 12);\n    }\n    ctx.fillStyle = \"#ffe66d\";\n    ctx.font = \"28px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"You did it, Star Explorer!\", WIDTH / 2, 140);\n    ctx.fillStyle = \"#e0fbfc\";\n    ctx.font = \"18px sans-serif\";\n    ctx.fillText(\"All 5 Star Seeds collected.\", WIDTH / 2, 180);\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(\"Press R to play again. Press H for tips. Press M to mute/unmute.\", WIDTH / 2, 220);\n    drawSpeakerIcon(WIDTH - 40, 40, Audio.enabled);\n  }\n\n  // Event handlers\n  canvas.addEventListener(\"keydown\", (e) => {\n    keys[e.key] = true;\n\n    if (e.key === \"Enter\") {\n      ensureAudioUnlocked();\n    }\n\n    if (gameState === \"title\" && e.key === \"Enter\") {\n      gameState = \"playing\";\n      announce(\"Game started. Explore the island and find friendly characters.\");\n      return;\n    }\n\n    if (e.key === \"m\" || e.key === \"M\") {\n      setMuted(Audio.enabled); // toggle\n      setMuted(!Audio.enabled);\n    }\n    if (e.key === \"h\" || e.key === \"H\") {\n      if (gameState === \"playing\") {\n        gameState = \"help\";\n      } else if (gameState === \"help\") {\n        gameState = \"playing\";\n      } else if (gameState === \"win\") {\n        gameState = \"help\";\n      } else if (gameState === \"puzzle\") {\n        // ignore\n      } else if (gameState === \"title\") {\n        // ignore\n      }\n    }\n\n    if (gameState === \"playing\" && e.key === \"Enter\") {\n      const it = interactables.find(i => nearInteractable(i));\n      if (it) {\n        openPuzzleFor(it);\n      }\n    }\n\n    if (gameState === \"playing\") {\n      if (keys[\"Escape\"]) {\n        // ignore or future pause\n      }\n    } else if (gameState === \"puzzle\") {\n      if (e.key === \"Escape\") {\n        activePuzzle = null;\n        gameState = \"playing\";\n      }\n      if (e.key === \"ArrowUp\" || e.key === \"w\") {\n        activeChoiceIndex = (activeChoiceIndex - 1 + 3) % 3;\n      }\n      if (e.key === \"ArrowDown\" || e.key === \"s\") {\n        activeChoiceIndex = (activeChoiceIndex + 1) % 3;\n      }\n      if (e.key === \"1\" || e.key === \"2\" || e.key === \"3\") {\n        const idx = parseInt(e.key, 10) - 1;\n        answerPuzzle(idx);\n      }\n      if (e.key === \"Enter\") {\n        answerPuzzle(activeChoiceIndex);\n      }\n    } else if (gameState === \"win\") {\n      if (e.key === \"r\" || e.key === \"R\") {\n        restart();\n      }\n    }\n\n    e.preventDefault();\n  });\n\n  canvas.addEventListener(\"keyup\", (e) => {\n    keys[e.key] = false;\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = e.clientX - rect.left;\n    mouse.y = e.clientY - rect.top;\n  });\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    mouse.down = true;\n    ensureAudioUnlocked();\n\n    if (gameState === \"title\") {\n      gameState = \"playing\";\n      announce(\"Game started. Explore the island and find friendly characters.\");\n    } else if (gameState === \"puzzle\") {\n      // Check clicks on choices\n      const mx = mouse.x;\n      const my = mouse.y;\n      for (let i = 0; i < puzzleBoxes.length; i++) {\n        const b = puzzleBoxes[i];\n        if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {\n          activeChoiceIndex = i;\n          answerPuzzle(i);\n        }\n      }\n    } else if (gameState === \"win\") {\n      restart();\n    }\n  });\n\n  canvas.addEventListener(\"mouseup\", (e) => {\n    mouse.down = false;\n  });\n\n  // Focus canvas to receive keyboard input\n  canvas.addEventListener(\"click\", () => {\n    canvas.focus();\n  });\n\n  // Restart\n  function restart() {\n    player.x = WORLD_W / 2;\n    player.y = WORLD_H / 2;\n    createWorld();\n    gameState = \"playing\";\n    announce(\"New game started.\");\n  }\n\n  // Initialize\n  function init() {\n    createWorld();\n    lastTime = performance.now();\n    requestAnimationFrame(loop);\n    announce(\"Welcome to Jelly Isles. Press Enter to begin.\");\n  }\n\n  // Start\n  init();\n\n  // Render world relative to camera before each draw\n  const originalFillRect = ctx.fillRect.bind(ctx);\n  // Nothing to override; we manage transforms explicitly.\n\n  // Game render integration: wrap drawWorld calls with camera transform\n  // We already set transform in updateCamera.\n\n  // Extra: Interaction prompt on screen when near an interactable (draw within world)\n  const _drawWorld = drawWorld;\n  drawWorld = function () {\n    _drawWorld();\n    // Show interaction tooltip if near\n    const it = interactables.find(i => nearInteractable(i));\n    if (it) {\n      ctx.save();\n      ctx.fillStyle = \"rgba(0,0,0,0.5)\";\n      ctx.fillRect(player.x - 90, player.y - 60, 180, 22);\n      ctx.fillStyle = \"#ffffff\";\n      ctx.font = \"12px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(`Press Enter to talk to ${it.name}`, player.x, player.y - 45);\n      ctx.restore();\n    }\n  };\n\n  // Attach onbeforeunload to stop audio gracefully\n  window.addEventListener(\"beforeunload\", () => {\n    stopAmbient();\n    try {\n      if (Audio.ctx) Audio.ctx.close();\n    } catch (e) {}\n  });\n\n})();\n---\n",
  "improve_response_tokens": 31996,
  "formatted_code": true,
  "formatting_response_tokens": 34329,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}