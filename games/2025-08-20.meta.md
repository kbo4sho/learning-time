# Game of the Day - 2025-08-20

## Metadata
- **Generated Date:** 2025-08-20
- **Generated Time:** 2025-08-20T00:20:53.094692
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-20.js
- **File Size:** 25416 bytes
- **Tokens Used:** 8661

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-20.js` - The playable game
- `2025-08-20.meta.json` - Machine-readable metadata
- `2025-08-20.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17630

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19096

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Electricity Math Game for ages 7-9
  // Renders into element with ID "game-of-the-day-stage"
  // Canvas size: 720x480
  // All visuals drawn via Canvas API. Sounds via Web Audio API.
  // Accessible: keyboard controls, aria-label, visual cues for audio.

  // -----------------------
  // Setup and safety checks
  // -----------------------
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error('Element with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container
  container.innerHTML = "";

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = "720px";
  canvas.style.height = "480px";
  canvas.tabIndex = 0; // make keyboard-focusable
  canvas.setAttribute("role", "application");
  canvas.setAttribute(
    "aria-label",
    "Electric City Math Game. Use keyboard or mouse to place batteries to match lamp power targets. Press M to mute or unmute audio."
  );
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");

  // Handle high DPI
  function setupHiDPI() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = 720 * dpr;
    canvas.height = 480 * dpr;
    canvas.style.width = "720px";
    canvas.style.height = "480px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  setupHiDPI();

  // -----------------------
  // Audio setup with error handling
  // -----------------------
  let audioCtx = null;
  let globalGain = null;
  let isMuted = false;
  let backgroundNode = null;

  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (AudioCtx) {
      audioCtx = new AudioCtx();
      globalGain = audioCtx.createGain();
      globalGain.gain.value = 0.25; // gentle overall volume
      globalGain.connect(audioCtx.destination);

      // Create gentle background hum using oscillator + subtle filter
      const humOsc = audioCtx.createOscillator();
      const humGain = audioCtx.createGain();
      const humFilter = audioCtx.createBiquadFilter();
      humOsc.type = "sine";
      humOsc.frequency.value = 55; // low hum
      humGain.gain.value = 0.06;
      humFilter.type = "lowpass";
      humFilter.frequency.value = 200;
      humOsc.connect(humFilter);
      humFilter.connect(humGain);
      humGain.connect(globalGain);
      humOsc.start();
      backgroundNode = { osc: humOsc, gain: humGain, filter: humFilter };
    } else {
      console.warn("Web Audio API not supported in this browser.");
    }
  } catch (e) {
    console.error("Audio initialization failed:", e);
    audioCtx = null;
  }

  function resumeAudioContext() {
    if (!audioCtx) return;
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => {
        console.warn("Audio resume failed:", e);
      });
    }
  }

  // Sound helpers (oscillators with envelopes)
  function playTone({ freq = 440, duration = 0.25, type = "sine", gain = 0.2 }) {
    if (!audioCtx || isMuted) return;
    try {
      resumeAudioContext();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g);
      g.connect(globalGain);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(gain, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.02);
    } catch (e) {
      console.warn("playTone failed:", e);
    }
  }

  function playSuccess() {
    // pleasant rising triad
    if (!audioCtx || isMuted) return;
    try {
      resumeAudioContext();
      const now = audioCtx.currentTime;
      const freqs = [660, 880, 990];
      freqs.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = i === 1 ? "triangle" : "sine";
        o.frequency.value = f;
        g.gain.value = 0.12;
        o.connect(g);
        g.connect(globalGain);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.linearRampToValueAtTime(0.12, now + 0.02 + 0.02 * i);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.35 + 0.05 * i);
        o.start(now + 0.02 * i);
        o.stop(now + 0.45 + 0.05 * i);
      });
    } catch (e) {
      console.warn("playSuccess failed:", e);
    }
  }

  function playError() {
    // short buzz
    if (!audioCtx || isMuted) return;
    try {
      resumeAudioContext();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.type = "square";
      o.frequency.value = 140;
      f.type = "highpass";
      f.frequency.value = 100;
      g.gain.value = 0.18;
      o.connect(f);
      f.connect(g);
      g.connect(globalGain);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.001, now);
      g.gain.linearRampToValueAtTime(0.18, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
      o.start(now);
      o.stop(now + 0.26);
    } catch (e) {
      console.warn("playError failed:", e);
    }
  }

  function playClick() {
    playTone({ freq: 880, duration: 0.08, type: "square", gain: 0.08 });
  }

  // -----------------------
  // Game data and helpers
  // -----------------------
  const STATE = {
    batteries: [], // battery objects
    target: 10,
    placed: [], // placed battery indices
    round: 1,
    score: 0,
    message: "Welcome! Charge the lamp to the exact power target.",
    focusedIndex: 0,
    dragging: null, // { idx, offsetX, offsetY }
    lastActionTime: 0,
  };

  const CHARACTERS = {
    professor: { name: "Professor Volt", color: "#4C4EFF" },
    sparky: { name: "Sparky the Squirrel", color: "#FF9F4C" },
    bulby: { name: "Bulby the Bulb", color: "#FFF374" },
  };

  // Initialize a round
  function newRound(round = 1) {
    STATE.round = round;
    STATE.placed = [];
    STATE.batteries = [];
    STATE.message = `${CHARACTERS.professor.name}: "Let's power the lamp!"`;
    // target grows slowly
    STATE.target = Math.max(5, Math.min(18, 6 + Math.floor(Math.random() * 10) + Math.floor(round / 2)));
    // create 5 battery cards with values 1-9 but ensure solvability:
    // We'll create 4 random and one guaranteed to allow reachability.
    const values = [];
    for (let i = 0; i < 4; i++) {
      values.push(1 + Math.floor(Math.random() * 9));
    }
    // compute some sum of subset toward target
    let needed = STATE.target - (values.reduce((a, b) => a + b, 0) % (STATE.target + 1));
    // ensure needed in 1..9, else pick a random
    if (needed < 1 || needed > 9) {
      needed = 1 + Math.floor(Math.random() * 9);
    }
    values.push(needed);
    // shuffle
    for (let i = values.length - 1; i >= 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [values[i], values[j]] = [values[j], values[i]];
    }
    // create battery objects
    const startX = 40;
    const startY = 360;
    const gap = 128;
    for (let i = 0; i < values.length; i++) {
      const x = startX + i * gap;
      const y = startY;
      STATE.batteries.push({
        value: values[i],
        x,
        y,
        w: 100,
        h: 60,
        picked: false,
        placed: false,
        id: "b" + Date.now() + "-" + i,
      });
    }
    STATE.focusedIndex = 0;
  }

  newRound(1);

  // Utility: check mouse inside rect
  function pointInRect(px, py, r) {
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  // -----------------------
  // Input handling (mouse & touch & keyboard)
  // -----------------------
  canvas.addEventListener("mousedown", (e) => {
    resumeAudioContext();
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left);
    const my = (e.clientY - rect.top);
    // Check batteries (topmost first)
    for (let i = STATE.batteries.length - 1; i >= 0; i--) {
      const b = STATE.batteries[i];
      if (!b.placed && pointInRect(mx, my, b)) {
        STATE.dragging = {
          idx: i,
          offsetX: mx - b.x,
          offsetY: my - b.y,
        };
        b.picked = true;
        STATE.focusedIndex = i;
        playClick();
        return;
      }
    }
    // check mute button area (top-right)
    if (mx > 640 && my < 48) {
      toggleMute();
      draw();
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    if (!STATE.dragging) return;
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left);
    const my = (e.clientY - rect.top);
    const d = STATE.dragging;
    const b = STATE.batteries[d.idx];
    b.x = mx - d.offsetX;
    b.y = my - d.offsetY;
    draw();
  });

  function endDrag(e) {
    if (!STATE.dragging) return;
    const rect = canvas.getBoundingClientRect();
    const mx = (e.changedTouches ? e.changedTouches[0].clientX - rect.left : e.clientX - rect.left);
    const my = (e.changedTouches ? e.changedTouches[0].clientY - rect.top : e.clientY - rect.top);
    const d = STATE.dragging;
    const b = STATE.batteries[d.idx];
    b.picked = false;
    // If dropped in lamp area, attempt place
    if (isInLampArea(mx, my)) {
      attemptPlaceBattery(d.idx);
    } else {
      // snap back to bottom area
      snapBatteryBack(d.idx);
    }
    STATE.dragging = null;
    draw();
  }

  canvas.addEventListener("mouseup", endDrag);
  canvas.addEventListener("mouseleave", endDrag);
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.touches[0].clientX - rect.left;
    const my = e.touches[0].clientY - rect.top;
    for (let i = STATE.batteries.length - 1; i >= 0; i--) {
      const b = STATE.batteries[i];
      if (!b.placed && pointInRect(mx, my, b)) {
        STATE.dragging = {
          idx: i,
          offsetX: mx - b.x,
          offsetY: my - b.y,
        };
        b.picked = true;
        STATE.focusedIndex = i;
        playClick();
        return;
      }
    }
    // mute area
    if (mx > 640 && my < 48) {
      toggleMute();
      draw();
    }
  }, { passive: false });

  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    if (!STATE.dragging) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.touches[0].clientX - rect.left;
    const my = e.touches[0].clientY - rect.top;
    const d = STATE.dragging;
    const b = STATE.batteries[d.idx];
    b.x = mx - d.offsetX;
    b.y = my - d.offsetY;
    draw();
  }, { passive: false });

  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    endDrag(e);
  });

  // Keyboard controls
  canvas.addEventListener("keydown", (e) => {
    resumeAudioContext();
    const key = e.key;
    if (key === "ArrowRight") {
      // move focus to next battery
      focusNextBattery(1);
      e.preventDefault();
      draw();
    } else if (key === "ArrowLeft") {
      focusNextBattery(-1);
      e.preventDefault();
      draw();
    } else if (key === "Enter" || key === " ") {
      // pick up or place focused battery
      const b = STATE.batteries[STATE.focusedIndex];
      if (!b) return;
      if (!b.placed && !b.picked) {
        // pick it up: mark as picked and simulate drag to lamp center
        b.picked = true;
        b.x = 300;
        b.y = 180;
        draw();
      } else if (b.picked) {
        // drop where it is: attempt place if near lamp
        if (isInLampArea(b.x + b.w / 2, b.y + b.h / 2)) {
          attemptPlaceBattery(STATE.focusedIndex);
        } else {
          snapBatteryBack(STATE.focusedIndex);
        }
        b.picked = false;
      }
      e.preventDefault();
    } else if (key === "Backspace") {
      // remove last placed battery back to deck
      e.preventDefault();
      removeLastPlaced();
      draw();
    } else if (key.toLowerCase() === "m") {
      // toggle mute
      toggleMute();
      draw();
    } else if (key === "n") {
      // new round (for testing)
      newRound(STATE.round + 1);
      playClick();
      draw();
    }
  });

  function focusNextBattery(dir) {
    const len = STATE.batteries.length;
    if (len === 0) return;
    STATE.focusedIndex = (STATE.focusedIndex + dir + len) % len;
    // skip placed ones
    let attempts = 0;
    while (STATE.batteries[STATE.focusedIndex].placed && attempts < len) {
      STATE.focusedIndex = (STATE.focusedIndex + dir + len) % len;
      attempts++;
    }
  }

  // -----------------------
  // Game logic: placement and checks
  // -----------------------
  function isInLampArea(x, y) {
    // lamp center area at center of canvas
    const lamp = { x: 280, y: 60, w: 160, h: 160 };
    return x >= lamp.x && x <= lamp.x + lamp.w && y >= lamp.y && y <= lamp.y + lamp.h;
  }

  function attemptPlaceBattery(idx) {
    const b = STATE.batteries[idx];
    if (b.placed) return;
    // Place battery into lamp
    b.placed = true;
    b.picked = false;
    STATE.placed.push(idx);
    playClick();
    evaluateSum();
  }

  function removeLastPlaced() {
    if (STATE.placed.length === 0) {
      STATE.message = `${CHARACTERS.sparky.name}: "No batteries in the lamp yet!"`;
      playError();
      return;
    }
    const idx = STATE.placed.pop();
    const b = STATE.batteries[idx];
    b.placed = false;
    // move it back to bottom area (snap)
    snapBatteryBack(idx);
    STATE.message = `${CHARACTERS.professor.name}: "You removed a battery."`;
    playClick();
  }

  function snapBatteryBack(idx) {
    // find an available bottom slot near initial placement index
    const baseX = 40 + idx * 128;
    const baseY = 360;
    const b = STATE.batteries[idx];
    b.x = baseX;
    b.y = baseY;
  }

  function currentPlacedSum() {
    return STATE.placed.reduce((s, idx) => s + (STATE.batteries[idx]?.value || 0), 0);
  }

  function evaluateSum() {
    const sum = currentPlacedSum();
    if (sum === STATE.target) {
      // success
      STATE.score += 1;
      STATE.message = `${CHARACTERS.bulby.name}: "Bright! You matched the power!"`;
      playSuccess();
      // animate bulb glow briefly (handled in drawCount)
      setTimeout(() => {
        // start next round after a short delay
        newRound(STATE.round + 1);
        draw();
      }, 1200);
    } else if (sum > STATE.target) {
      STATE.message = `${CHARACTERS.sparky.name}: "Uh-oh, that's too much power. Remove a battery."`;
      playError();
    } else {
      STATE.message = `${CHARACTERS.professor.name}: "Good! Keep adding. Current power: ${sum}."`;
      playTone({ freq: 660, duration: 0.12, type: "sine", gain: 0.06 });
    }
  }

  // -----------------------
  // Drawing functions
  // -----------------------
  let bulbGlow = 0; // for glow animation when success

  function drawBackground() {
    // Soft gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, 480);
    g.addColorStop(0, "#eef6ff");
    g.addColorStop(1, "#f3f9f9");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, 720, 480);

    // Wacky floating electrons (calming)
    for (let i = 0; i < 8; i++) {
      ctx.beginPath();
      ctx.globalAlpha = 0.05 + (i % 3) * 0.03;
      ctx.fillStyle = ["#FFEDDD", "#E8FFF8", "#FFF6E8"][i % 3];
      const rx = (i * 137.5) % 720;
      const ry = (i * 79.3 + (Date.now() / 800) * (i % 5 + 1)) % 480;
      ctx.arc(rx, ry, 48 - (i % 4) * 6, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawLampArea() {
    // Draw central lamp and circuit
    const lampX = 280;
    const lampY = 60;
    const lampW = 160;
    const lampH = 160;

    // wires
    ctx.strokeStyle = "#9ec9ff";
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(160, 140);
    ctx.lineTo(240, 140);
    ctx.lineTo(lampX, lampY + lampH / 2);
    ctx.lineTo(lampX + lampW, lampY + lampH / 2);
    ctx.lineTo(560, 140);
    ctx.stroke();

    // bulb background
    ctx.save();
    ctx.translate(lampX + lampW / 2, lampY + lampH / 2);
    const glow = Math.min(1, bulbGlow);
    // glow layers
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.fillStyle = `rgba(255, 244, 116, ${0.06 * (4 - i) * (0.4 + 0.6 * glow)})`;
      ctx.arc(0, 0, 52 + i * 12 * glow, 0, Math.PI * 2);
      ctx.fill();
    }
    // bulb glass
    ctx.beginPath();
    ctx.fillStyle = "#fffef7";
    ctx.strokeStyle = "#ffd965";
    ctx.lineWidth = 2;
    ctx.ellipse(0, 0, 46, 58, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // filament (visual tie to numbers)
    ctx.beginPath();
    ctx.strokeStyle = "#ffb84d";
    ctx.lineWidth = 3;
    ctx.moveTo(-14, -6);
    ctx.quadraticCurveTo(0, 6 + 12 * glow, 14, -6);
    ctx.stroke();

    ctx.restore();

    // lamp plate text
    ctx.fillStyle = "#2b2b2b";
    ctx.font = "bold 14px sans-serif";
    ctx.fillText("Power Lamp", lampX + lampW / 2 - 36, lampY - 8);

    // target info box
    ctx.fillStyle = "#d7f6ff";
    ctx.fillRect(lampX + lampW + 12, lampY + lampH / 2 - 28, 140, 56);
    ctx.strokeStyle = "#9fd6ff";
    ctx.strokeRect(lampX + lampW + 12, lampY + lampH / 2 - 28, 140, 56);
    ctx.fillStyle = "#005b8a";
    ctx.font = "bold 18px sans-serif";
    ctx.fillText("Target Power:", lampX + lampW + 20, lampY + lampH / 2 - 2);
    ctx.fillStyle = "#ff6b6b";
    ctx.font = "bold 28px sans-serif";
    ctx.fillText(STATE.target.toString(), lampX + lampW + 78, lampY + lampH / 2 + 26);

    // placed battery icons inside lamp arranged
    const placed = STATE.placed;
    const slotStartX = lampX + 20;
    const slotY = lampY + lampH - 46;
    for (let i = 0; i < placed.length; i++) {
      const idx = placed[i];
      const b = STATE.batteries[idx];
      const tx = slotStartX + i * 36;
      const ty = slotY;
      // draw small battery
      drawSmallBattery(tx, ty, b.value);
    }
  }

  function drawSmallBattery(x, y, value) {
    ctx.save();
    ctx.translate(x, y);
    // body
    ctx.fillStyle = "#ffe9b8";
    ctx.strokeStyle = "#b88a3a";
    ctx.lineWidth = 1.5;
    roundRect(ctx, 0, 0, 34, 22, 4, true, true);
    // positive tip
    ctx.fillStyle = "#ffd76f";
    ctx.fillRect(28, 6, 6, 10);
    // number
    ctx.fillStyle = "#6b3b00";
    ctx.font = "bold 12px sans-serif";
    ctx.fillText(value.toString(), 8, 15);
    ctx.restore();
  }

  function drawBatteries() {
    // bottom area where batteries sit
    ctx.font = "bold 16px sans-serif";
    ctx.fillStyle = "#005b8a";
    ctx.fillText("Battery Pack (drag to lamp)", 40, 340);

    for (let i = 0; i < STATE.batteries.length; i++) {
      const b = STATE.batteries[i];
      // skip if placed, draw semi-transparent small indicator at top-right stack
      if (b.placed) {
        // draw small icon near right side for placed ones
        ctx.save();
        ctx.globalAlpha = 0.6;
        drawSmallBattery(560 + (i % 2) * 38, 320 + Math.floor(i / 2) * 28, b.value);
        ctx.restore();
        continue;
      }

      // battery card rectangle
      ctx.save();
      // highlight if focused
      if (i === STATE.focusedIndex) {
        ctx.shadowColor = "rgba(0,0,0,0.15)";
        ctx.shadowBlur = 10;
      } else {
        ctx.shadowBlur = 0;
      }

      // body
      ctx.fillStyle = "#fff9f0";
      ctx.strokeStyle = "#f0c27b";
      ctx.lineWidth = 2;
      roundRect(ctx, b.x, b.y, b.w, b.h, 10, true, true);

      // top stripe to look like battery
      ctx.fillStyle = "#ffd86b";
      ctx.fillRect(b.x + 6, b.y + 6, b.w - 12, 14);

      // battery tip
      ctx.fillStyle = "#ffdb9f";
      ctx.fillRect(b.x + b.w - 10, b.y + b.h / 2 - 8, 8, 16);

      // number
      ctx.fillStyle = "#4c2e00";
      ctx.font = "bold 26px sans-serif";
      ctx.fillText(b.value.toString(), b.x + 16, b.y + 40);

      // focus outline
      if (i === STATE.focusedIndex) {
        ctx.strokeStyle = "#668cff";
        ctx.lineWidth = 3;
        roundRect(ctx, b.x - 4, b.y - 4, b.w + 8, b.h + 8, 12, false, true);
        // keyboard hint
        ctx.fillStyle = "#005b8a";
        ctx.font = "12px sans-serif";
        ctx.fillText("Press Enter to place", b.x + 6, b.y - 8);
      }

      // if picked, make it follow top layer (we handled via position)
      if (b.picked) {
        ctx.globalAlpha = 1;
        // little shadow
        ctx.fillStyle = "rgba(0,0,0,0.06)";
        ctx.fillRect(b.x + 6, b.y + b.h + 6, b.w - 12, 8);
      }
      ctx.restore();
    }
  }

  function drawCharactersAndUI() {
    // Right side characters
    const rightX = 560;
    // Professor Volt (squares with goggles)
    ctx.save();
    ctx.fillStyle = CHARACTERS.professor.color;
    ctx.fillRect(rightX, 40, 120, 72);
    ctx.fillStyle = "#ffffff";
    ctx.font = "bold 14px sans-serif";
    ctx.fillText(CHARACTERS.professor.name, rightX + 8, 68);
    // speech bubble
    ctx.fillStyle = "#ffffff";
    roundRect(ctx, rightX - 40, 120, 200, 56, 10, true, true);
    ctx.fillStyle = "#333";
    ctx.font = "12px sans-serif";
    ctx.fillText(STATE.message, rightX - 32, 145, 176);
    ctx.restore();

    // Squirky Sparky
    ctx.save();
    ctx.fillStyle = CHARACTERS.sparky.color;
    ctx.beginPath();
    ctx.ellipse(rightX + 60, 220, 50, 36, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#663300";
    ctx.font = "bold 12px sans-serif";
    ctx.fillText(CHARACTERS.sparky.name, rightX + 22, 220);
    ctx.restore();

    // Bulby (the lamp friend)
    ctx.save();
    ctx.fillStyle = CHARACTERS.bulby.color;
    ctx.beginPath();
    ctx.arc(rightX + 60, 295, 34, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#663300";
    ctx.font = "bold 12px sans-serif";
    ctx.fillText(CHARACTERS.bulby.name, rightX + 34, 295);
    ctx.restore();

    // Score box
    ctx.fillStyle = "#eaf9ff";
    ctx.fillRect(rightX, 340, 120, 80);
    ctx.strokeStyle = "#9fd6ff";
    ctx.strokeRect(rightX, 340, 120, 80);
    ctx.fillStyle = "#004a6b";
    ctx.font = "bold 18px sans-serif";
    ctx.fillText("Score", rightX + 12, 365);
    ctx.font = "bold 28px sans-serif";
    ctx.fillText(STATE.score.toString(), rightX + 40, 402);

    // Mute icon (top-right)
    ctx.save();
    ctx.fillStyle = isMuted ? "#ff6b6b" : "#7bd389";
    ctx.beginPath();
    ctx.arc(690, 28, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = "bold 12px sans-serif";
    ctx.fillText(isMuted ? "MUT" : "SND", 678, 32);
    ctx.restore();

    // Keyboard & accessibility instructions
    ctx.fillStyle = "#2b2b2b";
    ctx.font = "12px sans-serif";
    ctx.fillText("Controls: Mouse drag or use Arrow keys + Enter.", 40, 430);
    ctx.fillText("Press M to mute/unmute. Backspace to remove last battery.", 40, 448);
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === "undefined") r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function draw() {
    // clear
    ctx.clearRect(0, 0, 720, 480);
    drawBackground();
    drawLampArea();
    drawBatteries();
    drawCharactersAndUI();

    // if audio unavailable, show visual cue
    if (!audioCtx) {
      ctx.fillStyle = "#ffdddd";
      ctx.fillRect(10, 10, 260, 32);
      ctx.fillStyle = "#660000";
      ctx.font = "12px sans-serif";
      ctx.fillText("Audio not available in this browser. Sounds disabled.", 18, 32);
    }

    // fading bulbGlow
    bulbGlow *= 0.96;

    // spoken current sum display (floating near lamp)
    const sum = currentPlacedSum();
    ctx.font = "bold 20px sans-serif";
    ctx.fillStyle = sum === STATE.target ? "#0099ff" : "#005b8a";
    ctx.fillText("Current: " + sum, 300, 240);
  }

  // animate
  let rafId = null;
  function loop() {
    draw();
    rafId = requestAnimationFrame(loop);
  }
  loop();

  // -----------------------
  // Mute toggle
  // -----------------------
  function toggleMute() {
    isMuted = !isMuted;
    if (globalGain) {
      globalGain.gain.value = isMuted ? 0 : 0.25;
    }
    // visual cue (bulb flash)
    bulbGlow = isMuted ? 0 : 1;
    // small tone if unmuting
    if (!isMuted) playTone({ freq: 880, duration: 0.12, gain: 0.06 });
  }

  // -----------------------
  // Accessibility: focus handling
  // -----------------------
  // When canvas gains focus, show thin outline
  canvas.addEventListener("focus", () => {
    canvas.style.outline = "3px solid rgba(102,140,255,0.45)";
  });
  canvas.addEventListener("blur", () => {
    canvas.style.outline = "none";
  });

  // Ensure first click resumes audio (some browsers require user gesture)
  canvas.addEventListener("pointerdown", resumeAudioContext);

  // -----------------------
  // Resizing and cleanup
  // -----------------------
  window.addEventListener("resize", () => {
    // keep logical size constant; no changes required, but ensure HiDPI remains consistent
    setupHiDPI();
    draw();
  });

  // Expose a small debugging console if needed
  // (not required but helpful for teachers)
  try {
    // nothing to export to global to avoid polluting environment
  } catch (e) {
    console.warn("Could not attach debug hooks", e);
  }

  // -----------------------
  // End of script
  // -----------------------
})();
---

