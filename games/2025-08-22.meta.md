# Game of the Day - 2025-08-22

## Metadata
- **Generated Date:** 2025-08-22
- **Generated Time:** 2025-08-22T00:21:44.202462
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-22.js
- **File Size:** 23950 bytes
- **Tokens Used:** 8502

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-22.js` - The playable game
- `2025-08-22.meta.json` - Machine-readable metadata
- `2025-08-22.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17991

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20172

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Electric Math Game (Ages 7-9)
  // Renders inside element with id "game-of-the-day-stage"
  // Canvas size: 720x480
  // All visuals drawn with canvas. All sounds generated with Web Audio API.
  // Accessibility: keyboard controls, offscreen text updates (aria-live), visual audio indicator.

  // ----- Configuration -----
  const CANVAS_W = 720;
  const CANVAS_H = 480;
  const ROUNDS = 6; // number of rounds per play
  const MIN_TARGET = 6;
  const MAX_TARGET = 15;
  const MAX_WIRES = 4;
  const MIN_WIRE_VAL = 1;
  const MAX_WIRE_VAL = 8;
  const BG_COLOR = '#0b1630'; // deep calming blue
  const PANEL_COLOR = '#0f2544';
  const WIRES_COLORS = ['#FFB400', '#FF6B6B', '#6BCB77', '#4D96FF'];

  // ----- DOM Setup and Accessibility -----
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container element with ID "game-of-the-day-stage" not found.');
    return;
  }
  container.innerHTML = ''; // clear any content
  container.style.position = 'relative';
  container.style.width = CANVAS_W + 'px';
  container.style.height = CANVAS_H + 'px';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Electric math game. Use left and right arrows to select wires, space or enter to toggle. Press S to toggle sound.');
  canvas.style.outline = 'none';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Offscreen text for screen readers and live updates
  const sr = document.createElement('div');
  sr.setAttribute('aria-live', 'polite');
  sr.style.position = 'absolute';
  sr.style.left = '-9999px';
  container.appendChild(sr);

  // Visual small button for audio (drawn on canvas too) but we need a textual state for screen readers
  let audioAvailable = false;
  let audioEnabled = true;

  // ----- Audio Setup -----
  let audioCtx = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      audioCtx = new AudioContext();
      audioAvailable = true;
    } else {
      audioAvailable = false;
    }
  } catch (e) {
    console.warn('AudioContext creation failed:', e);
    audioAvailable = false;
    audioCtx = null;
  }

  // Gain nodes and background hum
  let masterGain = null;
  let humOsc = null;
  let humGain = null;
  if (audioAvailable) {
    try {
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.6;
      masterGain.connect(audioCtx.destination);

      humOsc = audioCtx.createOscillator();
      humOsc.type = 'sine';
      humOsc.frequency.value = 110; // low hum
      humGain = audioCtx.createGain();
      humGain.gain.value = 0.02; // gentle
      humOsc.connect(humGain);
      humGain.connect(masterGain);
      humOsc.start();
    } catch (e) {
      console.warn('Audio nodes setup failed:', e);
      audioAvailable = false;
    }
  }

  // Utility to ensure AudioContext resumed on user gesture
  async function ensureAudioOnUserGesture() {
    if (!audioAvailable || !audioCtx) return false;
    try {
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }
      return true;
    } catch (e) {
      console.warn('Unable to resume audio context:', e);
      return false;
    }
  }

  // Sound effects
  function playBeep(freq = 880, duration = 0.12, type = 'sine', volume = 0.12) {
    if (!audioAvailable || !audioEnabled) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + duration + 0.02);
    } catch (e) {
      console.warn('playBeep failed:', e);
    }
  }

  function playClick() {
    playBeep(1200, 0.06, 'triangle', 0.09);
  }

  function playCorrect() {
    if (!audioAvailable || !audioEnabled) return;
    try {
      // small arpeggio celebratory
      const now = audioCtx.currentTime;
      const freqs = [880, 1320, 1760];
      freqs.forEach((f, i) => {
        const osc = audioCtx.createOscillator();
        osc.type = 'square';
        const g = audioCtx.createGain();
        g.gain.value = 0.0001;
        osc.frequency.value = f;
        osc.connect(g);
        g.connect(masterGain);
        g.gain.setValueAtTime(0.12 / (i + 1), now + i * 0.08);
        g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.08 + 0.25);
        osc.start(now + i * 0.08);
        osc.stop(now + i * 0.08 + 0.3);
      });
    } catch (e) {
      console.warn('playCorrect failed:', e);
    }
  }

  function playWrong() {
    if (!audioAvailable || !audioEnabled) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(220, now);
      osc.frequency.exponentialRampToValueAtTime(80, now + 0.18);
      g.gain.value = 0.12;
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
      osc.connect(g);
      g.connect(masterGain);
      osc.start();
      osc.stop(now + 0.22);
    } catch (e) {
      console.warn('playWrong failed:', e);
    }
  }

  // ----- Game State -----
  let round = 1;
  let score = 0;
  let target = 10;
  let wires = []; // array of {value, on, x,y for UI}
  let selectedWire = 0;
  let solved = false;
  let sparksAnimation = []; // for spark particles
  let lastTime = 0;
  let animPulse = 0;

  function newRound() {
    solved = false;
    // generate target and wires
    target = randInt(MIN_TARGET, MAX_TARGET);
    wires = [];
    // Choose random wire values but ensure some possible combo equals target
    // We'll make sure the sum of all wires >= target and also create at least one subset equal to target by greedy algorithm
    // Start by creating subset values that sum to target
    let remaining = target;
    let subsetVals = [];
    while (remaining > 0 && subsetVals.length < MAX_WIRES) {
      const val = Math.min(remaining, randInt(MIN_WIRE_VAL, Math.min(MAX_WIRE_VAL, remaining)));
      subsetVals.push(val);
      remaining -= val;
    }
    // If still remaining (shouldn't), adjust
    if (remaining > 0) subsetVals.push(remaining);
    // Fill remaining wires with random values
    while (subsetVals.length < MAX_WIRES) {
      subsetVals.push(randInt(MIN_WIRE_VAL, MAX_WIRE_VAL));
    }
    // Shuffle and set initial states off
    shuffleArray(subsetVals);
    for (let i = 0; i < MAX_WIRES; i++) {
      wires.push({
        value: subsetVals[i],
        on: false,
        x: 120 + i * 140,
        y: 260,
        width: 100,
        height: 36
      });
    }
    selectedWire = 0;
    announceForSR(`Round ${round}. Target ${target}. Use left and right arrows to select a wire. Press space or enter to toggle a wire.`);
    updateBackgroundHum();
  }

  // ----- Utilities -----
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Announce updates for screen reader
  function announceForSR(text) {
    try {
      sr.textContent = text;
    } catch (e) {
      // ignore
    }
  }

  // ----- Drawing -----
  function drawRoundedRect(x, y, w, h, r = 8, fill = true, stroke = false, strokeColor = '#000') {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) {
      ctx.fill();
    }
    if (stroke) {
      ctx.strokeStyle = strokeColor;
      ctx.stroke();
    }
  }

  function drawScene(timestamp) {
    const dt = timestamp - lastTime;
    lastTime = timestamp;
    animPulse += dt * 0.004;

    // Background
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // Soft skyline panel
    ctx.fillStyle = PANEL_COLOR;
    drawRoundedRect(20, 20, CANVAS_W - 40, 140, 12);

    // Title and characters
    drawTitle();

    // Control panel where wires live
    drawControlPanel();

    // Lamp / target display
    drawTargetLamp();

    // Score and round display
    drawScoreboard();

    // Characters and wacky elements
    drawCharacters(animPulse);

    // Sparks animation
    updateAndDrawSparks(dt);

    // Instructions (bottom)
    drawInstructions();

    // Audio indicator
    drawAudioIcon();

    // If round solved, overlay celebration
    if (solved) {
      drawCelebration();
    }

    window.requestAnimationFrame(drawScene);
  }

  function drawTitle() {
    ctx.save();
    ctx.fillStyle = '#D7E9FF';
    ctx.font = '700 28px "Arial"';
    ctx.fillText('Sparky & the Power Puzzle', 34, 56);
    ctx.font = '400 14px "Arial"';
    ctx.fillStyle = '#B7D5FF';
    ctx.fillText('Connect wires to match the power target. Add the wire numbers!', 34, 82);
    ctx.restore();
  }

  function drawControlPanel() {
    // Panel base
    ctx.save();
    ctx.fillStyle = '#0b2a2f';
    drawRoundedRect(40, 180, CANVAS_W - 80, 260, 10);
    ctx.restore();

    // Wires area
    wires.forEach((wire, i) => {
      // draw wire path
      const baseX = wire.x + wire.width / 2;
      const baseY = wire.y - 40;
      const jx = baseX;
      const jy = baseY;
      // draw twisted wacky wire
      for (let s = 0; s < 6; s++) {
        const x1 = jx + (s - 3) * 10;
        const y1 = jy + Math.sin((animPulse + i * 0.8 + s) * 0.9) * 6 + s * 10;
        ctx.beginPath();
        ctx.strokeStyle = WIRES_COLORS[i % WIRES_COLORS.length];
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.moveTo(x1 - 8, y1 - 8);
        ctx.lineTo(x1 + 8, y1 + 8);
        ctx.stroke();
      }

      // Node (button)
      ctx.fillStyle = wire.on ? WIRES_COLORS[i % WIRES_COLORS.length] : '#223447';
      drawRoundedRect(wire.x, wire.y, wire.width, wire.height, 8);

      // Value text
      ctx.fillStyle = wire.on ? '#07241b' : '#BEE6FF';
      ctx.font = '700 20px "Arial"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(wire.value.toString(), wire.x + wire.width / 2, wire.y + wire.height / 2);

      // selection highlight
      if (i === selectedWire) {
        ctx.strokeStyle = '#FFD66B';
        ctx.lineWidth = 3;
        drawRoundedRect(wire.x - 6, wire.y - 6, wire.width + 12, wire.height + 12, 10, false, true, '#FFD66B');
      }

      // wire label below
      ctx.font = '12px "Arial"';
      ctx.fillStyle = '#B9E7FF';
      ctx.fillText('wire ' + (i + 1), wire.x + wire.width / 2, wire.y + wire.height + 18);
    });
  }

  function drawTargetLamp() {
    // Lamp box
    const boxX = 480;
    const boxY = 40;
    ctx.save();
    ctx.fillStyle = '#081327';
    drawRoundedRect(boxX, boxY, 200, 120, 12);
    // target text
    ctx.fillStyle = '#E6F7FF';
    ctx.font = '600 18px "Arial"';
    ctx.fillText('Power Target', boxX + 100, boxY + 28);
    ctx.font = '700 44px "Arial"';
    ctx.fillStyle = '#FFF2B2';
    ctx.fillText(target.toString(), boxX + 100, boxY + 78);

    // Lamp graphic
    const lampX = boxX + 100;
    const lampY = boxY + 110;
    const glow = solved ? 1.4 : 1 + Math.abs(Math.sin(animPulse)) * 0.12;
    // glow
    ctx.beginPath();
    const grd = ctx.createRadialGradient(lampX, lampY - 10, 6, lampX, lampY - 10, 60);
    grd.addColorStop(0, `rgba(255,235,120,${0.15 * glow})`);
    grd.addColorStop(1, 'rgba(255,235,120,0)');
    ctx.fillStyle = grd;
    ctx.arc(lampX, lampY - 10, 60, 0, Math.PI * 2);
    ctx.fill();

    // bulb
    ctx.fillStyle = solved ? '#FFF09E' : '#FFFAE0';
    ctx.beginPath();
    ctx.ellipse(lampX, lampY - 10, 30, 36, 0, 0, Math.PI * 2);
    ctx.fill();

    // base
    ctx.fillStyle = '#B9C7D8';
    drawRoundedRect(lampX - 22, lampY + 24, 44, 12, 3);
    ctx.restore();
  }

  function drawScoreboard() {
    ctx.save();
    ctx.fillStyle = '#E9F5FF';
    ctx.font = '600 16px "Arial"';
    ctx.fillText(`Round ${round}/${ROUNDS}`, 40, 160);
    ctx.fillText(`Score ${score}`, 160, 160);
    ctx.restore();
  }

  function drawCharacters(pulse) {
    // Sparky: little spark creature
    const sx = 120;
    const sy = 110;
    ctx.save();
    // body glow
    const glow = 0.3 + Math.abs(Math.sin(pulse)) * 0.2;
    const g = ctx.createRadialGradient(sx, sy, 4, sx, sy, 40);
    g.addColorStop(0, `rgba(255,220,120,${0.8 * glow})`);
    g.addColorStop(1, 'rgba(255,220,120,0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(sx, sy, 40, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.fillStyle = '#FFD66B';
    ctx.beginPath();
    ctx.moveTo(sx, sy - 22);
    ctx.bezierCurveTo(sx + 18, sy - 10, sx + 12, sy + 18, sx, sy + 22);
    ctx.bezierCurveTo(sx - 12, sy + 18, sx - 18, sy - 10, sx, sy - 22);
    ctx.fill();

    // eyes
    ctx.fillStyle = '#07241b';
    ctx.beginPath();
    ctx.arc(sx - 8, sy - 4, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(sx + 8, sy - 4, 4, 0, Math.PI * 2);
    ctx.fill();

    // smile
    ctx.strokeStyle = '#07241b';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(sx, sy + 2, 8, 0, Math.PI);
    ctx.stroke();

    // speech bubble
    ctx.fillStyle = '#E9F5FF';
    drawRoundedRect(sx + 40, sy - 36, 200, 44, 8);
    ctx.fillStyle = '#063046';
    ctx.font = '600 14px "Arial"';
    ctx.fillText("Let's light the houses! Add wires to equal the target.", sx + 50, sy - 12);

    ctx.restore();

    // Dr. Volt (plug scientist)
    const vx = 560;
    const vy = 180;
    ctx.save();
    ctx.fillStyle = '#D6EFFA';
    drawRoundedRect(vx - 26, vy - 14, 52, 58, 8);
    ctx.fillStyle = '#123C5C';
    ctx.fillRect(vx - 18, vy + 36, 36, 10);
    ctx.fillStyle = '#123C5C';
    ctx.font = '700 12px "Arial"';
    ctx.fillText('Dr. Volt', vx, vy - 26);
    ctx.restore();
  }

  function drawInstructions() {
    ctx.save();
    ctx.fillStyle = '#BFE7FF';
    ctx.font = '12px "Arial"';
    ctx.textAlign = 'left';
    ctx.fillText('Controls: ← →  select wire   Space/Enter toggle   S sound   R reset', 40, 460);
    ctx.restore();
  }

  function drawAudioIcon() {
    // top-right small speaker
    const x = CANVAS_W - 40;
    const y = 24;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = audioAvailable ? (audioEnabled ? '#BFF1C2' : '#FFD6D6') : '#777';
    drawRoundedRect(x - 18, y - 14, 36, 28, 6);
    // speaker shape
    ctx.fillStyle = '#07241b';
    ctx.beginPath();
    ctx.moveTo(x - 8, y - 6);
    ctx.lineTo(x - 2, y - 6);
    ctx.lineTo(x + 6, y - 12);
    ctx.lineTo(x + 6, y + 12);
    ctx.lineTo(x - 2, y + 6);
    ctx.lineTo(x - 8, y + 6);
    ctx.closePath();
    ctx.fill();

    // waves
    if (audioAvailable && audioEnabled) {
      ctx.strokeStyle = '#07241b';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + 10, y, 6, -0.6, 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x + 10, y, 10, -0.6, 0.6);
      ctx.stroke();
    } else if (!audioAvailable) {
      ctx.fillStyle = '#444';
      ctx.font = '600 10px Arial';
      ctx.fillText('X', x + 12, y + 4);
    } else {
      ctx.strokeStyle = '#440000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + 6, y - 6);
      ctx.lineTo(x + 12, y + 6);
      ctx.moveTo(x + 12, y - 6);
      ctx.lineTo(x + 6, y + 6);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawCelebration() {
    ctx.save();
    ctx.fillStyle = 'rgba(255, 250, 220, 0.18)';
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    ctx.fillStyle = '#fff';
    ctx.font = '700 36px "Arial"';
    ctx.textAlign = 'center';
    ctx.fillText('You did it!', CANVAS_W / 2, CANVAS_H / 2 - 8);
    ctx.font = '600 18px "Arial"';
    ctx.fillText('Great adding! Press Enter for next round.', CANVAS_W / 2, CANVAS_H / 2 + 28);
    ctx.restore();
  }

  // ----- Sparks (particle) effects when wrong or toggle -----
  function spawnSparks(x, y, color = '#FFB400') {
    for (let i = 0; i < 12; i++) {
      sparksAnimation.push({
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 6,
        vy: -Math.random() * 4 - 1,
        life: 600 + Math.random() * 400,
        age: 0,
        color: color,
        size: 2 + Math.random() * 3,
      });
    }
  }

  function updateAndDrawSparks(dt) {
    for (let i = sparksAnimation.length - 1; i >= 0; i--) {
      const p = sparksAnimation[i];
      p.age += dt;
      p.x += p.vx;
      p.y += p.vy + 0.02 * dt; // gravity
      p.vx *= 0.99;
      p.vy += 0.02;
      const lifeRatio = 1 - p.age / p.life;
      if (lifeRatio <= 0) {
        sparksAnimation.splice(i, 1);
        continue;
      }
      ctx.globalAlpha = lifeRatio;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * lifeRatio, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // ----- Game Logic -----
  function toggleWire(index) {
    if (index < 0 || index >= wires.length) return;
    wires[index].on = !wires[index].on;
    const centerX = wires[index].x + wires[index].width / 2;
    const centerY = wires[index].y - 10;
    spawnSparks(centerX, centerY, wires[index].on ? WIRES_COLORS[index] : '#888');
    playClick();
    evaluateSum();
    updateBackgroundHum();
    announceForSR(`Wire ${index + 1} ${wires[index].on ? 'on' : 'off'}. Current total ${currentSum()}.`);
  }

  function currentSum() {
    return wires.reduce((acc, w) => acc + (w.on ? w.value : 0), 0);
  }

  function evaluateSum() {
    const sum = currentSum();
    if (!solved && sum === target) {
      solved = true;
      score += 1;
      playCorrect();
      spawnSparks(CANVAS_W / 2, 200, '#B8FFB0');
      announceForSR('Correct! The lamp lit up. Press Enter to continue.');
      // small hum increase for success
      if (humGain) humGain.gain.setTargetAtTime(0.08, audioCtx.currentTime, 0.2);
    } else if (sum > target) {
      playWrong();
      // harsher sparks near lamp
      spawnSparks(540, 100, '#FF6B6B');
      announceForSR(`Oops! Sum is ${sum}. That's more than ${target}. Try turning some wires off.`);
    } else {
      // gentle feedback
      // reduce hum slightly as power increases
      if (humGain && audioAvailable) {
        const ratio = sum / Math.max(1, target);
        humGain.gain.setTargetAtTime(0.02 + 0.08 * ratio, audioCtx.currentTime, 0.1);
      }
    }
  }

  function updateBackgroundHum() {
    if (!audioAvailable || !humGain) return;
    const sum = currentSum();
    const ratio = sum / Math.max(1, target);
    humGain.gain.setTargetAtTime(0.02 + 0.08 * ratio, audioCtx.currentTime, 0.08);
  }

  function nextRoundOrEnd() {
    if (!solved) return;
    if (round < ROUNDS) {
      round++;
      newRound();
    } else {
      // game end - show final message and reset option
      announceForSR(`Game complete! Your score ${score} out of ${ROUNDS}. Press R to restart.`);
      // freeze hum
      if (humGain) humGain.gain.setTargetAtTime(0.02, audioCtx.currentTime, 0.4);
      solved = true;
      // set round back to 1 after a delay option - here we keep until R pressed
    }
  }

  function resetGame() {
    round = 1;
    score = 0;
    newRound();
    announceForSR('Game reset. New round started.');
  }

  // ----- Input Handling -----
  canvas.tabIndex = 0;
  canvas.addEventListener('click', async (e) => {
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;

    // check audio icon area clicks
    const ax = CANVAS_W - 40;
    const ay = 24;
    if (cx >= ax - 18 && cx <= ax + 18 && cy >= ay - 14 && cy <= ay + 14) {
      toggleAudio();
      return;
    }

    // if solved and player clicked, maybe proceed
    if (solved && round >= ROUNDS) {
      // nothing unless reset
    } else if (solved) {
      nextRoundOrEnd();
      return;
    }

    // check wire button clicks
    for (let i = 0; i < wires.length; i++) {
      const w = wires[i];
      if (cx >= w.x && cx <= w.x + w.width && cy >= w.y && cy <= w.y + w.height) {
        await ensureAudioOnUserGesture();
        selectedWire = i;
        toggleWire(i);
        return;
      }
    }
    // else focus canvas to enable keyboard
    canvas.focus();
  });

  // Keyboard controls
  canvas.addEventListener('keydown', async (e) => {
    if (e.key === 'ArrowRight') {
      selectedWire = (selectedWire + 1) % wires.length;
      playBeep(660, 0.06, 'sine', 0.06);
      announceForSR(`Selected wire ${selectedWire + 1}. Value ${wires[selectedWire].value}.`);
      e.preventDefault();
    } else if (e.key === 'ArrowLeft') {
      selectedWire = (selectedWire - 1 + wires.length) % wires.length;
      playBeep(660, 0.06, 'sine', 0.06);
      announceForSR(`Selected wire ${selectedWire + 1}. Value ${wires[selectedWire].value}.`);
      e.preventDefault();
    } else if (e.key === ' ' || e.key === 'Enter') {
      await ensureAudioOnUserGesture();
      if (solved) {
        nextRoundOrEnd();
      } else {
        toggleWire(selectedWire);
      }
      e.preventDefault();
    } else if (e.key.toLowerCase() === 's') {
      toggleAudio();
      e.preventDefault();
    } else if (e.key.toLowerCase() === 'r') {
      resetGame();
      e.preventDefault();
    }
  });

  // Also support pointer move highlighting wires for visual cue
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    for (let i = 0; i < wires.length; i++) {
      const w = wires[i];
      // highlight on hover visually by setting selected
      if (cx >= w.x && cx <= w.x + w.width && cy >= w.y && cy <= w.y + w.height) {
        selectedWire = i;
      }
    }
  });

  // Allow focusing with click anywhere on container
  container.addEventListener('click', () => {
    canvas.focus();
  });

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioAvailable) {
      announceForSR('Audio is not available in this browser.');
      return;
    }
    audioEnabled = !audioEnabled;
    if (audioEnabled) {
      ensureAudioOnUserGesture();
      playBeep(900, 0.08, 'sine', 0.12);
      announceForSR('Audio enabled.');
    } else {
      announceForSR('Audio muted.');
    }
  }

  // ----- Input safety: ensure audio errors not fatal -----
  window.addEventListener('unhandledrejection', (e) => {
    console.warn('Unhandled promise rejection in game:', e.reason);
  });

  // ----- Initialization -----
  function init() {
    // Focus canvas for keyboard control
    canvas.focus();

    // Start first round
    resetGame();

    // Start animation loop
    lastTime = performance.now();
    window.requestAnimationFrame(drawScene);

    // Accessibility startup message
    announceForSR('Welcome to Sparky & the Power Puzzle. Use arrow keys to pick a wire. Press space to toggle. Press S to toggle sound. Press R to restart.');
  }

  // Start but wait for a small user gesture for audio context resume if available
  init();

  // ----- Error handling reported on canvas when audio unavailable -----
  if (!audioAvailable) {
    console.warn('Audio not available. Game will continue without sound.');
    announceForSR('Note: Audio is not available in this browser. You can still play using visuals and keyboard.');
  }

  // Expose some state for debugging in console (non-invasive)
  window.__electricMathGame = {
    restart: resetGame,
    state: () => ({ round, score, target, wires, selectedWire, solved }),
  };
})();
---

