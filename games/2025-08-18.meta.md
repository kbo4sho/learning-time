# Game of the Day - 2025-08-18

## Metadata
- **Generated Date:** 2025-08-18
- **Generated Time:** 2025-08-18T00:24:23.280501
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-18.js
- **File Size:** 25548 bytes
- **Tokens Used:** 9285

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-18.js` - The playable game
- `2025-08-18.meta.json` - Machine-readable metadata
- `2025-08-18.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17719

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 18662

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
"use strict";

// Electricity Math Game for ages 7-9
// Renders into existing element with id "game-of-the-day-stage"
// All drawing via canvas, sound via Web Audio API oscillators.
// Keyboard and mouse controls implemented. Accessible instructions and visual audio cues included.

// Immediately executed to initialize
(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const CANVAS_ID = "game-of-the-day-canvas";

  // Colors / theme
  const COLORS = {
    bg: "#e6f7fb", // calming pale blue
    panel: "#f7fbfd",
    wire: "#7cc7c7",
    bulbOff: "#f4e7b8",
    bulbOn: "#ffd86b",
    robot: "#b3e0ff",
    acc: "#ffb7b7",
    text: "#10323a",
    soft: "#d9f0ef",
    speakerOn: "#2e8b57",
    speakerOff: "#9aa5a6",
    spark: "#fff27f"
  };

  // Canvas setup
  const stage = document.getElementById("game-of-the-day-stage");
  if (!stage) {
    console.error("No element with id 'game-of-the-day-stage' found.");
    return;
  }
  // Clear any children and create canvas
  stage.innerHTML = "";
  const canvas = document.createElement("canvas");
  canvas.id = CANVAS_ID;
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // to receive keyboard focus
  canvas.style.outline = "none";
  stage.appendChild(canvas);
  const ctx = canvas.getContext("2d", { alpha: false });

  // Audio manager using Web Audio API
  const audioManager = {
    ctx: null,
    masterGain: null,
    backgroundOsc: null,
    enabled: false,
    creating: false,
    // Try to initialize audio context on first user gesture
    async init() {
      if (this.creating || this.ctx) return;
      this.creating = true;
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) throw new Error("Web Audio API not supported");
        this.ctx = new AudioCtx();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.55;
        this.masterGain.connect(this.ctx.destination);
        // gentle background hum
        this.backgroundOsc = this.ctx.createOscillator();
        const bgGain = this.ctx.createGain();
        this.backgroundOsc.type = "sine";
        this.backgroundOsc.frequency.value = 60; // 60 Hz hum-ish subtle
        bgGain.gain.value = 0.01;
        this.backgroundOsc.connect(bgGain);
        bgGain.connect(this.masterGain);
        this.backgroundOsc.start();
        this.enabled = true;
        this.creating = false;
      } catch (err) {
        console.warn("Audio initialization failed:", err);
        this.ctx = null;
        this.enabled = false;
        this.creating = false;
      }
    },
    // Play a tone with simple envelope
    playTone({ freq = 440, type = "sine", duration = 0.25, volume = 0.12, detune = 0 } = {}) {
      if (!this.enabled || !this.ctx) return;
      try {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        osc.detune.value = detune;
        gain.gain.value = 0;
        osc.connect(gain);
        gain.connect(this.masterGain);
        const now = this.ctx.currentTime;
        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(volume, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
        osc.start(now);
        osc.stop(now + duration + 0.02);
      } catch (err) {
        console.warn("Error playing tone:", err);
      }
    },
    // Simple chime for correct
    playCorrect() {
      if (!this.enabled) return;
      this.playTone({ freq: 880, type: "sine", duration: 0.25, volume: 0.12 });
      // quick harmonic
      setTimeout(() => this.playTone({ freq: 1320, type: "triangle", duration: 0.18, volume: 0.08 }), 80);
    },
    // Buzzy for incorrect
    playIncorrect() {
      if (!this.enabled) return;
      this.playTone({ freq: 200, type: "sawtooth", duration: 0.18, volume: 0.14 });
      setTimeout(() => this.playTone({ freq: 120, type: "sawtooth", duration: 0.14, volume: 0.10 }), 80);
    },
    // Shoot sound
    playShoot() {
      if (!this.enabled) return;
      this.playTone({ freq: 520, type: "square", duration: 0.12, volume: 0.09 });
    },
    toggle() {
      // If audio not yet created, attempt to init
      if (!this.ctx) {
        this.init();
        return;
      }
      this.enabled = !this.enabled;
      if (!this.enabled) {
        // mute
        if (this.masterGain) this.masterGain.gain.value = 0;
      } else {
        if (this.masterGain) this.masterGain.gain.value = 0.55;
      }
    }
  };

  // Utility helpers
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // Game state
  const state = {
    bulbs: [], // top bulbs with targets
    orbs: [], // active fired orbs
    spareOrbs: [], // three available numbers visible at generator
    score: 0,
    lives: 3,
    round: 1,
    message: "Welcome! Make each bulb reach its number by zapping it with number-orbs.",
    lastActionTime: Date.now(),
    audioAvailable: false,
    aimAngle: -Math.PI / 2, // upward
    power: 10, // speed multiplier
    mousePos: { x: WIDTH / 2, y: HEIGHT / 2 },
    isMouseAiming: false,
    focused: true,
    paused: false,
    speakerVisible: true
  };

  // Initialize bulbs for a round
  function setupRound(round = 1) {
    state.bulbs = [];
    state.orbs = [];
    state.spareOrbs = [];
    state.message = "Round " + round + ": Light all bulbs by matching sums!";
    state.round = round;
    state.lives = Math.max(1, 4 - Math.floor((round - 1) / 2));
    state.score = 0;
    // create 3 bulbs with targets increasing with round
    const base = 6 + round;
    for (let i = 0; i < 3; i++) {
      const target = randInt(base + i, base + 6 + i);
      state.bulbs.push({
        x: 140 + i * 220,
        y: 110,
        radius: 42,
        target,
        current: 0,
        lit: false,
        charOffset: randInt(-8, 8)
      });
    }
    // create 3 spare orbs (numbers) for generator
    refillSpareOrbs();
  }

  function refillSpareOrbs() {
    state.spareOrbs = [];
    for (let i = 0; i < 3; i++) {
      // choose numbers that are helpful for targets
      const t = state.bulbs[randInt(0, state.bulbs.length - 1)].target;
      const suggestion = clamp(randInt(1, Math.max(3, Math.floor(t / 2))), 1, 9);
      state.spareOrbs.push({
        value: suggestion,
        x: WIDTH / 2 - 60 + i * 60,
        y: HEIGHT - 68,
        radius: 16,
        color: COLORS.accent || "#ffb7b7"
      });
    }
  }

  // Orb object created when shooting
  function createOrb(value, x, y, vx, vy) {
    return {
      value,
      x,
      y,
      vx,
      vy,
      radius: 14,
      alive: true,
      trail: []
    };
  }

  // Input handling
  let lastShotTime = 0;
  const SHOT_COOLDOWN = 250; // ms

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    state.mousePos.x = mx;
    state.mousePos.y = my;
    state.isMouseAiming = true;
    // compute aimAngle from generator center
    const gx = WIDTH / 2;
    const gy = HEIGHT - 40;
    const dx = mx - gx;
    const dy = my - gy;
    state.aimAngle = Math.atan2(dy, dx);
  });

  canvas.addEventListener("mouseleave", () => {
    state.isMouseAiming = false;
  });

  canvas.addEventListener("click", async (e) => {
    // Click acts as shoot + toggles audio if clicking speaker area
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // If click on speaker icon area
    if (mx >= WIDTH - 60 && mx <= WIDTH - 20 && my >= 20 && my <= 60) {
      // try init audio on click
      await audioManager.init();
      audioManager.toggle();
      state.audioAvailable = audioManager.enabled;
      state.message = audioManager.enabled ? "Audio ON" : "Audio OFF";
      return;
    }
    // Ensure AudioContext created on first user gesture if possible
    if (!audioManager.ctx) {
      await audioManager.init();
      state.audioAvailable = audioManager.enabled;
    }
    shootFromGenerator();
    canvas.focus();
  });

  // Keyboard controls
  const keyState = {};
  window.addEventListener("keydown", async (e) => {
    keyState[e.code] = true;
    // Try to init audio when a key is pressed first
    if (!audioManager.ctx) {
      await audioManager.init();
      state.audioAvailable = audioManager.enabled;
    }
    if (e.code === "KeyM") {
      audioManager.toggle();
      state.audioAvailable = audioManager.enabled;
      state.message = audioManager.enabled ? "Audio ON" : "Audio OFF";
      e.preventDefault();
    } else if (e.code === "Space") {
      shootFromGenerator();
      e.preventDefault();
    } else if (e.code === "KeyR") {
      setupRound(1);
      e.preventDefault();
    } else if (e.code === "KeyP") {
      state.paused = !state.paused;
      state.message = state.paused ? "Paused" : "Resumed";
      e.preventDefault();
    }
  });

  window.addEventListener("keyup", (e) => {
    keyState[e.code] = false;
  });

  // Shoot logic: fires the left-most spare orb value
  function shootFromGenerator() {
    if (state.paused) return;
    const now = Date.now();
    if (now - lastShotTime < SHOT_COOLDOWN) return;
    lastShotTime = now;
    if (state.spareOrbs.length === 0) {
      state.message = "No orbs left! Refilling...";
      refillSpareOrbs();
      return;
    }
    // pick first spare orb
    const orbInfo = state.spareOrbs.shift();
    const gx = WIDTH / 2;
    const gy = HEIGHT - 40;
    const angle = state.aimAngle;
    const speed = 3 + state.power * 0.6;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    const orb = createOrb(orbInfo.value, gx + Math.cos(angle) * 28, gy + Math.sin(angle) * 28, vx, vy);
    state.orbs.push(orb);
    audioManager.playShoot();
    state.message = `Zapped a ${orb.value}! Aim for a bulb to reach its number.`;
  }

  // Update loop: physics and collisions
  function update(dt) {
    if (state.paused) return;
    // Keyboard aim adjustments
    if (keyState["ArrowLeft"]) {
      state.aimAngle -= 0.03;
    }
    if (keyState["ArrowRight"]) {
      state.aimAngle += 0.03;
    }
    if (keyState["ArrowUp"]) {
      state.power = clamp(state.power + 0.06, 6, 16);
    }
    if (keyState["ArrowDown"]) {
      state.power = clamp(state.power - 0.06, 6, 16);
    }

    // Update orbs
    for (const orb of state.orbs) {
      if (!orb.alive) continue;
      orb.vy += 0.06; // subtle gravity to simulate wire sag
      orb.x += orb.vx;
      orb.y += orb.vy;
      // record trail
      orb.trail.push({ x: orb.x, y: orb.y });
      if (orb.trail.length > 10) orb.trail.shift();
      // boundary check: if off screen, remove
      if (orb.x < -30 || orb.x > WIDTH + 30 || orb.y > HEIGHT + 40) {
        orb.alive = false;
      }
      // check collisions with bulbs
      for (const bulb of state.bulbs) {
        if (bulb.lit) continue;
        const dx = orb.x - bulb.x;
        const dy = orb.y - bulb.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < orb.radius + bulb.radius - 6) {
          // deposit value
          bulb.current += orb.value;
          orb.alive = false;
          // sound and check
          if (bulb.current === bulb.target) {
            bulb.lit = true;
            state.score += bulb.target;
            audioManager.playCorrect();
            state.message = `Great! Bulb reached ${bulb.target}!`;
          } else if (bulb.current > bulb.target) {
            // Overload
            state.lives -= 1;
            audioManager.playIncorrect();
            state.message = `Overload! Bulb needed ${bulb.target} but got ${bulb.current}. It reset. Lives: ${state.lives}`;
            bulb.current = 0;
          } else {
            // Partial
            audioManager.playShoot();
            state.message = `Bulb got ${bulb.current} / ${bulb.target}. Keep going!`;
          }
          // spawn tiny sparks (visual) by saving a transient property
          bulb.sparkTimer = 16;
          break;
        }
      }
    }

    // clean up dead orbs
    state.orbs = state.orbs.filter((o) => o.alive);

    // Check round completion
    if (state.bulbs.every((b) => b.lit)) {
      state.round += 1;
      state.message = `Round complete! Starting round ${state.round}...`;
      // small delay before next round
      setTimeout(() => {
        setupRound(state.round);
      }, 900);
    }

    // Check game over
    if (state.lives <= 0) {
      state.paused = true;
      state.message = "Game over! Press R to restart.";
    }
  }

  // Drawing functions
  function drawBackground() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // gentle circuit-grid pattern
    ctx.strokeStyle = COLORS.soft;
    ctx.lineWidth = 1;
    for (let x = 0; x < WIDTH; x += 24) {
      ctx.beginPath();
      ctx.moveTo(x + (Math.sin(perfNow() / 800 + x * 0.02) * 4), 0);
      ctx.lineTo(x + (Math.sin(perfNow() / 800 + x * 0.02) * 4), HEIGHT);
      ctx.stroke();
    }
    for (let y = 0; y < HEIGHT; y += 24) {
      ctx.beginPath();
      ctx.moveTo(0, y + (Math.cos(perfNow() / 800 + y * 0.02) * 4));
      ctx.lineTo(WIDTH, y + (Math.cos(perfNow() / 800 + y * 0.02) * 4));
      ctx.stroke();
    }
  }

  function perfNow() {
    return performance.now();
  }

  function drawBulbs() {
    for (const bulb of state.bulbs) {
      // draw wire stub
      ctx.beginPath();
      ctx.strokeStyle = COLORS.wire;
      ctx.lineWidth = 6;
      ctx.moveTo(bulb.x, bulb.y + bulb.radius + 8);
      ctx.lineTo(bulb.x, bulb.y + bulb.radius + 40);
      ctx.stroke();

      // bulb glass
      ctx.beginPath();
      ctx.fillStyle = bulb.lit ? COLORS.bulbOn : COLORS.bulbOff;
      ctx.strokeStyle = "#bda65b";
      ctx.lineWidth = 3;
      ctx.ellipse(bulb.x, bulb.y, bulb.radius, bulb.radius * 1.1, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // filament indicator (shows partial charge)
      ctx.beginPath();
      const ratio = clamp(bulb.current / bulb.target, 0, 1);
      ctx.strokeStyle = "#a55b00";
      ctx.lineWidth = 3;
      ctx.moveTo(bulb.x - 12, bulb.y);
      ctx.lineTo(bulb.x + 12, bulb.y - 6 * ratio);
      ctx.stroke();

      // target number and current
      ctx.fillStyle = COLORS.text;
      ctx.font = "bold 16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(`Need: ${bulb.target}`, bulb.x, bulb.y - bulb.radius - 8);
      ctx.font = "bold 18px sans-serif";
      ctx.fillText(`${bulb.current}`, bulb.x, bulb.y + 6);

      // playful character on bulb base (Wirefox)
      drawWireFox(bulb.x - 24, bulb.y + bulb.radius + 22, bulb.charOffset, bulb.lit);

      // spark effects
      if (bulb.sparkTimer && bulb.sparkTimer > 0) {
        drawSparks(bulb.x, bulb.y + 6, bulb.sparkTimer);
        bulb.sparkTimer -= 1;
      }
    }
  }

  function drawWireFox(x, y, offset, happy) {
    ctx.save();
    ctx.translate(x, y);
    // body
    ctx.fillStyle = "#ffc8a2";
    ctx.beginPath();
    ctx.ellipse(0, 6 + offset * 0.1, 18, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    // head
    ctx.beginPath();
    ctx.fillStyle = "#ffd9b1";
    ctx.arc(0, -6 + offset * 0.1, 12, 0, Math.PI * 2);
    ctx.fill();
    // eyes
    ctx.fillStyle = happy ? "#003" : "#222";
    ctx.beginPath();
    ctx.arc(-4, -8, 2, 0, Math.PI * 2);
    ctx.arc(4, -8, 2, 0, Math.PI * 2);
    ctx.fill();
    // little wire tail
    ctx.strokeStyle = "#d18b4a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(14, 8);
    ctx.lineTo(22, 10);
    ctx.lineTo(26, 6);
    ctx.stroke();
    ctx.restore();
  }

  function drawSparks(cx, cy, t) {
    const count = Math.floor(6 + Math.random() * 6);
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2;
      const r = Math.random() * (t * 1.8);
      const x = cx + Math.cos(a) * r;
      const y = cy + Math.sin(a) * r;
      ctx.fillStyle = COLORS.spark;
      ctx.beginPath();
      ctx.arc(x, y, Math.max(1, 3 - t / 8), 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawGenerator() {
    const gx = WIDTH / 2;
    const gy = HEIGHT - 40;
    // base panel
    ctx.fillStyle = COLORS.panel;
    ctx.strokeStyle = "#c9e8ea";
    roundRect(ctx, gx - 140, gy - 30, 280, 64, 10);
    ctx.fill();
    ctx.stroke();

    // friendly robot "Volty" left side
    drawVolty(gx - 160, gy - 8);

    // center emitter
    ctx.beginPath();
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#bcdad9";
    ctx.lineWidth = 3;
    ctx.arc(gx, gy, 28, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // show current aim line from emitter
    ctx.beginPath();
    ctx.strokeStyle = COLORS.wire;
    ctx.lineWidth = 4;
    ctx.moveTo(gx, gy);
    const aimX = gx + Math.cos(state.aimAngle) * 90;
    const aimY = gy + Math.sin(state.aimAngle) * 90;
    ctx.lineTo(aimX, aimY);
    ctx.stroke();

    // spare orbs
    for (let i = 0; i < state.spareOrbs.length; i++) {
      const sp = state.spareOrbs[i];
      // small hover bob
      const bob = Math.sin(perfNow() / 300 + i) * 4;
      ctx.beginPath();
      ctx.fillStyle = "#ffe9e9";
      ctx.arc(sp.x, sp.y + bob, sp.radius + 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = "#ff8b8b";
      ctx.arc(sp.x, sp.y + bob, sp.radius, 0, Math.PI * 2);
      ctx.fill();
      // number
      ctx.fillStyle = "#fff";
      ctx.font = "bold 14px monospace";
      ctx.textAlign = "center";
      ctx.fillText(sp.value, sp.x, sp.y + 5 + bob);
    }

    // power meter
    ctx.fillStyle = "#cfeeea";
    ctx.fillRect(gx + 90, gy - 22, 36, 44);
    ctx.fillStyle = "#2e8b57";
    const height = clamp(((state.power - 6) / (16 - 6)) * 36, 2, 36);
    ctx.fillRect(gx + 96, gy + 12 - height, 24, height);
    ctx.strokeStyle = "#9ccbbf";
    ctx.strokeRect(gx + 90, gy - 22, 36, 44);

    // show controls text
    ctx.fillStyle = COLORS.text;
    ctx.font = "12px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Arrow keys to aim, Space to zap, M toggle sound", 12, HEIGHT - 12);
    ctx.fillText("Press R to restart, P to pause", 12, HEIGHT - 28);
  }

  function drawVolty(x, y) {
    ctx.save();
    ctx.translate(x, y);
    // head
    ctx.fillStyle = COLORS.robot;
    ctx.fillRect(-28, -28, 40, 36);
    // eye / screen
    ctx.fillStyle = "#06292c";
    ctx.fillRect(-24, -22, 32, 24);
    // smile
    ctx.fillStyle = "#8fe7e3";
    ctx.fillRect(-12, -8, 8, 4);
    // antenna
    ctx.beginPath();
    ctx.strokeStyle = "#7cc7c7";
    ctx.lineWidth = 3;
    ctx.moveTo(12, -32);
    ctx.lineTo(18, -44);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle = "#ffed99";
    ctx.arc(18, -44, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function roundRect(ctxRef, x, y, w, h, r) {
    ctxRef.beginPath();
    ctxRef.moveTo(x + r, y);
    ctxRef.arcTo(x + w, y, x + w, y + h, r);
    ctxRef.arcTo(x + w, y + h, x, y + h, r);
    ctxRef.arcTo(x, y + h, x, y, r);
    ctxRef.arcTo(x, y, x + w, y, r);
    ctxRef.closePath();
  }

  function drawOrbs() {
    // trails first
    for (const orb of state.orbs) {
      if (!orb.alive) continue;
      ctx.beginPath();
      let alpha = 0.25;
      for (let i = orb.trail.length - 1; i >= 0; i--) {
        const p = orb.trail[i];
        ctx.fillStyle = `rgba(255,230,120,${alpha})`;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        alpha *= 0.85;
      }
    }
    // draw orbs
    for (const orb of state.orbs) {
      if (!orb.alive) continue;
      ctx.beginPath();
      ctx.fillStyle = "#ffd36b";
      ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
      ctx.fill();
      // number
      ctx.fillStyle = "#2d2d2d";
      ctx.font = "bold 14px monospace";
      ctx.textAlign = "center";
      ctx.fillText(orb.value, orb.x, orb.y + 5);
    }
  }

  function drawUI() {
    // top-left info panel
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    roundRect(ctx, 12, 12, 280, 72, 8);
    ctx.fill();
    ctx.strokeStyle = "#bfecec";
    ctx.stroke();
    ctx.fillStyle = COLORS.text;
    ctx.font = "bold 16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Score: ${state.score}`, 28, 36);
    ctx.fillText(`Round: ${state.round}`, 28, 56);
    ctx.fillText(`Lives: ${state.lives}`, 160, 56);

    // message box
    ctx.fillStyle = "rgba(255,255,255,0.5)";
    roundRect(ctx, 310, 12, 398, 72, 8);
    ctx.fill();
    ctx.strokeStyle = "#bfecec";
    ctx.stroke();
    ctx.fillStyle = COLORS.text;
    ctx.font = "14px sans-serif";
    ctx.textAlign = "left";
    // wrap message if needed
    const msg = state.message || "";
    wrapText(ctx, msg, 326, 34, 370, 18);

    // speaker icon (visual cue for audio)
    ctx.save();
    ctx.translate(WIDTH - 44, 36);
    ctx.fillStyle = audioManager.enabled ? COLORS.speakerOn : COLORS.speakerOff;
    // speaker base
    ctx.beginPath();
    ctx.moveTo(-12, -8);
    ctx.lineTo(-4, -8);
    ctx.lineTo(4, -16);
    ctx.lineTo(4, 16);
    ctx.lineTo(-4, 8);
    ctx.lineTo(-12, 8);
    ctx.closePath();
    ctx.fill();
    // waves if enabled
    if (audioManager.enabled) {
      ctx.beginPath();
      ctx.strokeStyle = COLORS.speakerOn;
      ctx.lineWidth = 2;
      ctx.arc(6, 0, 6, -0.5, 0.5);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(6, 0, 10, -0.5, 0.5);
      ctx.stroke();
    } else {
      // X mark when off
      ctx.strokeStyle = COLORS.speakerOff;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-8, -8);
      ctx.lineTo(8, 8);
      ctx.moveTo(8, -8);
      ctx.lineTo(-8, 8);
      ctx.stroke();
    }
    ctx.restore();

    // Accessibility instruction block
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    roundRect(ctx, 12, HEIGHT - 110, 260, 88, 8);
    ctx.fill();
    ctx.strokeStyle = "#cfeeea";
    ctx.stroke();
    ctx.fillStyle = COLORS.text;
    ctx.font = "12px sans-serif";
    wrapText(ctx, "Instructions: Aim with mouse or arrow keys. Press Space to zap the number-orb into a bulb. Make each bulb's number match the target. Press M to toggle sound.", 24, HEIGHT - 90, 232, 16);
  }

  function wrapText(ctxRef, text, x, y, maxWidth, lineHeight) {
    const words = text.split(" ");
    let line = "";
    let curY = y;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + " ";
      const metrics = ctxRef.measureText(testLine);
      if (metrics.width > maxWidth && n > 0) {
        ctxRef.fillText(line, x, curY);
        line = words[n] + " ";
        curY += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctxRef.fillText(line, x, curY);
  }

  // Draw characters like Sparky (a lightning bug) as a decorative friend
  function drawSparky(x, y, t) {
    ctx.save();
    ctx.translate(x, y);
    // body
    ctx.beginPath();
    ctx.fillStyle = "#fef08a";
    ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    // wings
    ctx.beginPath();
    ctx.fillStyle = "#e8f6ff";
    ctx.ellipse(-6, -6, 6, 4, -0.5, 0, Math.PI * 2);
    ctx.ellipse(6, -6, 6, 4, 0.5, 0, Math.PI * 2);
    ctx.fill();
    // antennae
    ctx.strokeStyle = "#6b7280";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(-3, -6);
    ctx.lineTo(-8, -12);
    ctx.moveTo(3, -6);
    ctx.lineTo(8, -12);
    ctx.stroke();
    ctx.restore();
  }

  // Main render
  function render(now) {
    // time delta roughly
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawBulbs();
    drawOrbs();
    drawGenerator();
    drawUI();
    // decorative Sparky at top right
    drawSparky(WIDTH - 80, 80, now);

    // focus ring for keyboard accessibility
    if (document.activeElement === canvas) {
      ctx.strokeStyle = "#9dd6d6";
      ctx.lineWidth = 2;
      ctx.strokeRect(0.5, 0.5, WIDTH - 1, HEIGHT - 1);
    }
  }

  // Main loop
  let lastTime = performance.now();
  function loop(ts) {
    const dt = ts - lastTime;
    lastTime = ts;
    update(dt);
    render(ts);
    requestAnimationFrame(loop);
  }

  // Initialization and error handling
  try {
    setupRound(1);
    requestAnimationFrame(loop);
  } catch (err) {
    console.error("Game initialization error:", err);
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = "#ffdddd";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = "#600";
    ctx.font = "18px sans-serif";
    ctx.fillText("An error occurred loading the game. Try reloading the page.", 24, 40);
  }

  // Accessibility: expose a simple API on the canvas element for screen readers via title and aria
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Electricity math game. Aim and shoot number orbs to match bulbs' target numbers. Use arrow keys to aim and space to shoot. Press M to toggle sound.");
  canvas.title = "Electricity Math Game: Aim with mouse or arrow keys. Space to zap. M toggles sound. Press R to restart.";

  // Provide helpful console instructions for caregivers / teachers
  console.info("Electricity Math Game initialized. Controls: Arrow keys to aim, Space to shoot, M to toggle sound, R restart, P pause. Click speaker icon to toggle sound as well.");

  // Expose some functions for debugging if needed (not required)
  window._electricMathGame = {
    state,
    audioManager,
    setupRound
  };
})();
---

