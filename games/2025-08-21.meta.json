{
  "generated_date": "2025-08-21",
  "generated_timestamp": "2025-08-21T00:21:28.654005",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9992,
  "game_filename": "2025-08-21.js",
  "game_size_bytes": 28539,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Electricity Math Game - \"Spark's Circuit Quest\"\n  // Ages 7-9, addition/subtraction practice with an electrical theme.\n  // Renders into existing HTML element with id \"game-of-the-day-stage\".\n  // All graphics drawn on canvas. All audio generated with Web Audio API.\n  // Accessible: keyboard controls, aria-label updates, visual audio cues, error handling.\n\n  // ------------------ Setup and Utilities ------------------\n  const CONTAINER_ID = \"game-of-the-day-stage\";\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  // Find container\n  const container = document.getElementById(CONTAINER_ID);\n  if (!container) {\n    console.error(`Container element with id \"${CONTAINER_ID}\" not found.`);\n    return;\n  }\n  // Clear container\n  container.innerHTML = \"\";\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\n    \"aria-label\",\n    \"Spark's Circuit Quest. Use arrow keys or WASD to move Spark the electron. Collect numbered orbs to match the target power for each bulb. Press M to toggle sound. Press Enter to start.\"\n  );\n  canvas.setAttribute(\"tabindex\", \"0\"); // make focusable\n  canvas.title = \"Spark's Circuit Quest - Canvas Game\";\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n\n  // Keyboard state\n  const keys = {};\n  // Mouse state\n  let mouse = { x: 0, y: 0, down: false };\n\n  // Focus canvas for keyboard\n  canvas.focus();\n\n  // Helper: clamp\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n\n  // ----------- Audio Setup (Web Audio API) -------------\n  let audioContext = null;\n  let audioAvailable = true;\n  let audioMuted = false;\n  let bgGain = null;\n  let bgOsc = null;\n  let bgFilter = null;\n\n  // Try to create AudioContext with error handling\n  try {\n    const AudioCtx = window.AudioContext || window.webkitAudioContext;\n    if (!AudioCtx) {\n      throw new Error(\"Web Audio API not supported in this browser.\");\n    }\n    audioContext = new AudioCtx();\n  } catch (e) {\n    console.warn(\"AudioContext creation failed:\", e);\n    audioAvailable = false;\n    audioContext = null;\n  }\n\n  // Ensure audio resumes on first user gesture (browsers require that)\n  function tryResumeAudio() {\n    if (!audioAvailable || !audioContext) return;\n    if (audioContext.state === \"suspended\") {\n      audioContext\n        .resume()\n        .then(() => {\n          // Start background hum if not already\n          startBackgroundHum();\n        })\n        .catch((err) => {\n          console.warn(\"Failed to resume audio context:\", err);\n        });\n    } else {\n      startBackgroundHum();\n    }\n  }\n\n  function startBackgroundHum() {\n    if (!audioAvailable || !audioContext) return;\n    if (bgOsc) return; // already started\n    try {\n      bgOsc = audioContext.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 110; // low hum\n      bgFilter = audioContext.createBiquadFilter();\n      bgFilter.type = \"lowpass\";\n      bgFilter.frequency.value = 800;\n      bgGain = audioContext.createGain();\n      bgGain.gain.value = audioMuted ? 0 : 0.02;\n      bgOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgGain.connect(audioContext.destination);\n      bgOsc.start();\n    } catch (err) {\n      console.warn(\"Background hum start failed:\", err);\n    }\n  }\n\n  function stopBackgroundHum() {\n    if (!audioAvailable || !audioContext || !bgOsc) return;\n    try {\n      bgOsc.stop();\n    } catch (e) {\n      /* ignore */\n    }\n    bgOsc.disconnect();\n    bgFilter && bgFilter.disconnect();\n    bgGain && bgGain.disconnect();\n    bgOsc = null;\n    bgFilter = null;\n    bgGain = null;\n  }\n\n  // Simple beep generator for correct/incorrect/pickup\n  function playTone({ freq = 440, duration = 0.15, type = \"sine\", volume = 0.08 }) {\n    if (!audioAvailable || !audioContext || audioMuted) return;\n    try {\n      const osc = audioContext.createOscillator();\n      const gain = audioContext.createGain();\n      osc.type = type;\n      osc.frequency.setValueAtTime(freq, audioContext.currentTime);\n      gain.gain.setValueAtTime(volume, audioContext.currentTime);\n      // small decay\n      gain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);\n      osc.connect(gain);\n      gain.connect(audioContext.destination);\n      osc.start();\n      osc.stop(audioContext.currentTime + duration + 0.02);\n    } catch (err) {\n      console.warn(\"playTone error:\", err);\n    }\n  }\n\n  function playCorrectChime() {\n    // little arpeggio\n    playTone({ freq: 880, duration: 0.12, type: \"sine\", volume: 0.06 });\n    setTimeout(() => playTone({ freq: 660, duration: 0.12, type: \"sine\", volume: 0.06 }), 110);\n    setTimeout(() => playTone({ freq: 990, duration: 0.16, type: \"sine\", volume: 0.08 }), 230);\n  }\n\n  function playBuzz() {\n    // buzz with low frequency noise-ish\n    if (!audioAvailable || !audioContext || audioMuted) return;\n    try {\n      const osc = audioContext.createOscillator();\n      const gain = audioContext.createGain();\n      const filter = audioContext.createBiquadFilter();\n      osc.type = \"square\";\n      osc.frequency.value = 120;\n      filter.type = \"lowpass\";\n      filter.frequency.value = 600;\n      gain.gain.value = 0.08;\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioContext.destination);\n      osc.start();\n      gain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.4);\n      osc.stop(audioContext.currentTime + 0.45);\n    } catch (err) {\n      console.warn(\"playBuzz error:\", err);\n    }\n  }\n\n  // ------------- Game Variables ----------------\n  let lastTime = 0;\n  let running = false;\n\n  // Characters and theme\n  const characters = {\n    spark: {\n      name: \"Spark\",\n      color: \"#FFD66B\",\n      x: WIDTH / 2,\n      y: HEIGHT - 80,\n      radius: 18,\n      speed: 180, // pixels per second\n    },\n    professor: {\n      name: \"Professor Ohm\",\n      color: \"#9FD8FF\",\n    },\n    bulby: {\n      name: \"Bulby\",\n      color: \"#FFF1C6\",\n    },\n  };\n\n  // Game state\n  let level = 1;\n  let bulbsToPower = 3;\n  let currentBulbIndex = 0;\n  let targetValue = 10;\n  let orbs = []; // number orbs on screen\n  let collectedSum = 0;\n  let lives = 3;\n  let score = 0;\n  let phase = \"start\"; // start, playing, success, gameover\n  let flashTimer = 0;\n  let gentleParticles = [];\n\n  // Accessibility state: update canvas aria-label with dynamic info\n  function updateAria() {\n    const ariaText =\n      `Spark's Circuit Quest. Level ${level}, Bulb ${currentBulbIndex + 1} of ${bulbsToPower}. ` +\n      `Target power ${targetValue}. Current collected ${collectedSum}. Lives ${lives}. ` +\n      `Use arrow keys or WASD to move. Press M to toggle sound. Press Enter to start or continue.`;\n    canvas.setAttribute(\"aria-label\", ariaText);\n  }\n\n  // ------------- Procedural content ----------------\n  function generateOrbs(count = 6) {\n    orbs = [];\n    for (let i = 0; i < count; i++) {\n      const val = Math.floor(Math.random() * 9) + 1; // 1..9\n      const r = 18 + Math.random() * 12;\n      const x = 60 + Math.random() * (WIDTH - 120);\n      const y = 80 + Math.random() * (HEIGHT - 200);\n      const vx = (Math.random() * 2 - 1) * 40;\n      const vy = (Math.random() * 2 - 1) * 30;\n      const phase = Math.random() * Math.PI * 2;\n      orbs.push({\n        value: val,\n        x,\n        y,\n        r,\n        vx,\n        vy,\n        wobble: 20 + Math.random() * 30,\n        baseY: y,\n        phase,\n        floatSpeed: 0.8 + Math.random() * 1.2,\n        id: Math.random().toString(36).slice(2, 9),\n      });\n    }\n  }\n\n  function nextBulb() {\n    currentBulbIndex++;\n    collectedSum = 0;\n    if (currentBulbIndex >= bulbsToPower) {\n      // level completed\n      level++;\n      bulbsToPower = Math.min(4 + level, 6);\n      currentBulbIndex = 0;\n      score += 50; // bonus\n      phase = \"success\";\n      setTimeout(() => {\n        startLevel();\n        phase = \"playing\";\n      }, 1600);\n    } else {\n      // new bulb target\n      setUpCurrentBulb();\n    }\n    updateAria();\n  }\n\n  function setUpCurrentBulb() {\n    // target increases with level and bulb index\n    const base = 6 + level * 2 + currentBulbIndex * 1;\n    targetValue = base + Math.floor(Math.random() * 8); // e.g., 6..13 base plus 0..7 -> in range ~6..20\n    // ensure target is not less than 4\n    targetValue = Math.max(4, targetValue);\n    generateOrbs(6 + Math.min(level, 3));\n    collectedSum = 0;\n    flashTimer = 0;\n    updateAria();\n  }\n\n  function startLevel() {\n    phase = \"playing\";\n    setUpCurrentBulb();\n    lives = Math.max(1, 3 - Math.floor(level / 3));\n    score = 0;\n    characters.spark.x = WIDTH / 2;\n    characters.spark.y = HEIGHT - 80;\n  }\n\n  function resetGame() {\n    level = 1;\n    bulbsToPower = 3;\n    currentBulbIndex = 0;\n    score = 0;\n    lives = 3;\n    startLevel();\n  }\n\n  // ------------- Input Handlers ----------------\n  window.addEventListener(\"keydown\", (e) => {\n    keys[e.key.toLowerCase()] = true;\n    // allow resume audio on any key press\n    tryResumeAudio();\n\n    if (e.key === \"m\" || e.key === \"M\") {\n      audioMuted = !audioMuted;\n      if (bgGain) bgGain.gain.value = audioMuted ? 0 : 0.02;\n      updateAria();\n      e.preventDefault();\n    }\n\n    if (e.key === \"Enter\") {\n      if (phase === \"start\" || phase === \"gameover\" || phase === \"success\") {\n        resetGame();\n        phase = \"playing\";\n      }\n      e.preventDefault();\n    }\n  });\n  window.addEventListener(\"keyup\", (e) => {\n    keys[e.key.toLowerCase()] = false;\n  });\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    mouse.down = true;\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = e.clientX - rect.left;\n    mouse.y = e.clientY - rect.top;\n    // click is considered a user gesture; resume audio\n    tryResumeAudio();\n    // On click during start screen start the game\n    if (phase === \"start\" || phase === \"gameover\" || phase === \"success\") {\n      resetGame();\n      phase = \"playing\";\n    }\n  });\n\n  canvas.addEventListener(\"mouseup\", () => {\n    mouse.down = false;\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = e.clientX - rect.left;\n    mouse.y = e.clientY - rect.top;\n  });\n\n  // Touch support: translate to mouse\n  canvas.addEventListener(\"touchstart\", (e) => {\n    e.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const t = e.touches[0];\n    mouse.down = true;\n    mouse.x = t.clientX - rect.left;\n    mouse.y = t.clientY - rect.top;\n    tryResumeAudio();\n    if (phase === \"start\" || phase === \"gameover\" || phase === \"success\") {\n      resetGame();\n      phase = \"playing\";\n    }\n  }, { passive: false });\n\n  canvas.addEventListener(\"touchmove\", (e) => {\n    e.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const t = e.touches[0];\n    mouse.x = t.clientX - rect.left;\n    mouse.y = t.clientY - rect.top;\n  }, { passive: false });\n\n  canvas.addEventListener(\"touchend\", (e) => {\n    e.preventDefault();\n    mouse.down = false;\n  }, { passive: false });\n\n  // ------------- Collision Helpers --------------\n  function dist2(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n  }\n\n  // ------------- Particle gentle background -------------\n  function spawnParticles() {\n    gentleParticles = [];\n    for (let i = 0; i < 40; i++) {\n      gentleParticles.push({\n        x: Math.random() * WIDTH,\n        y: Math.random() * HEIGHT,\n        r: 1 + Math.random() * 2.5,\n        alpha: 0.08 + Math.random() * 0.18,\n        vy: 2 + Math.random() * 5,\n        vx: -1 + Math.random() * 2,\n      });\n    }\n  }\n\n  // ------------- Gameplay Logic ----------------\n  function update(dt) {\n    if (phase === \"start\") {\n      // slow gentle bob of characters\n      for (const p of gentleParticles) {\n        p.x += p.vx * dt;\n        p.y += p.vy * dt * 0.2;\n        if (p.x < -10) p.x = WIDTH + 10;\n        if (p.x > WIDTH + 10) p.x = -10;\n      }\n      return;\n    }\n\n    if (phase === \"gameover\" || phase === \"success\") {\n      // animate spark gently\n      characters.spark.y += Math.sin(Date.now() / 300) * 0.02;\n      return;\n    }\n\n    // Movement: keyboard or mouse control\n    const sp = characters.spark;\n    let moveX = 0;\n    let moveY = 0;\n    if (keys[\"arrowleft\"] || keys[\"a\"]) moveX -= 1;\n    if (keys[\"arrowright\"] || keys[\"d\"]) moveX += 1;\n    if (keys[\"arrowup\"] || keys[\"w\"]) moveY -= 1;\n    if (keys[\"arrowdown\"] || keys[\"s\"]) moveY += 1;\n\n    const usingMouse = mouse.down;\n    if (usingMouse) {\n      // Move toward mouse slowly\n      const dx = mouse.x - sp.x;\n      const dy = mouse.y - sp.y;\n      const dist = Math.hypot(dx, dy);\n      if (dist > 4) {\n        moveX = dx / dist;\n        moveY = dy / dist;\n      } else {\n        moveX = 0;\n        moveY = 0;\n      }\n    }\n\n    if (moveX !== 0 || moveY !== 0) {\n      // Normalize\n      const mag = Math.hypot(moveX, moveY);\n      moveX /= mag || 1;\n      moveY /= mag || 1;\n      sp.x += moveX * sp.speed * dt;\n      sp.y += moveY * sp.speed * dt;\n      // Keep inside bounds\n      sp.x = clamp(sp.x, 24, WIDTH - 24);\n      sp.y = clamp(sp.y, 24, HEIGHT - 24);\n    }\n\n    // Orbs float and bounce\n    for (const o of orbs) {\n      o.phase += dt * o.floatSpeed;\n      o.y = o.baseY + Math.sin(o.phase) * o.wobble;\n      o.x += o.vx * dt;\n      if (o.x < 24) {\n        o.x = 24;\n        o.vx *= -1;\n      }\n      if (o.x > WIDTH - 24) {\n        o.x = WIDTH - 24;\n        o.vx *= -1;\n      }\n      // gentle vy nudge\n      o.baseY += Math.sin(Date.now() / 1000 + o.phase) * 0.02;\n    }\n\n    // Check collisions with orbs\n    for (let i = orbs.length - 1; i >= 0; i--) {\n      const o = orbs[i];\n      const rr = (sp.radius + o.r) * (sp.radius + o.r);\n      if (dist2(sp.x, sp.y, o.x, o.y) < rr) {\n        collectedSum += o.value;\n        // small animation: push spark out a bit\n        const ang = Math.atan2(sp.y - o.y, sp.x - o.x);\n        sp.x += Math.cos(ang) * 8;\n        sp.y += Math.sin(ang) * 8;\n        // play pickup tone\n        playTone({ freq: 660 + o.value * 22, duration: 0.08, type: \"sine\", volume: 0.06 });\n        // remove orb\n        orbs.splice(i, 1);\n        // spawn replacement with some chance\n        if (Math.random() < 0.6) {\n          setTimeout(() => {\n            const val = Math.floor(Math.random() * 9) + 1;\n            const r = 18 + Math.random() * 12;\n            const x = 60 + Math.random() * (WIDTH - 120);\n            const y = 80 + Math.random() * (HEIGHT - 200);\n            orbs.push({\n              value: val,\n              x,\n              y,\n              r,\n              vx: (Math.random() * 2 - 1) * 40,\n              vy: (Math.random() * 2 - 1) * 30,\n              wobble: 20 + Math.random() * 30,\n              baseY: y,\n              phase: Math.random() * Math.PI * 2,\n              floatSpeed: 0.8 + Math.random() * 1.2,\n              id: Math.random().toString(36).slice(2, 9),\n            });\n          }, 600 + Math.random() * 600);\n        }\n      }\n    }\n\n    // Check sums\n    if (collectedSum === targetValue) {\n      // Success for this bulb\n      score += 10;\n      playCorrectChime();\n      nextBulb();\n    } else if (collectedSum > targetValue) {\n      // Overloaded! Buzz and penalty\n      playBuzz();\n      flashTimer = 0.8;\n      collectedSum = 0;\n      lives--;\n      if (lives <= 0) {\n        phase = \"gameover\";\n        updateAria();\n      }\n    }\n\n    // update flash timer\n    if (flashTimer > 0) {\n      flashTimer -= dt;\n      if (flashTimer < 0) flashTimer = 0;\n    }\n\n    // Gentle particles drift\n    for (const p of gentleParticles) {\n      p.x += p.vx * dt * 10;\n      p.y += p.vy * dt * 0.5;\n      if (p.y > HEIGHT + 10) p.y = -10;\n      if (p.x > WIDTH + 10) p.x = -10;\n      if (p.x < -10) p.x = WIDTH + 10;\n    }\n\n    // If orbs are empty, generate fresh\n    if (orbs.length < 3) {\n      generateOrbs(6);\n    }\n\n    updateAria();\n  }\n\n  // ------------- Drawing Helpers ----------------\n  function clear() {\n    // calm teal background\n    ctx.fillStyle = \"#102827\"; // deep greenish for electrical vibe\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawBackground() {\n    // soft glowing panels (canvas only)\n    // draw a large rounded rect fuse-like panel\n    ctx.save();\n    ctx.globalAlpha = 0.08;\n    ctx.fillStyle = \"#B8F0E0\";\n    roundRect(ctx, 40, 40, WIDTH - 80, HEIGHT - 90, 18, true, false);\n    ctx.restore();\n\n    // Wacky wires and sparkles\n    ctx.save();\n    ctx.globalAlpha = 0.6;\n    for (let i = 0; i < 4; i++) {\n      drawWavyWire(60 + i * 140, 60 + i * 30, WIDTH - 120 - i * 80, 60 + i * 30 + 120, i * 0.4);\n    }\n    ctx.restore();\n\n    // gentle floating particles\n    for (const p of gentleParticles) {\n      ctx.beginPath();\n      ctx.fillStyle = `rgba(255,255,220,${p.alpha})`;\n      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function drawWavyWire(x1, y1, x2, y2, wobble) {\n    const segments = 12;\n    ctx.beginPath();\n    for (let i = 0; i <= segments; i++) {\n      const t = i / segments;\n      const x = x1 + (x2 - x1) * t;\n      const y = y1 + (y2 - y1) * t + Math.sin(t * Math.PI * 2 + wobble * 2) * 6;\n      if (i === 0) ctx.moveTo(x, y);\n      else ctx.lineTo(x, y);\n    }\n    ctx.strokeStyle = \"#FFD66B\";\n    ctx.lineWidth = 2 + Math.sin(Date.now() / 700 + wobble) * 0.8;\n    ctx.stroke();\n\n    // little nodes along the wire\n    for (let i = 0; i <= segments; i += 3) {\n      const t = i / segments;\n      const x = x1 + (x2 - x1) * t;\n      const y = y1 + (y2 - y1) * t + Math.sin(t * Math.PI * 2 + wobble * 2) * 6;\n      ctx.beginPath();\n      ctx.fillStyle = \"#9FD8FF\";\n      ctx.arc(x, y, 3 + Math.abs(Math.sin(Date.now() / 300 + i)) * 1.4, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === \"undefined\") r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.lineTo(x + w - r, y);\n    ctx.quadraticCurveTo(x + w, y, x + w, y + r);\n    ctx.lineTo(x + w, y + h - r);\n    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);\n    ctx.lineTo(x + r, y + h);\n    ctx.quadraticCurveTo(x, y + h, x, y + h - r);\n    ctx.lineTo(x, y + r);\n    ctx.quadraticCurveTo(x, y, x + r, y);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function drawCharacters() {\n    // Professor Ohm (left): resistor-snail\n    const profX = 100;\n    const profY = HEIGHT - 110;\n    ctx.save();\n    ctx.fillStyle = \"#7FD1A0\";\n    roundRect(ctx, profX - 36, profY - 18, 72, 36, 18, true, false);\n    // make eyes\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.beginPath();\n    ctx.arc(profX - 12, profY - 3, 6, 0, Math.PI * 2);\n    ctx.arc(profX + 12, profY - 3, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#2B2D42\";\n    ctx.beginPath();\n    ctx.arc(profX - 12, profY - 2, 3, 0, Math.PI * 2);\n    ctx.arc(profX + 12, profY - 2, 3, 0, Math.PI * 2);\n    ctx.fill();\n    // little antenna\n    ctx.strokeStyle = \"#9FD8FF\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(profX - 36, profY - 10);\n    ctx.quadraticCurveTo(profX - 60, profY - 32, profX - 40, profY - 46);\n    ctx.stroke();\n    ctx.restore();\n\n    // Bulb (right): shows current bulb status\n    const bulbX = WIDTH - 120;\n    const bulbY = 120;\n    ctx.save();\n    // filament and glow depend on collected sum vs target\n    const percent = clamp(collectedSum / targetValue, 0, 1);\n    const glow = 0.08 + percent * 0.6;\n    // glow\n    ctx.beginPath();\n    ctx.fillStyle = `rgba(255,230,130,${glow})`;\n    ctx.arc(bulbX, bulbY, 50 + percent * 10, 0, Math.PI * 2);\n    ctx.fill();\n    // bulb glass\n    ctx.beginPath();\n    ctx.fillStyle = \"#FFF8D8\";\n    ctx.arc(bulbX, bulbY, 36, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = \"#F5E6A2\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    // filament\n    ctx.strokeStyle = `rgba(255,120,50,${0.5 + percent * 0.5})`;\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(bulbX - 10, bulbY);\n    ctx.quadraticCurveTo(bulbX, bulbY - 12 - percent * 8, bulbX + 10, bulbY);\n    ctx.stroke();\n    // base\n    ctx.fillStyle = \"#C7C7C7\";\n    ctx.fillRect(bulbX - 18, bulbY + 28, 36, 14);\n    ctx.restore();\n  }\n\n  function drawOrbs() {\n    for (const o of orbs) {\n      // ring glow\n      ctx.beginPath();\n      const glowAlpha = 0.14 + Math.abs(Math.sin(Date.now() / 400 + o.phase)) * 0.08;\n      ctx.fillStyle = `rgba(255, 220, 120, ${glowAlpha})`;\n      ctx.arc(o.x, o.y, o.r + 8, 0, Math.PI * 2);\n      ctx.fill();\n      // orb body\n      ctx.beginPath();\n      ctx.fillStyle = \"#FFD66B\";\n      ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);\n      ctx.fill();\n      // number\n      ctx.fillStyle = \"#2B2D42\";\n      ctx.font = `${Math.max(12, o.r)}px sans-serif`;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(String(o.value), o.x, o.y + 1);\n      // tiny spark lines\n      ctx.beginPath();\n      ctx.strokeStyle = \"rgba(255,255,255,0.7)\";\n      ctx.moveTo(o.x - o.r / 1.4, o.y - o.r / 1.4);\n      ctx.lineTo(o.x - o.r / 3, o.y - o.r / 3);\n      ctx.stroke();\n    }\n  }\n\n  function drawSpark() {\n    const sp = characters.spark;\n    // glow\n    ctx.beginPath();\n    ctx.fillStyle = `rgba(255,214,107,0.28)`;\n    ctx.arc(sp.x, sp.y, sp.radius + 12, 0, Math.PI * 2);\n    ctx.fill();\n    // body\n    ctx.beginPath();\n    ctx.fillStyle = sp.color;\n    ctx.arc(sp.x, sp.y, sp.radius, 0, Math.PI * 2);\n    ctx.fill();\n    // eyes\n    ctx.fillStyle = \"#2B2D42\";\n    ctx.beginPath();\n    ctx.arc(sp.x - 6, sp.y - 4, 3, 0, Math.PI * 2);\n    ctx.arc(sp.x + 6, sp.y - 4, 3, 0, Math.PI * 2);\n    ctx.fill();\n    // tiny tail spark\n    ctx.beginPath();\n    ctx.fillStyle = \"#FFD66B\";\n    ctx.ellipse(sp.x - sp.radius - 6, sp.y + 6, 6, 3, Math.PI / 6, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawHUD() {\n    // Top panel with target, sum, lives, score, controls\n    ctx.save();\n    ctx.fillStyle = \"rgba(16,40,39,0.6)\";\n    roundRect(ctx, 10, 8, WIDTH - 20, 56, 10, true, false);\n    // Target\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.font = \"20px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Target: ${targetValue}`, 30, 36);\n    // Current sum\n    ctx.fillStyle = \"#FFF7C6\";\n    ctx.fillText(`Collected: ${collectedSum}`, 170, 36);\n    // Lives\n    ctx.fillStyle = \"#FFCDD2\";\n    ctx.fillText(`Lives: ${lives}`, 340, 36);\n    // Score\n    ctx.fillStyle = \"#BEE7A5\";\n    ctx.fillText(`Score: ${score}`, 440, 36);\n    // Level\n    ctx.fillStyle = \"#CDE7FF\";\n    ctx.fillText(`Level: ${level}`, 550, 36);\n\n    // Controls hint\n    ctx.font = \"13px sans-serif\";\n    ctx.fillStyle = \"#DDEFF3\";\n    ctx.fillText(`Move: Arrow keys / WASD or touch-drag. M toggles sound. Enter to start.`, 30, 52);\n\n    // Audio icon\n    drawAudioIcon(WIDTH - 54, 34, audioAvailable && !audioMuted);\n    ctx.restore();\n\n    // If flash (error), draw overlay\n    if (flashTimer > 0) {\n      ctx.save();\n      const alpha = Math.min(0.6, flashTimer / 0.8);\n      ctx.fillStyle = `rgba(255, 80, 80, ${alpha})`;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.restore();\n    }\n  }\n\n  function drawAudioIcon(x, y, on) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = on ? \"#BFFCC6\" : \"#666\";\n    ctx.beginPath();\n    ctx.rect(-10, -8, 6, 16);\n    ctx.fill();\n    // speaker cone\n    ctx.beginPath();\n    ctx.moveTo(-4, -8);\n    ctx.lineTo(6, -14);\n    ctx.lineTo(6, 14);\n    ctx.lineTo(-4, 8);\n    ctx.closePath();\n    ctx.fill();\n    if (on) {\n      ctx.beginPath();\n      ctx.strokeStyle = \"#BFFCC6\";\n      ctx.lineWidth = 2;\n      ctx.arc(10, 0, 8, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      ctx.beginPath();\n      ctx.strokeStyle = \"#FF9AA2\";\n      ctx.lineWidth = 3;\n      ctx.moveTo(10, -8);\n      ctx.lineTo(-14, 14);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawStartScreen() {\n    clear();\n    drawBackground();\n    // Big title and instructions\n    ctx.save();\n    ctx.fillStyle = \"#FFF8D8\";\n    ctx.font = \"36px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Spark's Circuit Quest\", WIDTH / 2, 140);\n\n    ctx.font = \"18px sans-serif\";\n    ctx.fillStyle = \"#DDEFF3\";\n    ctx.fillText(\"Help Spark the electron power wacky bulbs!\", WIDTH / 2, 180);\n\n    // Draw Professor and Bulb as intro characters\n    drawCharacters();\n\n    // Short instructions list\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"left\";\n    const lines = [\n      \"How to play:\",\n      \" - Move Spark with arrow keys or WASD, or touch-drag on the screen.\",\n      \" - Collect numbered orbs. Their numbers add up.\",\n      \" - Match the bulb's target power exactly to light it!\",\n      \" - If you go over, the circuit overloads and you lose a life.\",\n      \" - Press M to toggle sound. Press Enter or click to start.\",\n    ];\n    let y = 260;\n    for (const line of lines) {\n      ctx.fillStyle = \"#EAF7F3\";\n      ctx.fillText(line, 80, y);\n      y += 22;\n    }\n\n    // friendly spark illustration\n    const spX = WIDTH / 2;\n    const spY = HEIGHT - 120;\n    ctx.beginPath();\n    ctx.fillStyle = \"#FFD66B\";\n    ctx.arc(spX, spY, 34, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#2B2D42\";\n    ctx.font = \"18px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Spark\", spX, spY + 6);\n    ctx.restore();\n  }\n\n  function drawGameOver() {\n    clear();\n    drawBackground();\n    drawOrbs();\n    drawSpark();\n    drawCharacters();\n    drawHUD();\n\n    ctx.save();\n    ctx.fillStyle = \"rgba(8, 10, 12, 0.6)\";\n    roundRect(ctx, WIDTH / 2 - 220, HEIGHT / 2 - 80, 440, 160, 12, true, false);\n    ctx.fillStyle = \"#FFF8D8\";\n    ctx.font = \"28px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Circuit Overloaded!\", WIDTH / 2, HEIGHT / 2 - 18);\n    ctx.font = \"18px sans-serif\";\n    ctx.fillStyle = \"#EAF7F3\";\n    ctx.fillText(`Your score: ${score}`, WIDTH / 2, HEIGHT / 2 + 8);\n    ctx.fillText(\"Press Enter or click to play again.\", WIDTH / 2, HEIGHT / 2 + 42);\n    ctx.restore();\n  }\n\n  // ------------- Main Render Loop ----------------\n  function render(timestamp) {\n    if (!lastTime) lastTime = timestamp;\n    const dt = Math.min(0.06, (timestamp - lastTime) / 1000);\n    lastTime = timestamp;\n\n    // Update\n    update(dt);\n\n    // Draw\n    if (phase === \"start\") {\n      drawStartScreen();\n    } else if (phase === \"gameover\") {\n      drawGameOver();\n    } else {\n      clear();\n      drawBackground();\n      drawOrbs();\n      drawSpark();\n      drawCharacters();\n      drawHUD();\n\n      // Draw instructions small text or status\n      if (audioAvailable === false) {\n        ctx.save();\n        ctx.fillStyle = \"#FFCCB3\";\n        ctx.font = \"14px sans-serif\";\n        ctx.textAlign = \"right\";\n        ctx.fillText(\"Audio unavailable on this device.\", WIDTH - 16, HEIGHT - 14);\n        ctx.restore();\n      }\n\n      if (phase === \"success\") {\n        ctx.save();\n        ctx.fillStyle = \"rgba(200,255,200,0.14)\";\n        roundRect(ctx, WIDTH / 2 - 180, HEIGHT / 2 - 60, 360, 120, 12, true, false);\n        ctx.fillStyle = \"#F3FFE9\";\n        ctx.font = \"24px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"Level complete! Charging next circuit...\", WIDTH / 2, HEIGHT / 2);\n        ctx.restore();\n      }\n    }\n\n    // Next frame\n    if (running) requestAnimationFrame(render);\n  }\n\n  // ------------- Start and Initialization ----------------\n  function init() {\n    spawnParticles();\n    generateOrbs(6);\n    updateAria();\n\n    // try resume audio on first user click\n    canvas.addEventListener(\"click\", tryResumeAudio, { once: true });\n    canvas.addEventListener(\"keydown\", tryResumeAudio, { once: true });\n\n    // Start drawing loop\n    running = true;\n    lastTime = performance.now();\n    requestAnimationFrame(render);\n  }\n\n  // Start on initialization\n  init();\n\n  // Start screen set\n  phase = \"start\";\n\n  // expose pause/resume for accessibility or debugging via console\n  window.sparkCircuit = {\n    pause() {\n      running = false;\n    },\n    resume() {\n      if (!running) {\n        running = true;\n        lastTime = performance.now();\n        requestAnimationFrame(render);\n      }\n    },\n    toggleAudio() {\n      audioMuted = !audioMuted;\n      if (bgGain) bgGain.gain.value = audioMuted ? 0 : 0.02;\n    },\n  };\n\n  // Provide small friendly messages into aria-label periodically\n  setInterval(() => {\n    updateAria();\n  }, 2500);\n\n  // -------------------- End --------------------\n})();\n---\n",
  "improve_response_tokens": 20685,
  "formatted_code": true,
  "formatting_response_tokens": 23189,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}