{
  "generated_date": "2025-08-22",
  "generated_timestamp": "2025-08-22T00:21:44.202462",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8502,
  "game_filename": "2025-08-22.js",
  "game_size_bytes": 23950,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Electric Math Game (Ages 7-9)\n  // Renders inside element with id \"game-of-the-day-stage\"\n  // Canvas size: 720x480\n  // All visuals drawn with canvas. All sounds generated with Web Audio API.\n  // Accessibility: keyboard controls, offscreen text updates (aria-live), visual audio indicator.\n\n  // ----- Configuration -----\n  const CANVAS_W = 720;\n  const CANVAS_H = 480;\n  const ROUNDS = 6; // number of rounds per play\n  const MIN_TARGET = 6;\n  const MAX_TARGET = 15;\n  const MAX_WIRES = 4;\n  const MIN_WIRE_VAL = 1;\n  const MAX_WIRE_VAL = 8;\n  const BG_COLOR = '#0b1630'; // deep calming blue\n  const PANEL_COLOR = '#0f2544';\n  const WIRES_COLORS = ['#FFB400', '#FF6B6B', '#6BCB77', '#4D96FF'];\n\n  // ----- DOM Setup and Accessibility -----\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container element with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  container.innerHTML = ''; // clear any content\n  container.style.position = 'relative';\n  container.style.width = CANVAS_W + 'px';\n  container.style.height = CANVAS_H + 'px';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = CANVAS_W;\n  canvas.height = CANVAS_H;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Electric math game. Use left and right arrows to select wires, space or enter to toggle. Press S to toggle sound.');\n  canvas.style.outline = 'none';\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Offscreen text for screen readers and live updates\n  const sr = document.createElement('div');\n  sr.setAttribute('aria-live', 'polite');\n  sr.style.position = 'absolute';\n  sr.style.left = '-9999px';\n  container.appendChild(sr);\n\n  // Visual small button for audio (drawn on canvas too) but we need a textual state for screen readers\n  let audioAvailable = false;\n  let audioEnabled = true;\n\n  // ----- Audio Setup -----\n  let audioCtx = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (AudioContext) {\n      audioCtx = new AudioContext();\n      audioAvailable = true;\n    } else {\n      audioAvailable = false;\n    }\n  } catch (e) {\n    console.warn('AudioContext creation failed:', e);\n    audioAvailable = false;\n    audioCtx = null;\n  }\n\n  // Gain nodes and background hum\n  let masterGain = null;\n  let humOsc = null;\n  let humGain = null;\n  if (audioAvailable) {\n    try {\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.6;\n      masterGain.connect(audioCtx.destination);\n\n      humOsc = audioCtx.createOscillator();\n      humOsc.type = 'sine';\n      humOsc.frequency.value = 110; // low hum\n      humGain = audioCtx.createGain();\n      humGain.gain.value = 0.02; // gentle\n      humOsc.connect(humGain);\n      humGain.connect(masterGain);\n      humOsc.start();\n    } catch (e) {\n      console.warn('Audio nodes setup failed:', e);\n      audioAvailable = false;\n    }\n  }\n\n  // Utility to ensure AudioContext resumed on user gesture\n  async function ensureAudioOnUserGesture() {\n    if (!audioAvailable || !audioCtx) return false;\n    try {\n      if (audioCtx.state === 'suspended') {\n        await audioCtx.resume();\n      }\n      return true;\n    } catch (e) {\n      console.warn('Unable to resume audio context:', e);\n      return false;\n    }\n  }\n\n  // Sound effects\n  function playBeep(freq = 880, duration = 0.12, type = 'sine', volume = 0.12) {\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = type;\n      osc.frequency.value = freq;\n      gain.gain.setValueAtTime(volume, audioCtx.currentTime);\n      gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);\n      osc.connect(gain);\n      gain.connect(masterGain);\n      osc.start();\n      osc.stop(audioCtx.currentTime + duration + 0.02);\n    } catch (e) {\n      console.warn('playBeep failed:', e);\n    }\n  }\n\n  function playClick() {\n    playBeep(1200, 0.06, 'triangle', 0.09);\n  }\n\n  function playCorrect() {\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      // small arpeggio celebratory\n      const now = audioCtx.currentTime;\n      const freqs = [880, 1320, 1760];\n      freqs.forEach((f, i) => {\n        const osc = audioCtx.createOscillator();\n        osc.type = 'square';\n        const g = audioCtx.createGain();\n        g.gain.value = 0.0001;\n        osc.frequency.value = f;\n        osc.connect(g);\n        g.connect(masterGain);\n        g.gain.setValueAtTime(0.12 / (i + 1), now + i * 0.08);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.08 + 0.25);\n        osc.start(now + i * 0.08);\n        osc.stop(now + i * 0.08 + 0.3);\n      });\n    } catch (e) {\n      console.warn('playCorrect failed:', e);\n    }\n  }\n\n  function playWrong() {\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      osc.type = 'sawtooth';\n      osc.frequency.setValueAtTime(220, now);\n      osc.frequency.exponentialRampToValueAtTime(80, now + 0.18);\n      g.gain.value = 0.12;\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);\n      osc.connect(g);\n      g.connect(masterGain);\n      osc.start();\n      osc.stop(now + 0.22);\n    } catch (e) {\n      console.warn('playWrong failed:', e);\n    }\n  }\n\n  // ----- Game State -----\n  let round = 1;\n  let score = 0;\n  let target = 10;\n  let wires = []; // array of {value, on, x,y for UI}\n  let selectedWire = 0;\n  let solved = false;\n  let sparksAnimation = []; // for spark particles\n  let lastTime = 0;\n  let animPulse = 0;\n\n  function newRound() {\n    solved = false;\n    // generate target and wires\n    target = randInt(MIN_TARGET, MAX_TARGET);\n    wires = [];\n    // Choose random wire values but ensure some possible combo equals target\n    // We'll make sure the sum of all wires >= target and also create at least one subset equal to target by greedy algorithm\n    // Start by creating subset values that sum to target\n    let remaining = target;\n    let subsetVals = [];\n    while (remaining > 0 && subsetVals.length < MAX_WIRES) {\n      const val = Math.min(remaining, randInt(MIN_WIRE_VAL, Math.min(MAX_WIRE_VAL, remaining)));\n      subsetVals.push(val);\n      remaining -= val;\n    }\n    // If still remaining (shouldn't), adjust\n    if (remaining > 0) subsetVals.push(remaining);\n    // Fill remaining wires with random values\n    while (subsetVals.length < MAX_WIRES) {\n      subsetVals.push(randInt(MIN_WIRE_VAL, MAX_WIRE_VAL));\n    }\n    // Shuffle and set initial states off\n    shuffleArray(subsetVals);\n    for (let i = 0; i < MAX_WIRES; i++) {\n      wires.push({\n        value: subsetVals[i],\n        on: false,\n        x: 120 + i * 140,\n        y: 260,\n        width: 100,\n        height: 36\n      });\n    }\n    selectedWire = 0;\n    announceForSR(`Round ${round}. Target ${target}. Use left and right arrows to select a wire. Press space or enter to toggle a wire.`);\n    updateBackgroundHum();\n  }\n\n  // ----- Utilities -----\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function shuffleArray(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n\n  // Announce updates for screen reader\n  function announceForSR(text) {\n    try {\n      sr.textContent = text;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  // ----- Drawing -----\n  function drawRoundedRect(x, y, w, h, r = 8, fill = true, stroke = false, strokeColor = '#000') {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) {\n      ctx.fill();\n    }\n    if (stroke) {\n      ctx.strokeStyle = strokeColor;\n      ctx.stroke();\n    }\n  }\n\n  function drawScene(timestamp) {\n    const dt = timestamp - lastTime;\n    lastTime = timestamp;\n    animPulse += dt * 0.004;\n\n    // Background\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);\n\n    // Soft skyline panel\n    ctx.fillStyle = PANEL_COLOR;\n    drawRoundedRect(20, 20, CANVAS_W - 40, 140, 12);\n\n    // Title and characters\n    drawTitle();\n\n    // Control panel where wires live\n    drawControlPanel();\n\n    // Lamp / target display\n    drawTargetLamp();\n\n    // Score and round display\n    drawScoreboard();\n\n    // Characters and wacky elements\n    drawCharacters(animPulse);\n\n    // Sparks animation\n    updateAndDrawSparks(dt);\n\n    // Instructions (bottom)\n    drawInstructions();\n\n    // Audio indicator\n    drawAudioIcon();\n\n    // If round solved, overlay celebration\n    if (solved) {\n      drawCelebration();\n    }\n\n    window.requestAnimationFrame(drawScene);\n  }\n\n  function drawTitle() {\n    ctx.save();\n    ctx.fillStyle = '#D7E9FF';\n    ctx.font = '700 28px \"Arial\"';\n    ctx.fillText('Sparky & the Power Puzzle', 34, 56);\n    ctx.font = '400 14px \"Arial\"';\n    ctx.fillStyle = '#B7D5FF';\n    ctx.fillText('Connect wires to match the power target. Add the wire numbers!', 34, 82);\n    ctx.restore();\n  }\n\n  function drawControlPanel() {\n    // Panel base\n    ctx.save();\n    ctx.fillStyle = '#0b2a2f';\n    drawRoundedRect(40, 180, CANVAS_W - 80, 260, 10);\n    ctx.restore();\n\n    // Wires area\n    wires.forEach((wire, i) => {\n      // draw wire path\n      const baseX = wire.x + wire.width / 2;\n      const baseY = wire.y - 40;\n      const jx = baseX;\n      const jy = baseY;\n      // draw twisted wacky wire\n      for (let s = 0; s < 6; s++) {\n        const x1 = jx + (s - 3) * 10;\n        const y1 = jy + Math.sin((animPulse + i * 0.8 + s) * 0.9) * 6 + s * 10;\n        ctx.beginPath();\n        ctx.strokeStyle = WIRES_COLORS[i % WIRES_COLORS.length];\n        ctx.lineWidth = 6;\n        ctx.lineCap = 'round';\n        ctx.moveTo(x1 - 8, y1 - 8);\n        ctx.lineTo(x1 + 8, y1 + 8);\n        ctx.stroke();\n      }\n\n      // Node (button)\n      ctx.fillStyle = wire.on ? WIRES_COLORS[i % WIRES_COLORS.length] : '#223447';\n      drawRoundedRect(wire.x, wire.y, wire.width, wire.height, 8);\n\n      // Value text\n      ctx.fillStyle = wire.on ? '#07241b' : '#BEE6FF';\n      ctx.font = '700 20px \"Arial\"';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(wire.value.toString(), wire.x + wire.width / 2, wire.y + wire.height / 2);\n\n      // selection highlight\n      if (i === selectedWire) {\n        ctx.strokeStyle = '#FFD66B';\n        ctx.lineWidth = 3;\n        drawRoundedRect(wire.x - 6, wire.y - 6, wire.width + 12, wire.height + 12, 10, false, true, '#FFD66B');\n      }\n\n      // wire label below\n      ctx.font = '12px \"Arial\"';\n      ctx.fillStyle = '#B9E7FF';\n      ctx.fillText('wire ' + (i + 1), wire.x + wire.width / 2, wire.y + wire.height + 18);\n    });\n  }\n\n  function drawTargetLamp() {\n    // Lamp box\n    const boxX = 480;\n    const boxY = 40;\n    ctx.save();\n    ctx.fillStyle = '#081327';\n    drawRoundedRect(boxX, boxY, 200, 120, 12);\n    // target text\n    ctx.fillStyle = '#E6F7FF';\n    ctx.font = '600 18px \"Arial\"';\n    ctx.fillText('Power Target', boxX + 100, boxY + 28);\n    ctx.font = '700 44px \"Arial\"';\n    ctx.fillStyle = '#FFF2B2';\n    ctx.fillText(target.toString(), boxX + 100, boxY + 78);\n\n    // Lamp graphic\n    const lampX = boxX + 100;\n    const lampY = boxY + 110;\n    const glow = solved ? 1.4 : 1 + Math.abs(Math.sin(animPulse)) * 0.12;\n    // glow\n    ctx.beginPath();\n    const grd = ctx.createRadialGradient(lampX, lampY - 10, 6, lampX, lampY - 10, 60);\n    grd.addColorStop(0, `rgba(255,235,120,${0.15 * glow})`);\n    grd.addColorStop(1, 'rgba(255,235,120,0)');\n    ctx.fillStyle = grd;\n    ctx.arc(lampX, lampY - 10, 60, 0, Math.PI * 2);\n    ctx.fill();\n\n    // bulb\n    ctx.fillStyle = solved ? '#FFF09E' : '#FFFAE0';\n    ctx.beginPath();\n    ctx.ellipse(lampX, lampY - 10, 30, 36, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // base\n    ctx.fillStyle = '#B9C7D8';\n    drawRoundedRect(lampX - 22, lampY + 24, 44, 12, 3);\n    ctx.restore();\n  }\n\n  function drawScoreboard() {\n    ctx.save();\n    ctx.fillStyle = '#E9F5FF';\n    ctx.font = '600 16px \"Arial\"';\n    ctx.fillText(`Round ${round}/${ROUNDS}`, 40, 160);\n    ctx.fillText(`Score ${score}`, 160, 160);\n    ctx.restore();\n  }\n\n  function drawCharacters(pulse) {\n    // Sparky: little spark creature\n    const sx = 120;\n    const sy = 110;\n    ctx.save();\n    // body glow\n    const glow = 0.3 + Math.abs(Math.sin(pulse)) * 0.2;\n    const g = ctx.createRadialGradient(sx, sy, 4, sx, sy, 40);\n    g.addColorStop(0, `rgba(255,220,120,${0.8 * glow})`);\n    g.addColorStop(1, 'rgba(255,220,120,0)');\n    ctx.fillStyle = g;\n    ctx.beginPath();\n    ctx.arc(sx, sy, 40, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.fillStyle = '#FFD66B';\n    ctx.beginPath();\n    ctx.moveTo(sx, sy - 22);\n    ctx.bezierCurveTo(sx + 18, sy - 10, sx + 12, sy + 18, sx, sy + 22);\n    ctx.bezierCurveTo(sx - 12, sy + 18, sx - 18, sy - 10, sx, sy - 22);\n    ctx.fill();\n\n    // eyes\n    ctx.fillStyle = '#07241b';\n    ctx.beginPath();\n    ctx.arc(sx - 8, sy - 4, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(sx + 8, sy - 4, 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    // smile\n    ctx.strokeStyle = '#07241b';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(sx, sy + 2, 8, 0, Math.PI);\n    ctx.stroke();\n\n    // speech bubble\n    ctx.fillStyle = '#E9F5FF';\n    drawRoundedRect(sx + 40, sy - 36, 200, 44, 8);\n    ctx.fillStyle = '#063046';\n    ctx.font = '600 14px \"Arial\"';\n    ctx.fillText(\"Let's light the houses! Add wires to equal the target.\", sx + 50, sy - 12);\n\n    ctx.restore();\n\n    // Dr. Volt (plug scientist)\n    const vx = 560;\n    const vy = 180;\n    ctx.save();\n    ctx.fillStyle = '#D6EFFA';\n    drawRoundedRect(vx - 26, vy - 14, 52, 58, 8);\n    ctx.fillStyle = '#123C5C';\n    ctx.fillRect(vx - 18, vy + 36, 36, 10);\n    ctx.fillStyle = '#123C5C';\n    ctx.font = '700 12px \"Arial\"';\n    ctx.fillText('Dr. Volt', vx, vy - 26);\n    ctx.restore();\n  }\n\n  function drawInstructions() {\n    ctx.save();\n    ctx.fillStyle = '#BFE7FF';\n    ctx.font = '12px \"Arial\"';\n    ctx.textAlign = 'left';\n    ctx.fillText('Controls: \u2190 \u2192  select wire   Space/Enter toggle   S sound   R reset', 40, 460);\n    ctx.restore();\n  }\n\n  function drawAudioIcon() {\n    // top-right small speaker\n    const x = CANVAS_W - 40;\n    const y = 24;\n    ctx.save();\n    ctx.globalAlpha = 0.95;\n    ctx.fillStyle = audioAvailable ? (audioEnabled ? '#BFF1C2' : '#FFD6D6') : '#777';\n    drawRoundedRect(x - 18, y - 14, 36, 28, 6);\n    // speaker shape\n    ctx.fillStyle = '#07241b';\n    ctx.beginPath();\n    ctx.moveTo(x - 8, y - 6);\n    ctx.lineTo(x - 2, y - 6);\n    ctx.lineTo(x + 6, y - 12);\n    ctx.lineTo(x + 6, y + 12);\n    ctx.lineTo(x - 2, y + 6);\n    ctx.lineTo(x - 8, y + 6);\n    ctx.closePath();\n    ctx.fill();\n\n    // waves\n    if (audioAvailable && audioEnabled) {\n      ctx.strokeStyle = '#07241b';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(x + 10, y, 6, -0.6, 0.6);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(x + 10, y, 10, -0.6, 0.6);\n      ctx.stroke();\n    } else if (!audioAvailable) {\n      ctx.fillStyle = '#444';\n      ctx.font = '600 10px Arial';\n      ctx.fillText('X', x + 12, y + 4);\n    } else {\n      ctx.strokeStyle = '#440000';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(x + 6, y - 6);\n      ctx.lineTo(x + 12, y + 6);\n      ctx.moveTo(x + 12, y - 6);\n      ctx.lineTo(x + 6, y + 6);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawCelebration() {\n    ctx.save();\n    ctx.fillStyle = 'rgba(255, 250, 220, 0.18)';\n    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);\n    ctx.fillStyle = '#fff';\n    ctx.font = '700 36px \"Arial\"';\n    ctx.textAlign = 'center';\n    ctx.fillText('You did it!', CANVAS_W / 2, CANVAS_H / 2 - 8);\n    ctx.font = '600 18px \"Arial\"';\n    ctx.fillText('Great adding! Press Enter for next round.', CANVAS_W / 2, CANVAS_H / 2 + 28);\n    ctx.restore();\n  }\n\n  // ----- Sparks (particle) effects when wrong or toggle -----\n  function spawnSparks(x, y, color = '#FFB400') {\n    for (let i = 0; i < 12; i++) {\n      sparksAnimation.push({\n        x: x,\n        y: y,\n        vx: (Math.random() - 0.5) * 6,\n        vy: -Math.random() * 4 - 1,\n        life: 600 + Math.random() * 400,\n        age: 0,\n        color: color,\n        size: 2 + Math.random() * 3,\n      });\n    }\n  }\n\n  function updateAndDrawSparks(dt) {\n    for (let i = sparksAnimation.length - 1; i >= 0; i--) {\n      const p = sparksAnimation[i];\n      p.age += dt;\n      p.x += p.vx;\n      p.y += p.vy + 0.02 * dt; // gravity\n      p.vx *= 0.99;\n      p.vy += 0.02;\n      const lifeRatio = 1 - p.age / p.life;\n      if (lifeRatio <= 0) {\n        sparksAnimation.splice(i, 1);\n        continue;\n      }\n      ctx.globalAlpha = lifeRatio;\n      ctx.fillStyle = p.color;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, p.size * lifeRatio, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n  }\n\n  // ----- Game Logic -----\n  function toggleWire(index) {\n    if (index < 0 || index >= wires.length) return;\n    wires[index].on = !wires[index].on;\n    const centerX = wires[index].x + wires[index].width / 2;\n    const centerY = wires[index].y - 10;\n    spawnSparks(centerX, centerY, wires[index].on ? WIRES_COLORS[index] : '#888');\n    playClick();\n    evaluateSum();\n    updateBackgroundHum();\n    announceForSR(`Wire ${index + 1} ${wires[index].on ? 'on' : 'off'}. Current total ${currentSum()}.`);\n  }\n\n  function currentSum() {\n    return wires.reduce((acc, w) => acc + (w.on ? w.value : 0), 0);\n  }\n\n  function evaluateSum() {\n    const sum = currentSum();\n    if (!solved && sum === target) {\n      solved = true;\n      score += 1;\n      playCorrect();\n      spawnSparks(CANVAS_W / 2, 200, '#B8FFB0');\n      announceForSR('Correct! The lamp lit up. Press Enter to continue.');\n      // small hum increase for success\n      if (humGain) humGain.gain.setTargetAtTime(0.08, audioCtx.currentTime, 0.2);\n    } else if (sum > target) {\n      playWrong();\n      // harsher sparks near lamp\n      spawnSparks(540, 100, '#FF6B6B');\n      announceForSR(`Oops! Sum is ${sum}. That's more than ${target}. Try turning some wires off.`);\n    } else {\n      // gentle feedback\n      // reduce hum slightly as power increases\n      if (humGain && audioAvailable) {\n        const ratio = sum / Math.max(1, target);\n        humGain.gain.setTargetAtTime(0.02 + 0.08 * ratio, audioCtx.currentTime, 0.1);\n      }\n    }\n  }\n\n  function updateBackgroundHum() {\n    if (!audioAvailable || !humGain) return;\n    const sum = currentSum();\n    const ratio = sum / Math.max(1, target);\n    humGain.gain.setTargetAtTime(0.02 + 0.08 * ratio, audioCtx.currentTime, 0.08);\n  }\n\n  function nextRoundOrEnd() {\n    if (!solved) return;\n    if (round < ROUNDS) {\n      round++;\n      newRound();\n    } else {\n      // game end - show final message and reset option\n      announceForSR(`Game complete! Your score ${score} out of ${ROUNDS}. Press R to restart.`);\n      // freeze hum\n      if (humGain) humGain.gain.setTargetAtTime(0.02, audioCtx.currentTime, 0.4);\n      solved = true;\n      // set round back to 1 after a delay option - here we keep until R pressed\n    }\n  }\n\n  function resetGame() {\n    round = 1;\n    score = 0;\n    newRound();\n    announceForSR('Game reset. New round started.');\n  }\n\n  // ----- Input Handling -----\n  canvas.tabIndex = 0;\n  canvas.addEventListener('click', async (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const cx = e.clientX - rect.left;\n    const cy = e.clientY - rect.top;\n\n    // check audio icon area clicks\n    const ax = CANVAS_W - 40;\n    const ay = 24;\n    if (cx >= ax - 18 && cx <= ax + 18 && cy >= ay - 14 && cy <= ay + 14) {\n      toggleAudio();\n      return;\n    }\n\n    // if solved and player clicked, maybe proceed\n    if (solved && round >= ROUNDS) {\n      // nothing unless reset\n    } else if (solved) {\n      nextRoundOrEnd();\n      return;\n    }\n\n    // check wire button clicks\n    for (let i = 0; i < wires.length; i++) {\n      const w = wires[i];\n      if (cx >= w.x && cx <= w.x + w.width && cy >= w.y && cy <= w.y + w.height) {\n        await ensureAudioOnUserGesture();\n        selectedWire = i;\n        toggleWire(i);\n        return;\n      }\n    }\n    // else focus canvas to enable keyboard\n    canvas.focus();\n  });\n\n  // Keyboard controls\n  canvas.addEventListener('keydown', async (e) => {\n    if (e.key === 'ArrowRight') {\n      selectedWire = (selectedWire + 1) % wires.length;\n      playBeep(660, 0.06, 'sine', 0.06);\n      announceForSR(`Selected wire ${selectedWire + 1}. Value ${wires[selectedWire].value}.`);\n      e.preventDefault();\n    } else if (e.key === 'ArrowLeft') {\n      selectedWire = (selectedWire - 1 + wires.length) % wires.length;\n      playBeep(660, 0.06, 'sine', 0.06);\n      announceForSR(`Selected wire ${selectedWire + 1}. Value ${wires[selectedWire].value}.`);\n      e.preventDefault();\n    } else if (e.key === ' ' || e.key === 'Enter') {\n      await ensureAudioOnUserGesture();\n      if (solved) {\n        nextRoundOrEnd();\n      } else {\n        toggleWire(selectedWire);\n      }\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === 's') {\n      toggleAudio();\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === 'r') {\n      resetGame();\n      e.preventDefault();\n    }\n  });\n\n  // Also support pointer move highlighting wires for visual cue\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const cx = e.clientX - rect.left;\n    const cy = e.clientY - rect.top;\n    for (let i = 0; i < wires.length; i++) {\n      const w = wires[i];\n      // highlight on hover visually by setting selected\n      if (cx >= w.x && cx <= w.x + w.width && cy >= w.y && cy <= w.y + w.height) {\n        selectedWire = i;\n      }\n    }\n  });\n\n  // Allow focusing with click anywhere on container\n  container.addEventListener('click', () => {\n    canvas.focus();\n  });\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    if (!audioAvailable) {\n      announceForSR('Audio is not available in this browser.');\n      return;\n    }\n    audioEnabled = !audioEnabled;\n    if (audioEnabled) {\n      ensureAudioOnUserGesture();\n      playBeep(900, 0.08, 'sine', 0.12);\n      announceForSR('Audio enabled.');\n    } else {\n      announceForSR('Audio muted.');\n    }\n  }\n\n  // ----- Input safety: ensure audio errors not fatal -----\n  window.addEventListener('unhandledrejection', (e) => {\n    console.warn('Unhandled promise rejection in game:', e.reason);\n  });\n\n  // ----- Initialization -----\n  function init() {\n    // Focus canvas for keyboard control\n    canvas.focus();\n\n    // Start first round\n    resetGame();\n\n    // Start animation loop\n    lastTime = performance.now();\n    window.requestAnimationFrame(drawScene);\n\n    // Accessibility startup message\n    announceForSR('Welcome to Sparky & the Power Puzzle. Use arrow keys to pick a wire. Press space to toggle. Press S to toggle sound. Press R to restart.');\n  }\n\n  // Start but wait for a small user gesture for audio context resume if available\n  init();\n\n  // ----- Error handling reported on canvas when audio unavailable -----\n  if (!audioAvailable) {\n    console.warn('Audio not available. Game will continue without sound.');\n    announceForSR('Note: Audio is not available in this browser. You can still play using visuals and keyboard.');\n  }\n\n  // Expose some state for debugging in console (non-invasive)\n  window.__electricMathGame = {\n    restart: resetGame,\n    state: () => ({ round, score, target, wires, selectedWire, solved }),\n  };\n})();\n---\n",
  "improve_response_tokens": 17991,
  "formatted_code": true,
  "formatting_response_tokens": 20172,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}