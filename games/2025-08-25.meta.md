# Game of the Day - 2025-08-25

## Metadata
- **Generated Date:** 2025-08-25
- **Generated Time:** 2025-08-25T00:23:21.936946
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-25.js
- **File Size:** 36850 bytes
- **Tokens Used:** 11295

## Functionality Score
- **Score:** 7/8 (87.5%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- ⚠️  No game state management found

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-25.js` - The playable game
- `2025-08-25.meta.json` - Machine-readable metadata
- `2025-08-25.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22322

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23475

### Final Functionality Score After Improvement
- **Score:** 7/8 (87.5%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- ⚠️  No game state management found

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Electricity Math Game for ages 7-9
  // Renders inside element with ID 'game-of-the-day-stage'
  // Canvas 720x480, uses Web Audio API (oscillators), accessible keyboard controls, drag/touch support.
  // All visuals drawn with canvas methods. No external resources.

  // Ensure container exists
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container and set ARIA
  container.innerHTML = '';
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Electric math game. Solve addition puzzles to light bulbs.');
  container.style.outline = 'none';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.setAttribute('tabindex', '0');
  canvas.style.display = 'block';
  canvas.style.background = '#0b1020'; // dark background for glow
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d', { alpha: false });

  // Accessibility live region for announcements
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '-9999px';
  live.style.width = '1px';
  live.style.height = '1px';
  live.style.overflow = 'hidden';
  live.textContent = '';
  container.appendChild(live);

  // Global variables
  const WIDTH = 720;
  const HEIGHT = 480;

  // Input state
  let mouse = { x: 0, y: 0, down: false };
  let touchId = null;

  // Utility
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }

  // Sound Manager using Web Audio API
  class SoundManager {
    constructor() {
      this.enabled = true;
      this.ctx = null;
      this.master = null;
      this.bgGain = null;
      this.bgOsc = null;
      this.available = false;
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) throw new Error('Web Audio API not supported');
        this.ctx = new AudioContext();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.9;
        this.master.connect(this.ctx.destination);

        // Background gentle hum
        this.bgGain = this.ctx.createGain();
        this.bgGain.gain.value = 0.02; // very subtle
        this.bgOsc = this.ctx.createOscillator();
        this.bgOsc.type = 'sine';
        this.bgOsc.frequency.value = 110; // low hum
        const bgFilter = this.ctx.createBiquadFilter();
        bgFilter.type = 'lowpass';
        bgFilter.frequency.value = 300;
        this.bgOsc.connect(bgFilter);
        bgFilter.connect(this.bgGain);
        this.bgGain.connect(this.master);
        this.bgOsc.start();

        this.available = true;
      } catch (e) {
        console.warn('Audio unavailable:', e);
        this.available = false;
        this.ctx = null;
      }
    }

    // Attempt to resume audio context on user gesture
    async resume() {
      if (!this.ctx) return;
      try {
        if (this.ctx.state === 'suspended') await this.ctx.resume();
      } catch (e) {
        console.warn('Error resuming audio context:', e);
      }
    }

    // Toggle audio on/off
    setEnabled(on) {
      this.enabled = on;
      if (!this.available) this.enabled = false;
      if (this.master) this.master.gain.value = this.enabled ? 0.9 : 0.0;
    }

    // Simple click sound
    click() {
      if (!this.enabled || !this.available) return;
      try {
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = 'square';
        o.frequency.value = 880;
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(this.master);
        o.start();
        g.gain.exponentialRampToValueAtTime(0.12, this.ctx.currentTime + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.18);
        o.stop(this.ctx.currentTime + 0.19);
      } catch (e) {
        console.warn('Click sound error', e);
      }
    }

    // Success chord
    success() {
      if (!this.enabled || !this.available) return;
      try {
        const now = this.ctx.currentTime;
        const freqs = [660, 880, 990]; // pleasant triad-ish
        freqs.forEach((f, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = ['sine', 'sawtooth', 'triangle'][i % 3];
          o.frequency.value = f;
          g.gain.value = 0.0001;
          o.connect(g);
          g.connect(this.master);
          o.start(now + i * 0.02);
          g.gain.exponentialRampToValueAtTime(0.12 / (i + 1), now + 0.02 + i * 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5 + i * 0.02);
          o.stop(now + 0.55 + i * 0.02);
        });
      } catch (e) {
        console.warn('Success sound error', e);
      }
    }

    // Error buzz
    error() {
      if (!this.enabled || !this.available) return;
      try {
        const now = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        const f = 220;
        o.type = 'sawtooth';
        o.frequency.value = f;
        g.gain.value = 0.0001;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 600;
        o.connect(filter);
        filter.connect(g);
        g.connect(this.master);
        o.start(now);
        g.gain.exponentialRampToValueAtTime(0.12, now + 0.03);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
        o.frequency.exponentialRampToValueAtTime(f * 3, now + 0.25);
        o.stop(now + 0.28);
      } catch (e) {
        console.warn('Error sound error', e);
      }
    }

    // gentle tap
    tap() {
      if (!this.enabled || !this.available) return;
      try {
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = 'sine';
        o.frequency.value = 440;
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(this.master);
        o.start();
        g.gain.exponentialRampToValueAtTime(0.07, this.ctx.currentTime + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.12);
        o.stop(this.ctx.currentTime + 0.13);
      } catch (e) {
        console.warn('Tap sound error', e);
      }
    }
  }

  const sound = new SoundManager();

  // Game Characters for fun: Sparky (squirrel electrician) and Volt (friendly robot)
  class Character {
    constructor(name, color, x, y) {
      this.name = name;
      this.color = color;
      this.x = x;
      this.y = y;
      this.w = 120;
      this.h = 120;
      this.wave = 0;
    }
    update(dt) {
      this.wave += dt * 2;
    }
    draw(ctx) {
      // Simple whimsical character: circle head with tools
      ctx.save();
      ctx.translate(this.x, this.y);

      // shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.ellipse(0, 52, this.w * 0.6, 18, 0, 0, Math.PI * 2);
      ctx.fill();

      // body
      ctx.fillStyle = this.color;
      roundRect(ctx, -50, -20, 100, 80, 18);
      ctx.fill();

      // head
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(0, -40, 36, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#222';
      // eyes
      ctx.beginPath();
      ctx.arc(-12, -44, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(12, -44, 6, 0, Math.PI * 2);
      ctx.fill();

      // smile
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, -34, 10, 0, Math.PI);
      ctx.stroke();

      // wobbling tool (a tiny lightning wrench)
      ctx.save();
      ctx.translate(38, -2 + Math.sin(this.wave) * 3);
      ctx.rotate(Math.sin(this.wave) * 0.3);
      ctx.fillStyle = '#ffd54f';
      roundRect(ctx, -6, -18, 12, 36, 4);
      ctx.fillStyle = '#ff8a65';
      ctx.beginPath();
      ctx.moveTo(6, -18);
      ctx.lineTo(14, -10);
      ctx.lineTo(6, -2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // name banner
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      roundRect(ctx, -60, 40, 120, 18, 9);
      ctx.fillStyle = '#fff';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(this.name, 0, 54);

      ctx.restore();
    }
  }

  // Round rect helper
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Battery and Bulb classes
  class Battery {
    constructor(id, val, x, y) {
      this.id = id;
      this.val = val;
      this.x = x;
      this.y = y;
      this.r = 32;
      this.drag = false;
      this.offsetX = 0;
      this.offsetY = 0;
      this.attachedTo = null; // bulb id if attached
      this.pulse = Math.random() * Math.PI * 2;
      this.visible = true;
      this.focused = false;
    }

    contains(px, py) {
      return Math.hypot(px - this.x, py - this.y) <= this.r;
    }

    draw(ctx) {
      if (!this.visible) return;
      this.pulse += 0.06;
      // battery body
      ctx.save();
      ctx.translate(this.x, this.y);
      // glow if focused or dragging
      const glow = this.drag || this.focused ? 0.6 : 0.15;
      const grd = ctx.createRadialGradient(-6, -6, 6, 6, 6, 40);
      grd.addColorStop(0, `rgba(255,255,180,${0.9 * glow})`);
      grd.addColorStop(1, `rgba(255,180,60,${0.0 + glow * 0.2})`);
      ctx.fillStyle = '#ffecb3';
      roundRect(ctx, -26, -40, 52, 80, 8);
      ctx.fill();

      // top terminal
      ctx.fillStyle = '#bdbdbd';
      roundRect(ctx, -10, -46, 20, 12, 3);
      ctx.fill();

      // lightning symbol
      ctx.fillStyle = '#ff8a00';
      ctx.beginPath();
      ctx.moveTo(-6, -6);
      ctx.lineTo(6, -6);
      ctx.lineTo(0, 18);
      ctx.lineTo(8, 4);
      ctx.lineTo(-4, 4);
      ctx.closePath();
      ctx.fill();

      // value
      ctx.fillStyle = '#222';
      ctx.font = 'bold 20px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(this.val, 0, 28);

      // small focus ring
      if (this.focused) {
        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, 0, this.r + 8, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    }
  }

  class Bulb {
    constructor(id, target, x, y) {
      this.id = id;
      this.target = target;
      this.x = x;
      this.y = y;
      this.r = 46;
      this.attached = []; // battery ids
      this.lit = false;
      this.glow = 0;
      this.focused = false;
    }

    contains(px, py) {
      return Math.hypot(px - this.x, py - this.y) <= this.r;
    }

    currentSum(batteries) {
      return this.attached.reduce((s, bid) => {
        const b = batteries.find(bb => bb.id === bid);
        return s + (b ? b.val : 0);
      }, 0);
    }

    update(dt, batteries) {
      const sum = this.currentSum(batteries);
      if (sum === this.target) {
        this.lit = true;
        this.glow = Math.min(1, this.glow + dt * 4);
      } else {
        this.lit = false;
        this.glow = Math.max(0, this.glow - dt * 2);
      }
    }

    draw(ctx, batteries, time) {
      ctx.save();
      ctx.translate(this.x, this.y);
      // base bulb
      const litAmt = this.glow;
      // glass
      const grd = ctx.createRadialGradient(-10, -18, 8, 10, 12, 80);
      grd.addColorStop(0, `rgba(255,255,200,${0.6 * (0.5 + litAmt * 0.5)})`);
      grd.addColorStop(1, `rgba(220,220,255,${0.05 + litAmt * 0.2})`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(0, -6, this.r * 0.9, this.r, 0, 0, Math.PI * 2);
      ctx.fill();

      // filament / bolt when lit
      if (this.lit) {
        ctx.strokeStyle = `rgba(255,230,120,${0.95})`;
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-10, -6);
        ctx.lineTo(-2, 6 + Math.sin(time * 8) * 2);
        ctx.lineTo(10, -10);
        ctx.stroke();

        // halo
        ctx.shadowColor = 'rgba(255,230,120,0.8)';
        ctx.shadowBlur = 24 * litAmt;
        ctx.fillStyle = `rgba(255,220,120,${0.08 + 0.25 * litAmt})`;
        ctx.beginPath();
        ctx.ellipse(0, -6, this.r * 1.6, this.r * 1.2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else {
        // unlit filament
        ctx.strokeStyle = '#6d6d6d';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-10, -6);
        ctx.lineTo(-2, 6);
        ctx.lineTo(10, -10);
        ctx.stroke();
      }

      // base metal
      ctx.fillStyle = '#9e9e9e';
      roundRect(ctx, -28, 20, 56, 18, 4);
      ctx.fill();

      // text: target and current sum
      ctx.fillStyle = '#fff';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`Need ${this.target}`, 0, 56);

      const sum = this.currentSum(batteries);
      ctx.fillStyle = sum > this.target ? '#ffcccc' : '#bfefff';
      ctx.font = '16px bold sans-serif';
      ctx.fillText(`${sum}/${this.target}`, 0, 40);

      // focus ring
      if (this.focused) {
        ctx.strokeStyle = 'rgba(180,220,255,0.9)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, -6, this.r + 8, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    }
  }

  // Game logic
  class Game {
    constructor(ctx) {
      this.ctx = ctx;
      this.last = performance.now();
      this.batteries = [];
      this.bulbs = [];
      this.characters = [
        new Character('Sparky', '#ff8a80', 110, 110),
        new Character('Volt', '#82b1ff', 610, 120)
      ];
      this.selectedBattery = null;
      this.selectedBatteryIndex = -1;
      this.focusList = []; // order: batteries then bulbs
      this.focusIndex = 0;
      this.mouseOver = null;
      this.electrons = []; // for animation along wires
      this.time = 0;
      this.audioOn = sound.enabled && sound.available;
      this.announced = '';
      this.generatePuzzle();
      this.bindEvents();
      this.running = true;
      this.frame = this.frame.bind(this);
      requestAnimationFrame(this.frame);
    }

    generatePuzzle() {
      this.batteries = [];
      this.bulbs = [];
      // choose 3 bulbs with targets between 5 and 15
      const possibleTargets = [5, 6, 7, 8, 9, 10, 11, 12, 13];
      for (let i = 0; i < 3; i++) {
        const target = possibleTargets.splice(randInt(0, possibleTargets.length - 1), 1)[0];
        const x = 180 + i * 180;
        const y = 200;
        this.bulbs.push(new Bulb(i, target, x, y));
      }
      // Create batteries: ensure solvability by creating for each bulb 2-3 numbers that sum to target
      const usedVals = [];
      let bid = 0;
      this.bulbs.forEach((bulb) => {
        // create 2 addends usually, sometimes 3
        const parts = Math.random() < 0.3 ? 3 : 2;
        let remaining = bulb.target;
        for (let p = 0; p < parts; p++) {
          const maxVal = Math.min(9, remaining - (parts - p - 1) * 1);
          const minVal = Math.max(1, Math.floor(remaining / (parts - p)) - 2);
          let v = randInt(minVal, maxVal);
          // avoid duplicates too much
          if (usedVals.includes(v)) v = Math.max(1, v - 1);
          remaining -= v;
          usedVals.push(v);
          const bx = 80 + (usedVals.length - 1) * 90 + (Math.random() * 20 - 10);
          const by = 360 + (Math.random() * 40 - 20);
          this.batteries.push(new Battery(bid++, v, bx, by));
          // attach logically? no, they start free
        }
      });
      // Add a few extra batteries as distractors
      const extras = 3;
      for (let i = 0; i < extras; i++) {
        const v = randInt(1, 9);
        const bx = 80 + (this.batteries.length) * 82 + (Math.random() * 20 - 10);
        const by = 360 + (Math.random() * 40 - 20);
        this.batteries.push(new Battery(bid++, v, bx, by));
      }

      // Randomize battery positions a bit
      this.batteries.forEach((b, i) => {
        b.x = 70 + i * 90;
        b.y = 350 + (i % 2 === 0 ? -8 : 8);
        b.visible = true;
        b.attachedTo = null;
      });

      // Build focus list
      this.focusList = [...this.batteries.map(b => ({ type: 'battery', id: b.id })), ...this.bulbs.map(b => ({ type: 'bulb', id: b.id }))];
      this.focusIndex = 0;
      this.updateFocus();
      this.electrons = [];
      live.textContent = 'New puzzle. Drag number batteries to bulbs to make the sums match the needed values.';
      this.announce('New puzzle ready. Drag batteries to bulbs to match the numbers.');
    }

    updateFocus() {
      // clear all
      this.batteries.forEach(b => b.focused = false);
      this.bulbs.forEach(b => b.focused = false);
      const focused = this.focusList[this.focusIndex];
      if (!focused) return;
      if (focused.type === 'battery') {
        const b = this.batteries.find(bb => bb.id === focused.id);
        if (b) b.focused = true;
      } else {
        const bl = this.bulbs.find(bb => bb.id === focused.id);
        if (bl) bl.focused = true;
      }
    }

    bindEvents() {
      // Mouse
      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
        mouse.down = true;
        this.onPointerDown(mouse.x, mouse.y);
      });
      window.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
        if (mouse.down) this.onPointerMove(mouse.x, mouse.y);
      });
      window.addEventListener('mouseup', (e) => {
        if (mouse.down) {
          const rect = canvas.getBoundingClientRect();
          mouse.x = e.clientX - rect.left;
          mouse.y = e.clientY - rect.top;
          this.onPointerUp(mouse.x, mouse.y);
        }
        mouse.down = false;
      });

      // Touch
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (touchId !== null) return;
        const t = e.changedTouches[0];
        touchId = t.identifier;
        const rect = canvas.getBoundingClientRect();
        const x = t.clientX - rect.left;
        const y = t.clientY - rect.top;
        mouse.x = x; mouse.y = y; mouse.down = true;
        this.onPointerDown(x, y);
      }, { passive: false });
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (let t of e.changedTouches) {
          if (t.identifier === touchId) {
            const rect = canvas.getBoundingClientRect();
            const x = t.clientX - rect.left;
            const y = t.clientY - rect.top;
            mouse.x = x; mouse.y = y;
            this.onPointerMove(x, y);
            break;
          }
        }
      }, { passive: false });
      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let t of e.changedTouches) {
          if (t.identifier === touchId) {
            const rect = canvas.getBoundingClientRect();
            const x = t.clientX - rect.left;
            const y = t.clientY - rect.top;
            this.onPointerUp(x, y);
            touchId = null;
            mouse.down = false;
            break;
          }
        }
      }, { passive: false });

      // Keyboard controls
      canvas.addEventListener('keydown', async (e) => {
        // Ensure audio resumed on user gesture
        if (sound.available) await sound.resume();

        if (e.key === 'Tab') {
          e.preventDefault();
          // cycle focus
          this.focusIndex = (this.focusIndex + 1) % this.focusList.length;
          this.updateFocus();
          sound.tap();
          this.announce('Focus moved');
        } else if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          // pick up or drop depending on focus
          const focused = this.focusList[this.focusIndex];
          if (!focused) return;
          if (focused.type === 'battery') {
            const battery = this.batteries.find(b => b.id === focused.id);
            if (!this.selectedBattery) {
              // pick up
              this.selectedBattery = battery;
              this.selectedBattery.drag = true;
              this.selectedBattery.offsetX = 0;
              this.selectedBattery.offsetY = 0;
              sound.click();
              this.announce(`Picked up battery ${battery.val}`);
            } else if (this.selectedBattery.id === battery.id) {
              // drop where it is
              this.selectedBattery.drag = false;
              this.selectedBattery = null;
              sound.tap();
              this.announce('Placed battery down');
            } else {
              // pick another: drop previous, pick this
              this.selectedBattery.drag = false;
              this.selectedBattery = battery;
              this.selectedBattery.drag = true;
              sound.click();
              this.announce(`Picked up battery ${battery.val}`);
            }
          } else if (focused.type === 'bulb') {
            const bulb = this.bulbs.find(b => b.id === focused.id);
            if (this.selectedBattery) {
              // attempt attach
              this.tryAttach(this.selectedBattery, bulb);
            } else {
              // give hint
              const sum = bulb.currentSum(this.batteries);
              this.announce(`Bulb needs ${bulb.target}. It currently has ${sum}.`);
            }
          }
        } else if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
          // move selected battery if any
          if (this.selectedBattery) {
            switch (e.key) {
              case 'ArrowLeft': this.selectedBattery.x -= 12; break;
              case 'ArrowRight': this.selectedBattery.x += 12; break;
              case 'ArrowUp': this.selectedBattery.y -= 12; break;
              case 'ArrowDown': this.selectedBattery.y += 12; break;
            }
            sound.tap();
          }
        } else if (e.key === 'r' || e.key === 'R') {
          // reset / new puzzle
          this.generatePuzzle();
          sound.tap();
        } else if (e.key === 'm' || e.key === 'M') {
          // toggle audio
          this.audioOn = !this.audioOn;
          sound.setEnabled(this.audioOn);
          this.announce(`Audio ${this.audioOn ? 'on' : 'off'}`);
        }
      });

      // For accessibility: focus canvas on click
      canvas.addEventListener('focus', () => {
        this.announce('Game focused. Tab to cycle through batteries and bulbs. Enter to pick up or attach. Arrow keys move picked battery. Press R for new puzzle. Press M to toggle audio.');
      });
    }

    onPointerDown(x, y) {
      // pick battery if clicked
      const b = this.batteries.slice().reverse().find(bb => bb.visible && bb.contains(x, y));
      if (b) {
        this.selectedBattery = b;
        b.drag = true;
        b.offsetX = x - b.x;
        b.offsetY = y - b.y;
        // focus to this battery
        this.focusIndex = this.focusList.findIndex(f => f.type === 'battery' && f.id === b.id);
        this.updateFocus();
        sound.click();
        this.announce(`Picked up battery ${b.val}`);
        return;
      }
      // if clicked on a bulb and carrying battery, attach
      const bl = this.bulbs.find(bb => bb.contains(x, y));
      if (bl && this.selectedBattery) {
        this.tryAttach(this.selectedBattery, bl);
        return;
      }
      // clicked empty: drop selected battery
      if (this.selectedBattery) {
        this.selectedBattery.drag = false;
        this.announce('Placed battery');
        this.selectedBattery = null;
        sound.tap();
      }
    }

    onPointerMove(x, y) {
      if (this.selectedBattery && this.selectedBattery.drag) {
        this.selectedBattery.x = x - this.selectedBattery.offsetX;
        this.selectedBattery.y = y - this.selectedBattery.offsetY;
      } else {
        // highlight hovered battery or bulb
        const overB = this.batteries.find(bb => bb.visible && bb.contains(x, y));
        if (overB) {
          this.mouseOver = { type: 'battery', id: overB.id };
        } else {
          const overBulb = this.bulbs.find(bb => bb.contains(x, y));
          if (overBulb) this.mouseOver = { type: 'bulb', id: overBulb.id }; else this.mouseOver = null;
        }
      }
    }

    onPointerUp(x, y) {
      if (this.selectedBattery && this.selectedBattery.drag) {
        // check if over a bulb to attach
        const overBulb = this.bulbs.find(bb => bb.contains(x, y));
        if (overBulb) {
          this.tryAttach(this.selectedBattery, overBulb);
        } else {
          // drop
          this.selectedBattery.drag = false;
          this.selectedBattery = null;
          sound.tap();
        }
      }
    }

    tryAttach(battery, bulb) {
      if (!battery || !bulb) return;
      // If already attached to some bulb, detach first
      if (battery.attachedTo !== null) {
        const oldBulb = this.bulbs.find(b => b.id === battery.attachedTo);
        if (oldBulb) {
          oldBulb.attached = oldBulb.attached.filter(id => id !== battery.id);
        }
      }
      // attach
      battery.attachedTo = bulb.id;
      bulb.attached.push(battery.id);
      battery.visible = true;
      battery.drag = false;
      // Snap battery position near bulb
      const angle = (bulb.attached.length - 1) * 0.6 - 0.6;
      const dist = bulb.r + 30;
      battery.x = bulb.x + Math.cos(angle) * dist;
      battery.y = bulb.y + Math.sin(angle) * dist;
      sound.click();
      // Check correctness
      const sum = bulb.currentSum(this.batteries);
      if (sum === bulb.target) {
        // success: play sound, animate electrons
        sound.success();
        this.spawnElectrons(bulb);
        this.announce(`Bulb ${bulb.id + 1} lit! You matched ${bulb.target}.`);
      } else if (sum > bulb.target) {
        // too much
        sound.error();
        this.announce(`Too much! Bulb ${bulb.id + 1} needs ${bulb.target} but has ${sum}. Remove some batteries.`);
      } else {
        // partial
        sound.tap();
        this.announce(`Good. Bulb ${bulb.id + 1} now has ${sum} of ${bulb.target}.`);
      }

      // clear selected battery
      if (this.selectedBattery && this.selectedBattery.id === battery.id) {
        this.selectedBattery = null;
      }
    }

    spawnElectrons(bulb) {
      // Create animated electrons that flow from battery positions to bulb center
      const attachedBats = bulb.attached.map(id => this.batteries.find(b => b.id === id)).filter(Boolean);
      attachedBats.forEach((bat, i) => {
        for (let k = 0; k < Math.min(4, bat.val); k++) {
          this.electrons.push({
            x: bat.x,
            y: bat.y,
            tx: bulb.x,
            ty: bulb.y - 6,
            life: 0,
            speed: 0.02 + Math.random() * 0.02,
            color: `hsl(${50 + Math.random() * 30}, 90%, 60%)`
          });
        }
      });
    }

    update(dt) {
      this.time += dt;
      this.characters.forEach(c => c.update(dt));
      // update bulbs
      this.bulbs.forEach(b => b.update(dt, this.batteries));
      // update electrons
      this.electrons = this.electrons.filter(e => e.life < 1);
      this.electrons.forEach(e => {
        e.life = Math.min(1, e.life + e.speed);
        // ease
        const t = easeOutCubic(e.life);
        e.x = lerp(e.x, e.tx, t);
        e.y = lerp(e.y, e.ty, t);
      });

      // Check win: all bulbs lit
      if (this.bulbs.every(b => b.lit)) {
        // Celebrate: create more electrons across bulbs
        if (!this.celebrated) {
          this.celebrated = true;
          sound.success();
          this.announce('All bulbs lit! Great job! Press R to play again.');
          // little fireworks of electrons
          this.bulbs.forEach((bulb) => {
            for (let i = 0; i < 12; i++) {
              this.electrons.push({
                x: bulb.x + (Math.random() * 160 - 80),
                y: bulb.y + (Math.random() * 160 - 80),
                tx: bulb.x,
                ty: bulb.y - 6,
                life: 0,
                speed: 0.02 + Math.random() * 0.03,
                color: `hsl(${40 + Math.random() * 40}, 90%, 60%)`
              });
            }
          });
        }
      } else {
        this.celebrated = false;
      }
    }

    frame(now) {
      if (!this.running) return;
      const dt = Math.min(0.05, (now - this.last) / 1000);
      this.last = now;
      this.update(dt);
      this.render(now / 1000);
      requestAnimationFrame(this.frame);
    }

    render(time) {
      // background grid and wires
      const ctx = this.ctx;
      ctx.clearRect(0, 0, WIDTH, HEIGHT);

      // background gradient
      const bg = ctx.createLinearGradient(0, 0, 0, HEIGHT);
      bg.addColorStop(0, '#071022');
      bg.addColorStop(1, '#08162a');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // gentle circuit board pattern
      this.drawCircuitBoard(ctx, time);

      // draw characters
      this.characters.forEach(c => c.draw(ctx));

      // draw bulbs
      this.bulbs.forEach(b => b.draw(ctx, this.batteries, time));

      // draw wires from batteries to bulbs
      this.drawWires(ctx, time);

      // draw batteries
      this.batteries.forEach(b => b.draw(ctx));

      // draw electrons
      this.electrons.forEach(e => {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = e.color;
        ctx.beginPath();
        ctx.arc(e.x, e.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // UI overlay: instructions and buttons
      this.drawUI(ctx);

      // If audio unavailable show icon
      this.drawAudioIcon(ctx);

      // Tooltip or focus info
      if (this.mouseOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(12, HEIGHT - 66, 260, 48);
        ctx.fillStyle = '#fff';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'left';
        if (this.mouseOver.type === 'battery') {
          const b = this.batteries.find(bb => bb.id === this.mouseOver.id);
          ctx.fillText(`Battery ${b.val}. Drag to a bulb to add.`, 22, HEIGHT - 40);
        } else {
          const bl = this.bulbs.find(bb => bb.id === this.mouseOver.id);
          ctx.fillText(`Bulb needs ${bl.target}. Current ${bl.currentSum(this.batteries)}.`, 22, HEIGHT - 40);
        }
      }

      // Draw focus instruction
      ctx.fillStyle = '#fff';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Tab: change focus • Enter: pick/place • Arrows: move picked battery • R: reset • M: audio', 12, HEIGHT - 12);
    }

    drawCircuitBoard(ctx, time) {
      // soft glowing grid lines
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = '#49a6ff';
      ctx.lineWidth = 1;
      for (let x = 0; x < WIDTH; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x + Math.sin(time + x * 0.01) * 2, 0);
        ctx.lineTo(x + Math.sin(time + x * 0.01) * 2, HEIGHT);
        ctx.stroke();
      }
      for (let y = 0; y < HEIGHT; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y + Math.cos(time + y * 0.01) * 2);
        ctx.lineTo(WIDTH, y + Math.cos(time + y * 0.01) * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    drawWires(ctx, time) {
      ctx.save();
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      this.bulbs.forEach((bulb) => {
        bulb.attached.forEach((bid, i) => {
          const b = this.batteries.find(bb => bb.id === bid);
          if (!b) return;
          // color glows more if bulb lit
          const litAmt = bulb.glow;
          // compute bezier from battery to bulb
          const sx = b.x, sy = b.y;
          const tx = bulb.x, ty = bulb.y - 6;
          const mx = (sx + tx) / 2;
          ctx.beginPath();
          const cp1x = mx + (sy - ty) * 0.12;
          const cp1y = sy + (ty - sy) * 0.4;
          const cp2x = mx - (sy - ty) * 0.12;
          const cp2y = ty - (ty - sy) * 0.4;
          // glowing stroke
          const grad = ctx.createLinearGradient(sx, sy, tx, ty);
          grad.addColorStop(0, `rgba(255,200,90,${0.5})`);
          grad.addColorStop(1, `rgba(180,240,255,${0.6 + litAmt * 0.4})`);
          ctx.strokeStyle = grad;
          ctx.lineWidth = 6 + litAmt * 8;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tx, ty);
          ctx.stroke();

          // inner bright line
          ctx.strokeStyle = `rgba(255,255,210,${0.9})`;
          ctx.lineWidth = 2 + litAmt * 4;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tx, ty);
          ctx.stroke();
        });
      });
      ctx.restore();
    }

    drawUI(ctx) {
      // left top: title
      ctx.fillStyle = '#fff';
      ctx.font = '24px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Charge the Bulbs!', 12, 36);

      // subtitle
      ctx.fillStyle = '#bfe8ff';
      ctx.font = '14px sans-serif';
      ctx.fillText('Help Sparky and Volt by adding number batteries to make each bulb reach its target.', 12, 58);

      // Draw a Reset button (canvas-only)
      const bx = WIDTH - 120, by = 18, bw = 104, bh = 36;
      // button background
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      roundRect(ctx, bx, by, bw, bh, 8);
      ctx.fill();

      // button text
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('New Puzzle (R)', bx + bw / 2, by + 24);

      // handle click on reset using pointer coordinates: we detect everywhere in pointerdown, but also offer keyboard R

      // Draw audio toggle button
      const ax = WIDTH - 260, ay = 18, aw = 120, ah = 36;
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      roundRect(ctx, ax, ay, aw, ah, 8);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = '14px sans-serif';
      ctx.fillText(`Audio: ${this.audioOn ? 'On (M)' : 'Off (M)'}`, ax + aw / 2, ay + 24);
    }

    drawAudioIcon(ctx) {
      const x = WIDTH - 34, y = HEIGHT - 34;
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = this.audioOn ? '#ffd54f' : '#555';
      ctx.arc(x, y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = this.audioOn ? '#222' : '#222';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(this.audioOn ? '🔊' : '🔈', x, y + 4);
      // If audio unavailable show cross
      if (!sound.available) {
        ctx.fillStyle = '#ff8a80';
        ctx.font = '10px sans-serif';
        ctx.fillText('Audio Unavailable', WIDTH - 160, HEIGHT - 14);
      }
      ctx.restore();
    }

    announce(text) {
      if (text === this.announced) return;
      this.announced = text;
      live.textContent = text;
    }
  }

  // Helpers
  function lerp(a, b, t) { return a + (b - a) * t; }
  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

  // Start game
  const game = new Game(ctx);

  // Additional pointer handling for UI buttons: detect clicks on areas (Reset & Audio)
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    // Reset button area
    if (x >= WIDTH - 120 && x <= WIDTH - 16 && y >= 18 && y <= 54) {
      game.generatePuzzle();
      sound.tap();
      return;
    }
    // Audio toggle
    if (x >= WIDTH - 260 && x <= WIDTH - 140 && y >= 18 && y <= 54) {
      game.audioOn = !game.audioOn;
      sound.setEnabled(game.audioOn);
      game.announce(`Audio ${game.audioOn ? 'on' : 'off'}`);
      return;
    }
    // Speaker icon
    if (x >= WIDTH - 52 && x <= WIDTH - 16 && y >= HEIGHT - 52 && y <= HEIGHT - 16) {
      game.audioOn = !game.audioOn;
      sound.setEnabled(game.audioOn);
      game.announce(`Audio ${game.audioOn ? 'on' : 'off'}`);
      return;
    }
  });

  // Ensure audio resumes on first user interaction (polite)
  window.addEventListener('click', async function resumeAudioOnce() {
    await sound.resume();
    window.removeEventListener('click', resumeAudioOnce);
  });

  // Make sure canvas is focusable and initially focused for keyboard
  canvas.focus();

})();
---

