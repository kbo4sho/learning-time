{
  "generated_date": "2025-08-19",
  "generated_timestamp": "2025-08-19T00:22:03.584014",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9752,
  "game_filename": "2025-08-19.js",
  "game_size_bytes": 28220,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Electricity Math Game for ages 7-9\n// Renders into existing element with id \"game-of-the-day-stage\"\n// Game: \"Spark Squad: Power-Up Puzzle\"\n// Concept: addition to reach a target voltage by selecting battery cells\n// All graphics drawn via canvas, sounds generated by Web Audio API oscillators\n// Accessible: keyboard controls, offscreen instructions for screen readers, aria labels, visual audio indicator\n\n(function () {\n  // Configuration\n  const STAGE_ID = 'game-of-the-day-stage';\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const BATTERY_COUNT = 6;\n  const MIN_TARGET = 10;\n  const MAX_TARGET = 30;\n  const LEVEL_TIME = 45; // seconds per round optional (not enforced heavily)\n  const ELECTRON_COLOR = '#ffee66';\n\n  // Get container\n  const container = document.getElementById(STAGE_ID);\n  if (!container) {\n    console.error('Game container not found: #' + STAGE_ID);\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative'; // ensure we can position things inside\n\n  // Create offscreen text for screen readers (accessible instructions)\n  const srText = document.createElement('div');\n  srText.setAttribute('aria-hidden', 'false');\n  srText.style.position = 'absolute';\n  srText.style.left = '-9999px';\n  srText.style.top = 'auto';\n  srText.style.width = '1px';\n  srText.style.height = '1px';\n  srText.style.overflow = 'hidden';\n  srText.id = 'spark-squad-instructions';\n  srText.innerText =\n    'Spark Squad: Power-Up Puzzle. Use arrow keys to move between batteries. Press Space or Enter to select a battery to add to the circuit. Press Backspace or C to clear selection. Press M to toggle sound. Choose batteries to add up to the target number shown. When you hit the correct number, the bulb lights!';\n  container.appendChild(srText);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.style.display = 'block';\n  canvas.style.background = '#10202b'; // calm background\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Spark Squad electricity math game canvas');\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let audioAllowed = true;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    audioCtx = new AudioContext();\n  } catch (err) {\n    console.warn('Web Audio API not supported or failed to create context:', err);\n    audioAllowed = false;\n    audioCtx = null;\n  }\n\n  // Create master gain node if audio context exists\n  let masterGain = null;\n  if (audioCtx) {\n    try {\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.8;\n      masterGain.connect(audioCtx.destination);\n    } catch (err) {\n      console.warn('Failed to create gain node:', err);\n      audioAllowed = false;\n      masterGain = null;\n    }\n  }\n\n  // Helper to resume audio context on user gesture\n  async function ensureAudioRunning() {\n    if (!audioAllowed || !audioCtx) return false;\n    try {\n      if (audioCtx.state === 'suspended') {\n        await audioCtx.resume();\n      }\n      return true;\n    } catch (err) {\n      console.warn('Could not resume audio context:', err);\n      return false;\n    }\n  }\n\n  // Sound generators using Web Audio API\n  function playClick() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = 'square';\n      o.frequency.setValueAtTime(880, audioCtx.currentTime);\n      g.gain.setValueAtTime(0, audioCtx.currentTime);\n      g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);\n      o.connect(g);\n      g.connect(masterGain);\n      o.start();\n      o.stop(audioCtx.currentTime + 0.2);\n    } catch (err) {\n      console.warn('Error playing click sound:', err);\n    }\n  }\n\n  function playCorrect() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const freqs = [440, 660, 880];\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        const g = audioCtx.createGain();\n        o.type = 'sine';\n        o.frequency.setValueAtTime(f, now + i * 0.08);\n        g.gain.setValueAtTime(0, now + i * 0.08);\n        g.gain.linearRampToValueAtTime(0.12, now + i * 0.08 + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.28);\n        o.connect(g);\n        g.connect(masterGain);\n        o.start(now + i * 0.08);\n        o.stop(now + i * 0.08 + 0.3);\n      });\n    } catch (err) {\n      console.warn('Error playing correct sound:', err);\n    }\n  }\n\n  function playIncorrect() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const f = audioCtx.createBiquadFilter();\n      const g = audioCtx.createGain();\n      o.type = 'sawtooth';\n      o.frequency.setValueAtTime(220, audioCtx.currentTime);\n      f.type = 'lowpass';\n      f.frequency.setValueAtTime(600, audioCtx.currentTime);\n      g.gain.setValueAtTime(0.001, audioCtx.currentTime);\n      g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);\n      o.connect(f);\n      f.connect(g);\n      g.connect(masterGain);\n      o.start();\n      o.stop(audioCtx.currentTime + 0.5);\n    } catch (err) {\n      console.warn('Error playing incorrect sound:', err);\n    }\n  }\n\n  // Gentle background hum (subtle)\n  let humOsc = null;\n  function startBackgroundHum() {\n    if (!audioAllowed || !audioCtx || !masterGain) return;\n    try {\n      if (humOsc) return;\n      humOsc = audioCtx.createOscillator();\n      const humGain = audioCtx.createGain();\n      humOsc.type = 'sine';\n      humOsc.frequency.setValueAtTime(55, audioCtx.currentTime);\n      humGain.gain.value = 0.02;\n      humOsc.connect(humGain);\n      humGain.connect(masterGain);\n      humOsc.start();\n    } catch (err) {\n      console.warn('Could not start background hum:', err);\n    }\n  }\n\n  function stopBackgroundHum() {\n    if (!humOsc) return;\n    try {\n      humOsc.stop();\n    } catch (err) {\n      // ignore\n    }\n    humOsc = null;\n  }\n\n  // Game state\n  const state = {\n    level: 1,\n    target: randInt(MIN_TARGET, MAX_TARGET),\n    batteries: [],\n    selectedIndices: new Set(),\n    batteriesSelectedSum: 0,\n    selectedIndex: 0,\n    solved: false,\n    score: 0,\n    timeLeft: LEVEL_TIME,\n    showMessage: '',\n    messageTimer: 0,\n    soundOn: audioAllowed,\n    electrons: [], // animated moving particles along wires\n    lastTick: performance.now(),\n  };\n\n  // Initialize batteries for a new round\n  function resetRound() {\n    state.target = randInt(MIN_TARGET + state.level - 1, MAX_TARGET + state.level - 1);\n    state.batteries = [];\n    state.selectedIndices.clear();\n    state.batteriesSelectedSum = 0;\n    state.selectedIndex = 0;\n    state.solved = false;\n    state.timeLeft = LEVEL_TIME;\n    state.showMessage = '';\n    state.messageTimer = 0;\n    // generate battery values ensuring solution exists (simple method: generate some random then add one that ensures solvable)\n    // create some random small numbers and ensure some subset sums to target by constructing a subset\n    // We'll create a subset sum by selecting some random addends that sum to target (split target)\n    let remaining = state.target;\n    const parts = [];\n    // ensure between 2 and BATTERY_COUNT parts\n    const partCount = randInt(2, Math.min(BATTERY_COUNT, Math.max(2, Math.floor(state.target / 4))));\n    for (let i = 0; i < partCount - 1; i++) {\n      const maxPart = Math.max(1, Math.floor(remaining / (partCount - i)));\n      const val = randInt(1, Math.max(1, Math.min(maxPart, 9)));\n      parts.push(val);\n      remaining -= val;\n    }\n    parts.push(Math.max(1, remaining));\n    // If parts length < battery count, fill with random distractors\n    while (parts.length < BATTERY_COUNT) {\n      parts.push(randInt(1, 9));\n    }\n    // Shuffle and assign to batteries\n    shuffleArray(parts);\n    for (let i = 0; i < BATTERY_COUNT; i++) {\n      const value = parts[i] || randInt(1, 9);\n      state.batteries.push({\n        value,\n        x: 80 + i * ((WIDTH - 160) / (BATTERY_COUNT - 1)),\n        y: HEIGHT - 80,\n        width: 64,\n        height: 32,\n        wobble: Math.random() * 1000,\n      });\n    }\n    // create some electrons initially empty\n    state.electrons = [];\n  }\n\n  // Utility functions\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function shuffleArray(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n\n  // Input handling\n  let pointer = { x: 0, y: 0, down: false };\n\n  canvas.addEventListener('mousemove', (e) => {\n    const r = canvas.getBoundingClientRect();\n    pointer.x = ((e.clientX - r.left) * (canvas.width / r.width)) || 0;\n    pointer.y = ((e.clientY - r.top) * (canvas.height / r.height)) || 0;\n  });\n\n  canvas.addEventListener('mousedown', (e) => {\n    pointer.down = true;\n    handleUserGesture();\n    handleClick(pointer.x, pointer.y);\n  });\n\n  window.addEventListener('mouseup', () => {\n    pointer.down = false;\n  });\n\n  canvas.addEventListener('touchstart', (e) => {\n    handleUserGesture();\n    e.preventDefault();\n    if (e.touches[0]) {\n      const t = e.touches[0];\n      const r = canvas.getBoundingClientRect();\n      pointer.x = ((t.clientX - r.left) * (canvas.width / r.width)) || 0;\n      pointer.y = ((t.clientY - r.top) * (canvas.height / r.height)) || 0;\n      handleClick(pointer.x, pointer.y);\n    }\n  }, { passive: false });\n\n  canvas.addEventListener('touchmove', (e) => {\n    e.preventDefault();\n    if (e.touches[0]) {\n      const t = e.touches[0];\n      const r = canvas.getBoundingClientRect();\n      pointer.x = ((t.clientX - r.left) * (canvas.width / r.width)) || 0;\n      pointer.y = ((t.clientY - r.top) * (canvas.height / r.height)) || 0;\n    }\n  }, { passive: false });\n\n  // Keyboard controls\n  window.addEventListener('keydown', (e) => {\n    // allow arrow keys, space/enter, backspace/C, M for sound toggle\n    if (e.key === 'ArrowLeft') {\n      state.selectedIndex = (state.selectedIndex - 1 + state.batteries.length) % state.batteries.length;\n      e.preventDefault();\n      handleUserGesture();\n    } else if (e.key === 'ArrowRight') {\n      state.selectedIndex = (state.selectedIndex + 1) % state.batteries.length;\n      e.preventDefault();\n      handleUserGesture();\n    } else if (e.key === ' ' || e.key === 'Enter') {\n      e.preventDefault();\n      toggleBatterySelection(state.selectedIndex);\n      handleUserGesture();\n    } else if (e.key === 'Backspace' || e.key.toLowerCase() === 'c') {\n      e.preventDefault();\n      clearSelection();\n      handleUserGesture();\n    } else if (e.key.toLowerCase() === 'm') {\n      e.preventDefault();\n      toggleSound();\n      handleUserGesture();\n    }\n  });\n\n  function handleClick(x, y) {\n    // check if clicked on a battery\n    for (let i = 0; i < state.batteries.length; i++) {\n      const b = state.batteries[i];\n      if (x >= b.x - b.width / 2 && x <= b.x + b.width / 2 && y >= b.y - b.height / 2 && y <= b.y + b.height / 2) {\n        state.selectedIndex = i;\n        toggleBatterySelection(i);\n        return;\n      }\n    }\n    // click on speaker icon to toggle sound\n    if (x >= WIDTH - 48 && x <= WIDTH - 16 && y >= 16 && y <= 48) {\n      toggleSound();\n    }\n  }\n\n  function toggleBatterySelection(index) {\n    if (state.solved) return;\n    if (state.selectedIndices.has(index)) {\n      state.selectedIndices.delete(index);\n      state.batteriesSelectedSum -= state.batteries[index].value;\n      state.showMessage = 'Removed ' + state.batteries[index].value;\n      state.messageTimer = 120;\n    } else {\n      state.selectedIndices.add(index);\n      state.batteriesSelectedSum += state.batteries[index].value;\n      state.showMessage = 'Added ' + state.batteries[index].value;\n      state.messageTimer = 120;\n      // spawn electrons moving from battery to bulb\n      spawnElectronsForBattery(index);\n      playClick();\n    }\n    checkSolution();\n  }\n\n  function clearSelection() {\n    if (state.solved) return;\n    state.selectedIndices.clear();\n    state.batteriesSelectedSum = 0;\n    state.showMessage = 'Cleared';\n    state.messageTimer = 120;\n    playClick();\n  }\n\n  function toggleSound() {\n    state.soundOn = !state.soundOn;\n    if (state.soundOn) {\n      // try to resume audio context\n      ensureAudioRunning();\n      startBackgroundHum();\n    } else {\n      stopBackgroundHum();\n    }\n    state.showMessage = state.soundOn ? 'Sound On' : 'Sound Off';\n    state.messageTimer = 90;\n  }\n\n  // Check whether current selected sum matches target\n  function checkSolution() {\n    if (state.batteriesSelectedSum === state.target) {\n      // success\n      state.solved = true;\n      state.score += 1;\n      state.showMessage = 'Perfect! Bulb lit!';\n      state.messageTimer = 180;\n      spawnVictoryElectrons();\n      if (state.soundOn) playCorrect();\n      // schedule next round after a delay\n      setTimeout(() => {\n        state.level += 1;\n        resetRound();\n      }, 1500);\n    } else if (state.batteriesSelectedSum > state.target) {\n      // over target\n      state.showMessage = 'Too high!';\n      state.messageTimer = 90;\n      if (state.soundOn) playIncorrect();\n      // small shake or twinkle handled in draw\n    } else {\n      // still below\n      state.showMessage = 'Sum ' + state.batteriesSelectedSum;\n      state.messageTimer = 60;\n    }\n  }\n\n  // Electrons: moving particles along wire from battery to bulb\n  function spawnElectronsForBattery(index) {\n    const b = state.batteries[index];\n    for (let i = 0; i < 6; i++) {\n      state.electrons.push({\n        fromX: b.x,\n        fromY: b.y - 18,\n        toX: WIDTH / 2,\n        toY: HEIGHT / 2 - 40,\n        t: Math.random(), // position along path [0..1]\n        speed: 0.008 + Math.random() * 0.008,\n        size: 3 + Math.random() * 3,\n        hue: 50 + Math.random() * 40,\n      });\n    }\n  }\n\n  function spawnVictoryElectrons() {\n    for (let i = 0; i < 60; i++) {\n      state.electrons.push({\n        fromX: WIDTH / 2,\n        fromY: HEIGHT / 2 - 40,\n        toX: WIDTH / 2 + (Math.random() - 0.5) * 300,\n        toY: HEIGHT / 2 - 40 + (Math.random() - 0.5) * 200,\n        t: Math.random(),\n        speed: 0.004 + Math.random() * 0.02,\n        size: 2 + Math.random() * 4,\n        hue: 40 + Math.random() * 200,\n      });\n    }\n  }\n\n  // Main loop\n  let rafId = null;\n  function startGameLoop() {\n    state.lastTick = performance.now();\n    if (state.soundOn) startBackgroundHum();\n    function tick(now) {\n      const dt = Math.min(100, now - state.lastTick);\n      update(dt / 1000);\n      draw();\n      state.lastTick = now;\n      rafId = requestAnimationFrame(tick);\n    }\n    rafId = requestAnimationFrame(tick);\n  }\n\n  function stopGameLoop() {\n    if (rafId) cancelAnimationFrame(rafId);\n  }\n\n  // Update game state\n  function update(dt) {\n    // update electrons\n    for (let i = state.electrons.length - 1; i >= 0; i--) {\n      const e = state.electrons[i];\n      e.t += e.speed * dt * 60;\n      if (e.t > 1.1) {\n        state.electrons.splice(i, 1);\n      }\n    }\n    // message timer\n    if (state.messageTimer > 0) state.messageTimer--;\n  }\n\n  // Drawing helpers\n  function drawRoundedRect(x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function draw() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Background gradient and wacky elements\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#08202a');\n    g.addColorStop(1, '#0f3040');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft glowing grid to suggest circuit board\n    drawCircuitBackground();\n\n    // Top HUD: title, target, lamp\n    drawHUD();\n\n    // Draw \"circuit board\" center: bulb + wires\n    drawBulbAndWires();\n\n    // Draw batteries bottom\n    drawBatteries();\n\n    // Draw floating electrons\n    drawElectrons();\n\n    // Draw characters - Amp robot and Blinky bulb sidekick\n    drawCharacters();\n\n    // Draw message box\n    drawMessage();\n\n    // Draw instructions at bottom area\n    drawInstructions();\n\n    // Draw sound indicator\n    drawSoundIcon();\n  }\n\n  // Background: calm circuit-like patterns\n  function drawCircuitBackground() {\n    ctx.save();\n    ctx.globalAlpha = 0.18;\n    ctx.strokeStyle = '#0ef';\n    ctx.lineWidth = 1;\n    for (let i = 0; i < 12; i++) {\n      ctx.beginPath();\n      const y = 40 + (i * 32) + Math.sin((performance.now() / 700) + i) * 6;\n      ctx.moveTo(20, y);\n      ctx.bezierCurveTo(200, y + (i % 3) * 6, 520, y - (i % 4) * 8, WIDTH - 20, y + (i % 2) * 4);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    // Title\n    ctx.save();\n    ctx.fillStyle = '#fff';\n    ctx.font = 'bold 20px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Spark Squad: Power-Up Puzzle', 18, 28);\n\n    // Level and score\n    ctx.font = '14px sans-serif';\n    ctx.fillStyle = '#bfe';\n    ctx.fillText('Level: ' + state.level + '   Score: ' + state.score, 18, 48);\n\n    // Target display with wacky meter\n    ctx.textAlign = 'center';\n    ctx.fillStyle = '#fff';\n    ctx.font = '28px \"Segoe UI\", Roboto, sans-serif';\n    ctx.fillText('Target Voltage', WIDTH / 2, 40);\n    // meter box\n    const boxW = 220;\n    ctx.fillStyle = '#0b3a3e';\n    drawRoundedRect(WIDTH / 2 - boxW / 2, 48, boxW, 46, 10);\n    ctx.fillStyle = '#0ff';\n    ctx.font = 'bold 36px sans-serif';\n    ctx.fillText(state.target + ' V', WIDTH / 2, 82);\n    ctx.restore();\n  }\n\n  function drawBulbAndWires() {\n    const cx = WIDTH / 2;\n    const cy = HEIGHT / 2 - 40;\n\n    // wires from each battery to bulb center\n    for (let i = 0; i < state.batteries.length; i++) {\n      const b = state.batteries[i];\n      ctx.beginPath();\n      const startX = b.x;\n      const startY = b.y - 18;\n      const cp1x = startX;\n      const cp1y = startY - 60 - (i - state.batteries.length / 2) * 6;\n      const cp2x = cx - 40 + (i - state.batteries.length / 2) * 8;\n      const cp2y = cy + 10;\n      ctx.moveTo(startX, startY);\n      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, cx, cy);\n      // style depending on whether selected\n      if (state.selectedIndices.has(i)) {\n        const grad = ctx.createLinearGradient(startX, startY, cx, cy);\n        grad.addColorStop(0, '#ffd966');\n        grad.addColorStop(1, '#ff9900');\n        ctx.strokeStyle = grad;\n        ctx.lineWidth = 6;\n        ctx.shadowBlur = 14;\n        ctx.shadowColor = '#ffd966';\n      } else {\n        ctx.strokeStyle = '#204a4f';\n        ctx.lineWidth = 3;\n        ctx.shadowBlur = 0;\n      }\n      ctx.stroke();\n      ctx.shadowBlur = 0;\n    }\n\n    // Bulb base and glass\n    ctx.save();\n    // base\n    ctx.fillStyle = '#333';\n    ctx.fillRect(cx - 22, cy + 26, 44, 18);\n    ctx.fillStyle = '#232';\n    ctx.fillRect(cx - 18, cy + 28, 36, 14);\n\n    // glass\n    const lit = state.solved;\n    const g = ctx.createRadialGradient(cx, cy - 10, 6, cx, cy - 10, 80);\n    if (lit) {\n      g.addColorStop(0, '#ffffaa');\n      g.addColorStop(0.5, '#ffdd66');\n      g.addColorStop(1, 'rgba(255,200,100,0.06)');\n    } else {\n      g.addColorStop(0, '#dfefff');\n      g.addColorStop(1, 'rgba(255,255,255,0.02)');\n    }\n    ctx.fillStyle = g;\n    ctx.beginPath();\n    ctx.ellipse(cx, cy - 18, 48, 60, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = 'rgba(0,0,0,0.1)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    ctx.restore();\n\n    // filament or sparkle\n    ctx.save();\n    if (lit) {\n      // filament glowing crown\n      for (let i = 0; i < 10; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = `rgba(255,220,120,${0.08 + Math.random() * 0.12})`;\n        ctx.lineWidth = 1.2;\n        ctx.moveTo(cx - 20 + Math.random() * 40, cy - 40 + Math.random() * 12);\n        ctx.lineTo(cx + (Math.random() - 0.5) * 30, cy - 10 + Math.random() * 15);\n        ctx.stroke();\n      }\n    } else {\n      // filament shape\n      ctx.beginPath();\n      ctx.strokeStyle = '#553300';\n      ctx.lineWidth = 2.5;\n      ctx.moveTo(cx - 12, cy - 6);\n      ctx.quadraticCurveTo(cx, cy - 28, cx + 12, cy - 6);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // label near bulb showing current sum\n    ctx.save();\n    ctx.fillStyle = '#fff';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Current Sum: ' + state.batteriesSelectedSum + ' V', cx, cy + 80);\n    ctx.restore();\n  }\n\n  function drawBatteries() {\n    for (let i = 0; i < state.batteries.length; i++) {\n      const b = state.batteries[i];\n      const x = b.x;\n      const y = b.y;\n      const w = b.width;\n      const h = b.height;\n\n      // wobble for life\n      const wob = Math.sin((performance.now() + b.wobble) / 300) * 3;\n\n      ctx.save();\n      ctx.translate(x, y + wob);\n\n      // battery body\n      ctx.fillStyle = '#112';\n      ctx.fillRect(-w / 2, -h / 2, w, h);\n      // positive cap\n      ctx.fillStyle = '#ffd966';\n      ctx.fillRect(w / 2 - 6, -h / 4, 6, h / 2);\n      // decorative stripes\n      ctx.fillStyle = '#223';\n      ctx.fillRect(-w / 2 + 6, -h / 2 + 4, w - 12, h - 8);\n      // value panel\n      ctx.fillStyle = state.selectedIndices.has(i) ? '#ffdd66' : '#9ee';\n      drawRoundedRect(-w / 2 + 8, -h / 2 + 6, w - 16, h - 12, 4);\n\n      // battery value text\n      ctx.fillStyle = '#033';\n      ctx.font = '16px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(b.value + 'V', 0, 0);\n\n      // highlight selected rectangle\n      if (state.selectedIndex === i) {\n        ctx.strokeStyle = '#fff';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(-w / 2 - 6, -h / 2 - 6, w + 12, h + 12);\n      }\n\n      ctx.restore();\n    }\n  }\n\n  function drawElectrons() {\n    for (const e of state.electrons) {\n      const t = Math.min(1, e.t);\n      // simple linear interpolation with slight curve\n      const cx1 = e.fromX;\n      const cy1 = e.fromY;\n      const cx2 = (e.fromX + e.toX) / 2;\n      const cy2 = Math.min(e.fromY, e.toY) - 80;\n      const cx3 = e.toX;\n      const cy3 = e.toY;\n\n      // quadratic bezier interpolation\n      const x = (1 - t) * (1 - t) * cx1 + 2 * (1 - t) * t * cx2 + t * t * cx3;\n      const y = (1 - t) * (1 - t) * cy1 + 2 * (1 - t) * t * cy2 + t * t * cy3;\n\n      ctx.beginPath();\n      ctx.fillStyle = `hsl(${e.hue}, 95%, 60%)`;\n      ctx.shadowBlur = 8;\n      ctx.shadowColor = `hsl(${e.hue}, 100%, 60%)`;\n      ctx.arc(x, y, e.size, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.shadowBlur = 0;\n    }\n  }\n\n  function drawCharacters() {\n    // Amp the cute robot near left\n    const ax = 70;\n    const ay = HEIGHT / 2 + 30;\n    drawAmp(ax, ay);\n\n    // Blinky the bulb sidekick near right\n    const bx = WIDTH - 120;\n    const by = HEIGHT / 2 - 20;\n    drawBlinky(bx, by);\n  }\n\n  function drawAmp(x, y) {\n    ctx.save();\n    ctx.translate(x, y);\n    // body\n    ctx.fillStyle = '#cde';\n    ctx.fillRect(-28, -36, 56, 68);\n    ctx.fillStyle = '#89a';\n    ctx.fillRect(-34, -44, 68, 12); // headband\n    // face\n    ctx.fillStyle = '#113';\n    ctx.fillRect(-16, -26, 32, 20);\n    ctx.fillStyle = '#fff';\n    ctx.font = '12px monospace';\n    ctx.textAlign = 'center';\n    ctx.fillText('Amp', 0, -14);\n    // eyes as LEDs\n    ctx.beginPath();\n    ctx.fillStyle = '#ffd966';\n    ctx.arc(-8, -6, 4, 0, Math.PI * 2);\n    ctx.arc(8, -6, 4, 0, Math.PI * 2);\n    ctx.fill();\n    // antenna\n    ctx.strokeStyle = '#ffd966';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(18, -44);\n    ctx.lineTo(26, -60);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(26, -62, 4, 0, Math.PI * 2);\n    ctx.fill();\n    // arms\n    ctx.fillStyle = '#bcd';\n    ctx.fillRect(-56, -6, 20, 8);\n    ctx.fillRect(36, -6, 20, 8);\n    ctx.restore();\n  }\n\n  function drawBlinky(x, y) {\n    ctx.save();\n    ctx.translate(x, y);\n    // bulb body\n    const lit = state.solved;\n    const rad = ctx.createRadialGradient(0, -18, 6, 0, -18, 48);\n    rad.addColorStop(0, lit ? '#fff9aa' : '#fff');\n    rad.addColorStop(0.6, lit ? '#ffd966' : '#dfefff');\n    rad.addColorStop(1, 'rgba(255,255,255,0.03)');\n    ctx.fillStyle = rad;\n    ctx.beginPath();\n    ctx.ellipse(0, -18, 34, 46, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // face\n    ctx.fillStyle = '#133';\n    ctx.font = 'bold 12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Blinky', 0, -8);\n    // cheeks\n    ctx.beginPath();\n    ctx.fillStyle = lit ? '#ffcc88' : '#ffd';\n    ctx.arc(-10, -16, 3, 0, Math.PI * 2);\n    ctx.arc(10, -16, 3, 0, Math.PI * 2);\n    ctx.fill();\n    // little sparks around when lit\n    if (lit) {\n      for (let i = 0; i < 6; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = `rgba(255,230,170,${0.2 + Math.random() * 0.6})`;\n        ctx.lineWidth = 1.2;\n        const rx = (Math.random() - 0.5) * 80;\n        const ry = -18 + (Math.random() - 0.5) * 40;\n        ctx.moveTo(rx, ry);\n        ctx.lineTo(rx + (Math.random() - 0.5) * 12, ry + (Math.random() - 0.5) * 12);\n        ctx.stroke();\n      }\n    }\n    ctx.restore();\n  }\n\n  function drawMessage() {\n    if (!state.showMessage) return;\n    ctx.save();\n    ctx.textAlign = 'center';\n    ctx.font = '18px sans-serif';\n    ctx.fillStyle = '#fff';\n    ctx.globalAlpha = Math.min(1, state.messageTimer / 120);\n    ctx.fillText(state.showMessage, WIDTH / 2, HEIGHT - 18);\n    ctx.globalAlpha = 1;\n    ctx.restore();\n  }\n\n  function drawInstructions() {\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Controls: \u2190 \u2192 to move, Space/Enter to pick, Backspace or C to clear, M to toggle sound', 16, HEIGHT - 6);\n    ctx.restore();\n  }\n\n  function drawSoundIcon() {\n    ctx.save();\n    ctx.translate(WIDTH - 36, 24);\n    // speaker shape\n    ctx.beginPath();\n    ctx.fillStyle = state.soundOn ? '#ffd966' : '#556';\n    ctx.moveTo(-12, -8);\n    ctx.lineTo(-2, -8);\n    ctx.lineTo(6, -16);\n    ctx.lineTo(6, 16);\n    ctx.lineTo(-2, 8);\n    ctx.lineTo(-12, 8);\n    ctx.closePath();\n    ctx.fill();\n\n    // waves or muted cross\n    if (state.soundOn) {\n      ctx.strokeStyle = '#ffd966';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(8, 0, 8, -0.6, 0.6);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(10, 0, 12, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(-2, -6);\n      ctx.lineTo(12, 10);\n      ctx.moveTo(12, -6);\n      ctx.lineTo(-2, 10);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // User gesture to enable audio safely\n  function handleUserGesture() {\n    if (audioCtx && audioCtx.state === 'suspended') {\n      ensureAudioRunning().then((ok) => {\n        if (ok && state.soundOn) startBackgroundHum();\n      });\n    } else if (state.soundOn && audioCtx) {\n      startBackgroundHum();\n    }\n  }\n\n  // Initialize first round and start game\n  resetRound();\n  startGameLoop();\n\n  // Start audio if allowed and requested\n  if (audioAllowed && state.soundOn) {\n    ensureAudioRunning().then((ok) => {\n      if (ok) startBackgroundHum();\n    });\n  }\n\n  // Expose some debug on container\n  container.addEventListener('keydown', (e) => {\n    // container focus friendly\n  });\n\n  // Clean up when unloading\n  window.addEventListener('unload', () => {\n    stopGameLoop();\n    if (humOsc) {\n      try { humOsc.stop(); } catch (e) {}\n    }\n    if (audioCtx) {\n      try { audioCtx.close(); } catch (e) {}\n    }\n  });\n\n  // Prevent errors from unhandled promise rejections from audio resume\n  window.addEventListener('unhandledrejection', (evt) => {\n    console.warn('Unhandled promise rejection:', evt.reason);\n  });\n})();\n---\n",
  "improve_response_tokens": 20223,
  "formatted_code": true,
  "formatting_response_tokens": 22377,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}