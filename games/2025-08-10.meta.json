{
  "generated_date": "2025-08-10",
  "generated_timestamp": "2025-08-10T00:25:14.443378",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9417,
  "game_filename": "2025-08-10.js",
  "game_size_bytes": 26201,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Electricity Math Game for ages 7-9\n  // Renders inside element with ID 'game-of-the-day-stage'\n  // All graphics drawn on canvas. Sound via Web Audio API (oscillators).\n  // Keyboard controls and accessible live text included.\n\n  // === Setup DOM and Canvas ===\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container element with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  container.style.position = 'relative';\n  container.style.width = '720px';\n  container.style.height = '480px';\n  container.setAttribute('role', 'application');\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.outline = 'none';\n  canvas.setAttribute('tabindex', '0'); // make focusable for keyboard\n  canvas.setAttribute('aria-label', 'Spark City math game. Use arrow keys to move the spark. Press M to mute. Press Enter or Space to start or interact.');\n  container.appendChild(canvas);\n\n  // Accessible live region (visually hidden) for screen readers\n  const live = document.createElement('div');\n  live.setAttribute('aria-live', 'polite');\n  live.style.position = 'absolute';\n  live.style.left = '0';\n  live.style.top = '0';\n  live.style.width = '1px';\n  live.style.height = '1px';\n  live.style.overflow = 'hidden';\n  live.style.clip = 'rect(1px, 1px, 1px, 1px)';\n  live.style.whiteSpace = 'nowrap';\n  live.style.clipPath = 'inset(50%)';\n  container.appendChild(live);\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error('2D canvas context not available.');\n    return;\n  }\n\n  // === Audio Setup with error handling ===\n  let audioCtx = null;\n  let masterGain = null;\n  let ambientOsc = null;\n  let audioEnabled = true;\n  let audioAllowed = false;\n\n  function initAudio() {\n    if (audioCtx) return;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AudioContext();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.6;\n      masterGain.connect(audioCtx.destination);\n\n      // ambient hum (gentle)\n      ambientOsc = audioCtx.createOscillator();\n      const ambientGain = audioCtx.createGain();\n      ambientOsc.frequency.value = 110; // low hum\n      ambientOsc.type = 'sine';\n      ambientGain.gain.value = 0.02;\n      ambientOsc.connect(ambientGain);\n      ambientGain.connect(masterGain);\n      ambientOsc.start();\n\n      audioAllowed = true;\n    } catch (e) {\n      console.warn('AudioContext creation failed or blocked by browser:', e);\n      audioAllowed = false;\n      audioCtx = null;\n    }\n  }\n\n  function resumeAudioOnGesture() {\n    // Some browsers require resume on user gesture\n    if (!audioCtx) initAudio();\n    if (audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('Failed to resume audio context:', e);\n      });\n    }\n  }\n\n  function playTone({freq = 440, duration = 0.2, type = 'sine', gain = 0.1, detune = 0}) {\n    if (!audioAllowed || !audioCtx || !audioEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      o.detune.value = detune;\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.linearRampToValueAtTime(gain, now + 0.01);\n      g.gain.linearRampToValueAtTime(0.0001, now + duration);\n      o.start(now);\n      o.stop(now + duration + 0.05);\n    } catch (e) {\n      console.warn('playTone error:', e);\n    }\n  }\n\n  function playPluck(value) {\n    // pluck with pitch related to value\n    const base = 220 + (value * 40);\n    playTone({freq: base, duration: 0.18, type: 'triangle', gain: 0.12});\n    // small second harmonic\n    setTimeout(() => playTone({freq: base * 1.5, duration: 0.12, type: 'sine', gain: 0.06}), 60);\n  }\n\n  function playSuccessMelody() {\n    if (!audioAllowed || !audioEnabled) return;\n    playTone({freq: 660, duration: 0.18, type: 'sine', gain: 0.14});\n    setTimeout(() => playTone({freq: 880, duration: 0.16, type: 'sine', gain: 0.12}), 160);\n    setTimeout(() => playTone({freq: 990, duration: 0.22, type: 'sine', gain: 0.12}), 320);\n  }\n\n  function playBuzzer() {\n    if (!audioAllowed || !audioEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const f = audioCtx.createBiquadFilter();\n      const g = audioCtx.createGain();\n      o.type = 'sawtooth';\n      o.frequency.value = 120;\n      f.type = 'lowpass';\n      f.frequency.value = 800;\n      g.gain.value = 0.0001;\n      o.connect(f);\n      f.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.linearRampToValueAtTime(0.16, now + 0.01);\n      g.gain.linearRampToValueAtTime(0.0001, now + 0.36);\n      o.start(now);\n      o.stop(now + 0.38);\n    } catch (e) {\n      console.warn('playBuzzer error:', e);\n    }\n  }\n\n  // === Game Variables ===\n  const W = canvas.width;\n  const H = canvas.height;\n\n  let state = 'start'; // start, playing, success, gameover\n  let level = 1;\n  let score = 0;\n  let lives = 3;\n\n  // Player spark\n  const player = {\n    x: 90,\n    y: H / 2,\n    r: 16,\n    vx: 0,\n    vy: 0,\n    speed: 140, // pixels per second\n    collected: [], // numbers collected (values)\n    color: '#FFD166'\n  };\n\n  // Bulbs (targets)\n  let bulbs = [];\n\n  // Number orbs scattered\n  let orbs = [];\n\n  // Time\n  let lastTs = null;\n  let running = true;\n\n  // Input\n  const keys = {};\n\n  // Visual style palette\n  const palette = {\n    bg: '#E8F6FF',\n    panel: '#CFF6EA',\n    wire: '#7D8AFA',\n    sparkGlow: '#FFEDB6',\n    text: '#05386B',\n    soft: '#F6F7FD',\n    accent: '#FF7B7B'\n  };\n\n  // Characters descriptions for narrative and memory\n  const characters = {\n    wattson: {\n      name: 'Wattson',\n      role: 'Lightning Squirrel',\n      desc: 'A zippy squirrel who loves counting charges!'\n    },\n    ampy: {\n      name: 'Ampy',\n      role: 'Friendly Bulb',\n      desc: 'A gentle bulb who lights up when you give the right charge.'\n    },\n    gearhead: {\n      name: 'Gearhead',\n      role: 'Helper Robot',\n      desc: 'Keeps the city circuits tidy and gives hints.'\n    }\n  };\n\n  // Accessibility status to be read by screen readers\n  function announce(text) {\n    live.textContent = text;\n  }\n\n  // === Utility Functions ===\n  function rand(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  function randInt(min, max) {\n    return Math.floor(rand(min, max + 1));\n  }\n\n  function distance(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // === Game Logic ===\n  function newLevel(lv = 1) {\n    level = lv;\n    player.x = 90;\n    player.y = H / 2;\n    player.collected = [];\n    score = score;\n    lives = Math.max(1, lives);\n    // Generate bulbs based on level\n    bulbs = [];\n    const bulbCount = Math.min(4, 2 + Math.floor(level / 2));\n    const rightX = W - 120;\n    const spacing = H / (bulbCount + 1);\n    for (let i = 0; i < bulbCount; i++) {\n      // Targets between 3 and 18 scaled by level difficulty\n      const minTarget = 3;\n      const maxTarget = Math.min(20, 6 + level * 2);\n      const target = randInt(minTarget, maxTarget);\n      bulbs.push({\n        x: rightX,\n        y: spacing * (i + 1),\n        r: 36,\n        target: target,\n        lit: false,\n        tries: 0\n      });\n    }\n\n    // Generate orbs (numbers) scattered around the left and middle area\n    const orbCount = Math.max(6, 6 + level);\n    orbs = [];\n    for (let i = 0; i < orbCount; i++) {\n      const val = randInt(1, Math.min(9, 3 + Math.floor(level)));\n      const px = rand(160, W - 240);\n      const py = rand(60, H - 60);\n      orbs.push({\n        x: px,\n        y: py,\n        r: 14,\n        value: val,\n        collected: false,\n        floatPhase: rand(0, Math.PI * 2)\n      });\n    }\n\n    announce(`Level ${level} started. Bulbs need: ${bulbs.map(b => b.target).join(', ')}. Use arrow keys to move the spark and add numbers to match the bulbs.`);\n  }\n\n  // Player collects orb\n  function collectOrb(orb) {\n    orb.collected = true;\n    player.collected.push(orb.value);\n    playPluck(orb.value);\n    announce(`You collected ${orb.value}. Current charge is ${player.collected.reduce((a, b) => a + b, 0)}.`);\n  }\n\n  // Attempt to deliver to bulb\n  function deliverToBulb(bulb) {\n    const current = player.collected.reduce((a, b) => a + b, 0);\n    bulb.tries++;\n    if (current === bulb.target) {\n      bulb.lit = true;\n      score += Math.max(10, bulb.target * 2);\n      playSuccessMelody();\n      announce(`${characters.ampy.name} lit up! You matched ${current}. Score ${score}.`);\n      // Clear player's collected\n      player.collected = [];\n      // Remove any orbs that were placed (they are already collected)\n      // Check level complete\n      if (bulbs.every(b => b.lit)) {\n        state = 'levelComplete';\n        announce(`Level complete! Score ${score}. Press Enter to go to next level.`);\n      }\n    } else {\n      // Wrong attempt\n      playBuzzer();\n      lives -= 1;\n      announce(`Oh no! ${characters.gearhead.name} says try again. Delivered ${current} but needed ${bulb.target}. Lives left ${lives}.`);\n      // penalty: drop one collected orb back into play near player\n      if (player.collected.length > 0) {\n        const droppedValue = player.collected.pop();\n        orbs.push({\n          x: player.x + rand(-40, 40),\n          y: player.y + rand(-20, 20),\n          r: 14,\n          value: droppedValue,\n          collected: false,\n          floatPhase: 0\n        });\n        playPluck(droppedValue);\n      }\n      if (lives <= 0) {\n        state = 'gameover';\n        announce('Game over. Press Enter to restart.');\n      }\n    }\n  }\n\n  // === Input Handling ===\n  window.addEventListener('keydown', (e) => {\n    // Prevent page from scrolling on arrow keys\n    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {\n      e.preventDefault();\n    }\n    keys[e.key] = true;\n\n    // Start/resume audio on any key press\n    resumeAudioOnGesture();\n\n    if (state === 'start' && (e.key === 'Enter' || e.key === ' ')) {\n      state = 'playing';\n      newLevel(1);\n      lastTs = performance.now();\n      announce('Game started. Move the spark to collect numbers and match the bulbs.');\n    } else if ((state === 'levelComplete' || state === 'gameover' || state === 'success') && (e.key === 'Enter' || e.key === ' ')) {\n      if (state === 'levelComplete') {\n        newLevel(level + 1);\n        state = 'playing';\n        lastTs = performance.now();\n      } else {\n        // restart\n        level = 1;\n        score = 0;\n        lives = 3;\n        newLevel(1);\n        state = 'playing';\n        lastTs = performance.now();\n      }\n    } else if (e.key.toLowerCase() === 'm') {\n      audioEnabled = !audioEnabled;\n      announce(audioEnabled ? 'Audio enabled.' : 'Audio muted.');\n    }\n  }, {passive: false});\n\n  window.addEventListener('keyup', (e) => {\n    keys[e.key] = false;\n  });\n\n  canvas.addEventListener('click', (e) => {\n    // focus canvas for keyboard\n    canvas.focus();\n    resumeAudioOnGesture();\n    if (state === 'start') {\n      state = 'playing';\n      newLevel(1);\n      lastTs = performance.now();\n      announce('Game started. Move the spark to collect numbers and match the bulbs.');\n    } else if (state === 'levelComplete') {\n      newLevel(level + 1);\n      state = 'playing';\n      lastTs = performance.now();\n    } else if (state === 'gameover') {\n      level = 1;\n      score = 0;\n      lives = 3;\n      newLevel(1);\n      state = 'playing';\n      lastTs = performance.now();\n    }\n  });\n\n  // Touch support for mobile: simple directional swipe handling\n  let touchStart = null;\n  canvas.addEventListener('touchstart', (e) => {\n    resumeAudioOnGesture();\n    touchStart = e.touches[0];\n  }, {passive: true});\n  canvas.addEventListener('touchend', (e) => {\n    touchStart = null;\n  });\n  canvas.addEventListener('touchmove', (e) => {\n    if (!touchStart) return;\n    const t = e.touches[0];\n    const dx = t.clientX - touchStart.clientX;\n    const dy = t.clientY - touchStart.clientY;\n    // map to keys temporarily\n    keys['ArrowRight'] = dx > 10;\n    keys['ArrowLeft'] = dx < -10;\n    keys['ArrowDown'] = dy > 10;\n    keys['ArrowUp'] = dy < -10;\n  }, {passive: true});\n\n  // === Drawing Helpers ===\n  function drawRoundedRect(x, y, w, h, r, fillStyle, strokeStyle) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n  }\n\n  function drawSpark(p) {\n    const glow = ctx.createRadialGradient(p.x, p.y, 2, p.x, p.y, p.r + 20);\n    glow.addColorStop(0, 'rgba(255,255,200,0.9)');\n    glow.addColorStop(0.5, 'rgba(255,210,100,0.25)');\n    glow.addColorStop(1, 'rgba(255,210,100,0.02)');\n    ctx.fillStyle = glow;\n    ctx.beginPath();\n    ctx.arc(p.x, p.y, p.r + 22, 0, Math.PI * 2);\n    ctx.fill();\n\n    // main body\n    ctx.beginPath();\n    ctx.fillStyle = p.color;\n    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = '#FFA500';\n    ctx.stroke();\n\n    // cute eyes (Wattson's style)\n    ctx.fillStyle = '#2E2E2E';\n    ctx.beginPath();\n    ctx.ellipse(p.x - 6, p.y - 4, 2.6, 3.6, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(p.x + 6, p.y - 4, 2.6, 3.6, 0, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawOrb(orb) {\n    // gentle float motion\n    const fp = 6 * Math.sin(performance.now() / 600 + orb.floatPhase);\n    ctx.beginPath();\n    const grad = ctx.createLinearGradient(orb.x - orb.r, orb.y - orb.r + fp, orb.x + orb.r, orb.y + orb.r + fp);\n    grad.addColorStop(0, '#FFF9C4');\n    grad.addColorStop(1, '#FFE082');\n    ctx.fillStyle = grad;\n    ctx.arc(orb.x, orb.y + fp, orb.r, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#E0A800';\n    ctx.lineWidth = 1.5;\n    ctx.stroke();\n\n    // number text\n    ctx.fillStyle = '#2E2E2E';\n    ctx.font = 'bold 16px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(orb.value.toString(), orb.x, orb.y + fp);\n  }\n\n  function drawBulb(b) {\n    // base wire connector\n    ctx.save();\n    // wire\n    ctx.strokeStyle = palette.wire;\n    ctx.lineWidth = 6;\n    ctx.beginPath();\n    ctx.moveTo(b.x - 80, b.y);\n    ctx.quadraticCurveTo(b.x - 40, b.y - 30, b.x - 20, b.y - 10);\n    ctx.stroke();\n\n    // Bulb glass\n    const glow = ctx.createRadialGradient(b.x, b.y - 8, 4, b.x, b.y - 8, b.r + 18);\n    if (b.lit) {\n      glow.addColorStop(0, 'rgba(255,255,180,0.95)');\n      glow.addColorStop(0.6, 'rgba(255,230,120,0.5)');\n      glow.addColorStop(1, 'rgba(255,230,120,0.04)');\n    } else {\n      glow.addColorStop(0, 'rgba(220,235,255,0.9)');\n      glow.addColorStop(1, 'rgba(200,220,255,0.02)');\n    }\n    ctx.fillStyle = glow;\n    ctx.beginPath();\n    ctx.ellipse(b.x, b.y - 8, b.r, b.r + 10, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // socket\n    ctx.fillStyle = '#9AA5D1';\n    ctx.fillRect(b.x - 12, b.y + b.r - 6, 24, 12);\n    ctx.strokeStyle = '#6C7390';\n    ctx.strokeRect(b.x - 12, b.y + b.r - 6, 24, 12);\n\n    // target number\n    ctx.fillStyle = '#153243';\n    ctx.font = 'bold 18px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(b.target.toString(), b.x, b.y - 8);\n\n    // small halo text if lit\n    if (b.lit) {\n      ctx.fillStyle = 'rgba(255,220,120,0.9)';\n      ctx.font = '12px sans-serif';\n      ctx.fillText('Lit!', b.x, b.y + b.r + 18);\n    } else {\n      ctx.fillStyle = '#153243';\n      ctx.font = '12px sans-serif';\n      ctx.fillText(`Tries: ${b.tries}`, b.x, b.y + b.r + 18);\n    }\n    ctx.restore();\n  }\n\n  function drawCharacters() {\n    // Wattson the Lightning Squirrel (left bottom)\n    const wx = 48, wy = H - 60;\n    // tail\n    ctx.beginPath();\n    ctx.fillStyle = '#F7C59F';\n    ctx.ellipse(wx - 24, wy - 4, 24, 12, -0.6, 0, Math.PI * 2);\n    ctx.fill();\n    // body\n    ctx.beginPath();\n    ctx.fillStyle = '#FFD7A6';\n    ctx.arc(wx, wy, 18, 0, Math.PI * 2);\n    ctx.fill();\n    // face\n    ctx.fillStyle = '#2E2E2E';\n    ctx.beginPath();\n    ctx.ellipse(wx - 4, wy - 4, 3, 4, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(wx + 6, wy - 4, 3, 4, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // text\n    ctx.fillStyle = '#2E2E2E';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(`${characters.wattson.name} the ${characters.wattson.role}`, wx + 36, wy - 6);\n\n    // Ampy the bulb (top-left)\n    const ax = 80, ay = 60;\n    ctx.save();\n    // bulb glow\n    const g = ctx.createRadialGradient(ax, ay, 2, ax, ay, 40);\n    g.addColorStop(0, 'rgba(255,255,200,0.9)');\n    g.addColorStop(1, 'rgba(255,230,160,0.02)');\n    ctx.fillStyle = g;\n    ctx.beginPath();\n    ctx.arc(ax, ay, 28, 0, Math.PI * 2);\n    ctx.fill();\n    // filament\n    ctx.fillStyle = '#222';\n    ctx.fillRect(ax - 6, ay + 6, 12, 8);\n    ctx.fillStyle = '#2E2E2E';\n    ctx.font = '12px sans-serif';\n    ctx.fillText(`${characters.ampy.name}`, ax + 44, ay - 4);\n    ctx.restore();\n\n    // Gearhead robot (bottom-right)\n    const rx = W - 48, ry = H - 60;\n    ctx.fillStyle = '#C7D3FF';\n    ctx.fillRect(rx - 18, ry - 22, 36, 36);\n    ctx.fillStyle = '#2E2E2E';\n    ctx.fillRect(rx - 10, ry - 10, 6, 6);\n    ctx.fillRect(rx + 4, ry - 10, 6, 6);\n    ctx.fillStyle = '#2E2E2E';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'right';\n    ctx.fillText(`${characters.gearhead.name}`, rx - 42, ry + 10);\n  }\n\n  // === Game Update & Render ===\n  function update(dt) {\n    if (state !== 'playing') return;\n\n    // Input movement\n    let dirX = 0, dirY = 0;\n    if (keys['ArrowLeft'] || keys['a'] || keys['A']) dirX -= 1;\n    if (keys['ArrowRight'] || keys['d'] || keys['D']) dirX += 1;\n    if (keys['ArrowUp'] || keys['w'] || keys['W']) dirY -= 1;\n    if (keys['ArrowDown'] || keys['s'] || keys['S']) dirY += 1;\n\n    // Normalize\n    if (dirX !== 0 || dirY !== 0) {\n      const len = Math.sqrt(dirX * dirX + dirY * dirY) || 1;\n      dirX /= len;\n      dirY /= len;\n    }\n\n    player.vx = dirX * player.speed;\n    player.vy = dirY * player.speed;\n\n    player.x += player.vx * dt;\n    player.y += player.vy * dt;\n\n    // Keep inside play area (avoid bulbs area on right)\n    player.x = clamp(player.x, 40, W - 140);\n    player.y = clamp(player.y, 40, H - 40);\n\n    // Check orb collisions\n    orbs.forEach((orb) => {\n      if (orb.collected) return;\n      const dx = player.x - orb.x;\n      const dy = player.y - orb.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < player.r + orb.r - 2) {\n        collectOrb(orb);\n      }\n    });\n\n    // Check bulb collisions (delivery on touch)\n    bulbs.forEach((b) => {\n      const dx = player.x - b.x;\n      const dy = player.y - (b.y - 8); // align with bulb center\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < player.r + b.r - 6 && !b.lit) {\n        // deliver\n        deliverToBulb(b);\n      }\n    });\n\n    // float phases for orbs\n    orbs.forEach(o => o.floatPhase += dt * 2);\n\n    // Remove collected orbs from array over time (visual)\n    orbs = orbs.filter(o => !o.collected || o.collected === false);\n  }\n\n  function render() {\n    // background\n    ctx.clearRect(0, 0, W, H);\n    // gradient background\n    const bg = ctx.createLinearGradient(0, 0, 0, H);\n    bg.addColorStop(0, palette.bg);\n    bg.addColorStop(1, '#F6FCFF');\n    ctx.fillStyle = bg;\n    ctx.fillRect(0, 0, W, H);\n\n    // Soft panel for play area\n    drawRoundedRect(16, 16, W - 32, H - 32, 12, palette.panel, '#DDEBFF');\n\n    // Title and instructions area (top)\n    ctx.fillStyle = palette.text;\n    ctx.font = 'bold 20px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Spark City \u2014 Help Wattson deliver exact energy!', 24, 40);\n    ctx.font = '12px sans-serif';\n    ctx.fillStyle = '#345';\n    ctx.fillText('Collect number charges and bring the exact total to each bulb to light it.', 24, 60);\n\n    // Draw characters\n    drawCharacters();\n\n    // draw bulbs\n    bulbs.forEach(drawBulb);\n\n    // draw orbs\n    orbs.forEach((orb) => {\n      if (!orb.collected) drawOrb(orb);\n    });\n\n    // draw wires and fun elements (wacky shapes)\n    // zigzag resistor area\n    ctx.strokeStyle = '#C390FF';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    const startX = 140;\n    const startY = H - 40;\n    ctx.moveTo(startX, startY);\n    for (let i = 0; i < 8; i++) {\n      const x = startX + i * 22;\n      const y = startY + (i % 2 === 0 ? -12 : 12);\n      ctx.lineTo(x, y);\n    }\n    ctx.stroke();\n\n    // render collected small badges near player to show current charge values\n    const badX = player.x + 28, badY = player.y - 10;\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillStyle = '#123';\n    ctx.fillText('Charge:', player.x - 26, player.y + 40);\n    let offset = 0;\n    player.collected.forEach((v, idx) => {\n      ctx.fillStyle = '#FFF1B6';\n      ctx.beginPath();\n      ctx.arc(player.x + offset - 12, player.y + 40, 12, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = '#EAB308';\n      ctx.stroke();\n      ctx.fillStyle = '#2E2E2E';\n      ctx.font = 'bold 12px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(String(v), player.x + offset - 12, player.y + 40);\n      offset += 28;\n    });\n\n    // draw player spark\n    drawSpark(player);\n\n    // HUD: level, score, lives\n    ctx.fillStyle = '#123';\n    ctx.font = 'bold 14px sans-serif';\n    ctx.textAlign = 'right';\n    ctx.fillText(`Level ${level}`, W - 24, 36);\n    ctx.fillText(`Score ${score}`, W - 24, 56);\n    ctx.fillText(`Lives ${lives}`, W - 24, 76);\n\n    // audio visual cue\n    ctx.save();\n    ctx.translate(W - 48, 96);\n    ctx.fillStyle = audioEnabled && audioAllowed ? '#FFD4A3' : '#CCC';\n    ctx.beginPath();\n    ctx.arc(0, 0, 12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#222';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(audioEnabled ? '\ud83d\udd0a' : '\ud83d\udd08', 0, 0);\n    ctx.restore();\n\n    // bottom instructions and controls\n    ctx.fillStyle = '#0B2545';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Controls: Arrow keys or WASD to move. Touch drag on mobile. Press M to mute/unmute. Collect numbers and touch a bulb to deliver.', 24, H - 18);\n\n    // contextual overlays\n    if (state === 'start') {\n      ctx.fillStyle = 'rgba(8, 20, 40, 0.6)';\n      ctx.fillRect(80, 100, W - 160, 240);\n      ctx.fillStyle = '#FFF';\n      ctx.font = 'bold 28px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Spark City', W / 2, 160);\n      ctx.font = '16px sans-serif';\n      ctx.fillText('Wattson needs help delivering exact charges to the bulbs!', W / 2, 200);\n      ctx.font = '14px sans-serif';\n      ctx.fillText('Collect numbers (1\u20139) and bring the exact total to light each bulb.', W / 2, 232);\n      ctx.fillStyle = '#FFD166';\n      drawRoundedRect(W / 2 - 74, 260, 148, 42, 10, '#FFD166', '#F0A500');\n      ctx.fillStyle = '#123';\n      ctx.font = 'bold 16px sans-serif';\n      ctx.fillText('Start Game', W / 2, 286);\n    } else if (state === 'levelComplete') {\n      ctx.fillStyle = 'rgba(10, 80, 60, 0.65)';\n      ctx.fillRect(120, 120, W - 240, H - 240);\n      ctx.fillStyle = '#E6FFFA';\n      ctx.font = 'bold 22px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Great job! Level complete!', W / 2, H / 2 - 12);\n      ctx.font = '16px sans-serif';\n      ctx.fillText('Press Enter to continue to the next exciting circuit!', W / 2, H / 2 + 18);\n    } else if (state === 'gameover') {\n      ctx.fillStyle = 'rgba(80, 10, 10, 0.6)';\n      ctx.fillRect(120, 120, W - 240, H - 240);\n      ctx.fillStyle = '#FFF2F2';\n      ctx.font = 'bold 24px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Oh no \u2014 the city is out of spark!', W / 2, H / 2 - 8);\n      ctx.font = '16px sans-serif';\n      ctx.fillText('Press Enter to try again.', W / 2, H / 2 + 20);\n    }\n\n    // small helpful hint area for screen readers\n    // (also visuals)\n    ctx.fillStyle = '#0B2545';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Bulb targets: ${bulbs.map(b => b.target).join(', ')}`, 24, 92);\n  }\n\n  // === Main Loop ===\n  function loop(ts) {\n    if (!lastTs) lastTs = ts;\n    const dt = Math.min(0.06, (ts - lastTs) / 1000);\n    lastTs = ts;\n\n    try {\n      update(dt);\n      render();\n    } catch (e) {\n      console.error('Error during game update/render:', e);\n      announce('An error occurred. Please reload the page to try again.');\n      running = false;\n    }\n\n    if (running) requestAnimationFrame(loop);\n  }\n\n  // === Initialization ===\n  function start() {\n    // Initialize audio if possible but don't block main UI\n    try {\n      initAudio();\n    } catch (e) {\n      console.warn('Audio init failed:', e);\n    }\n\n    // initial screen\n    render();\n    announce('Welcome to Spark City! Press Enter or click to start. Use arrow keys to move. Press M to mute or unmute audio.');\n    // start loop\n    lastTs = null;\n    requestAnimationFrame(loop);\n  }\n\n  // Start after a short delay so container style settle\n  setTimeout(start, 250);\n\n  // Expose minimal debug in window (non-intrusive)\n  window.sparkCity = {\n    restart: () => {\n      level = 1; score = 0; lives = 3; state = 'start';\n      player.collected = [];\n      orbs = [];\n      bulbs = [];\n      lastTs = null;\n      announce('Game reset. Press Enter to start.');\n    },\n    mute: (v) => {\n      audioEnabled = !v ? false : true;\n    }\n  };\n\n  // Ensure errors in audio are handled gracefully\n  window.addEventListener('unhandledrejection', (ev) => {\n    console.warn('Unhandled promise rejection:', ev.reason);\n  });\n})();\n---\n",
  "improve_response_tokens": 20195,
  "formatted_code": true,
  "formatting_response_tokens": 22867,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}