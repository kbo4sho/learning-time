# Game of the Day - 2025-08-05

## Metadata
- **Generated Date:** 2025-08-05
- **Generated Time:** 2025-08-05T17:27:40.487296
- **Model:** gpt-4.1-mini
- **Theme:** open world exploration
- **Game File:** 2025-08-05.js
- **File Size:** 15926 bytes
- **Tokens Used:** 4934

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: open world exploration

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-4.1-mini model with the theme: "open world exploration".

## Files Generated
- `2025-08-05.js` - The playable game
- `2025-08-05.meta.json` - Machine-readable metadata
- `2025-08-05.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 11755

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 13969

### Final Functionality Score After Improvement
- **Score:** 7/8 (87.5%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- ⚠️  No game state management found

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
const gameContainer = document.getElementById('game-of-the-day-stage');
gameContainer.innerHTML = '';
gameContainer.style.width = '720px';
gameContainer.style.height = '480px';
gameContainer.style.position = 'relative';

const canvas = document.createElement('canvas');
canvas.width = 720;
canvas.height = 480;
canvas.setAttribute('role', 'img');
canvas.setAttribute('aria-label', 'Math adventure game with a friendly explorer collecting shapes in an open world');
gameContainer.appendChild(canvas);
const ctx = canvas.getContext('2d');

// Game state and config
const gameWidth = canvas.width;
const gameHeight = canvas.height;

const explorer = {
  x: gameWidth/2,
  y: gameHeight/2,
  radius: 20,
  color: '#3a8baf',
  speed: 4
};

const shapes = ['circle', 'square', 'triangle'];
const shapeColors = ['#f08a5d', '#b83b5e', '#6a2c70'];
const shapeSize = 30;

let collectibleShapes = [];

// Target math concept: Counting and addition
// Narrative: Explorer finds wacky shapes in a calm island world and needs to collect correct amount of shapes to build a "math treasure".
// Each shape has a hidden value (1, 2, 3), player collects shapes and answers quizzes about total values.

// Friendly characters tied to theme:
const characters = {
  explorer: {
    name: 'Ellie the Explorer',
    description: 'A curious adventurer who loves discovering math treasures.'
  },
  guide: {
    name: 'Wobbly the Wise Wombat',
    description: 'Your funny, wacky guide who helps with questions and clues.'
  }
};

// Audio context setup with error handling
let audioCtx;
try {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
} catch (e) {
  audioCtx = null;
  console.warn('Web Audio API not supported or failed to initialize.');
}

// Sounds helpers
function playTone(freq, duration = 200, type = 'sine') {
  if (!audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration/1000);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration/1000);
  } catch (e) {
    // fail silently on audio errors
  }
}

function playCorrectSound() {
  playTone(600, 300, 'triangle');
}

function playWrongSound() {
  playTone(200, 300, 'square');
}

function playBackgroundTone() {
  if (!audioCtx) return null;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(120, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    return {osc, gain};
  } catch {
    return null;
  }
}

// Visual calming background with gentle animation
let bgWaves = [
  {y: 430, amplitude: 10, frequency: 0.015, phase: 0},
  {y: 450, amplitude: 12, frequency: 0.02, phase: 1},
  {y: 470, amplitude: 8, frequency: 0.017, phase: 0.5}
];

// Keyboard state tracking for accessibility
const keysPressed = {};

// Player collected shapes and counting
let collected = [];
let question = null; // {text: string, correctAnswer: number}
let showQuestion = false;
let message = '';
let messageTimeout = null;

// Accessible text instructions
const instructions = `Use arrow keys or WASD to move Ellie the Explorer.
Collect colorful shapes by moving over them.
After you collect shapes, answer the quiz by typing the number and pressing Enter.
Press H for help anytime.`;

// UI font
const font = '20px Comic Sans MS, cursive, sans-serif';

function drawBackground(time) {
  ctx.fillStyle = '#c6f3f1';
  ctx.fillRect(0, 0, gameWidth, gameHeight);

  // Draw gentle ocean waves - wavy arcs
  bgWaves.forEach((wave, idx) => {
    ctx.beginPath();
    ctx.strokeStyle = `rgba(60, 120, 150, 0.25)`;
    ctx.lineWidth = 2;
    for (let x = 0; x <= gameWidth; x += 10) {
      const y = wave.y + wave.amplitude * Math.sin(wave.frequency * x + wave.phase + time*0.002);
      if (x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  });
}

// Draw Ellie the Explorer - round character with wacky hat and backpack, simple shapes
function drawExplorer(x, y) {
  // Body circle
  ctx.fillStyle = explorer.color;
  ctx.beginPath();
  ctx.arc(x, y, explorer.radius, 0, Math.PI * 2);
  ctx.fill();

  // Eyes (white ovals)
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.ellipse(x - 7, y - 5, 6, 9, 0, 0, Math.PI * 2);
  ctx.ellipse(x + 7, y - 5, 6, 9, 0, 0, Math.PI * 2);
  ctx.fill();

  // Pupils
  ctx.fillStyle = '#30475e';
  ctx.beginPath();
  ctx.arc(x - 7, y - 2, 3, 0, Math.PI * 2);
  ctx.arc(x + 7, y - 2, 3, 0, Math.PI * 2);
  ctx.fill();

  // Wacky explorer hat (green crooked triangle)
  ctx.fillStyle = '#3d9b35';
  ctx.beginPath();
  ctx.moveTo(x - 20, y - 25);
  ctx.lineTo(x + 20, y - 25);
  ctx.lineTo(x, y - 50);
  ctx.closePath();
  ctx.fill();

  // Backpack (orange oval)
  ctx.fillStyle = '#f28c28';
  ctx.beginPath();
  ctx.ellipse(x, y + 15, 18, 26, 0, 0, Math.PI * 2);
  ctx.fill();

  // Smile
  ctx.strokeStyle = '#30475e';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y + 5, 10, 0, Math.PI, false);
  ctx.stroke();
}

// Draw shapes scattered on map
function drawShape(shape) {
  ctx.save();
  ctx.translate(shape.x, shape.y);

  // Draw shape's color
  ctx.fillStyle = shape.color;
  ctx.strokeStyle = '#2b2d42';
  ctx.lineWidth = 3;

  switch (shape.type) {
    case 'circle':
      ctx.beginPath();
      ctx.arc(0, 0, shapeSize/2, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      break;
    case 'square':
      ctx.beginPath();
      ctx.rect(-shapeSize/2, -shapeSize/2, shapeSize, shapeSize);
      ctx.fill();
      ctx.stroke();
      break;
    case 'triangle':
      ctx.beginPath();
      ctx.moveTo(0, -shapeSize/2);
      ctx.lineTo(shapeSize/2, shapeSize/2);
      ctx.lineTo(-shapeSize/2, shapeSize/2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      break;
  }
  // Draw value number inside shape, cartoonish text
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 18px Comic Sans MS';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(shape.value, 0, 2);

  ctx.restore();
}

// Wobbly the Wise Wombat - corner guide with speech bubble
function drawGuide(text) {
  const baseX = 640;
  const baseY = 80;

  // Body (brown oval)
  ctx.fillStyle = '#8d6e63';
  ctx.beginPath();
  ctx.ellipse(baseX, baseY + 40, 30, 40, 0, 0, Math.PI * 2);
  ctx.fill();

  // Head (lighter brown circle)
  ctx.fillStyle = '#a1887f';
  ctx.beginPath();
  ctx.arc(baseX, baseY, 25, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.ellipse(baseX - 8, baseY - 5, 6, 9, 0, 0, Math.PI * 2);
  ctx.ellipse(baseX + 8, baseY - 5, 6, 9, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#4e342e';
  ctx.beginPath();
  ctx.arc(baseX - 8, baseY - 2, 3, 0, Math.PI * 2);
  ctx.arc(baseX + 8, baseY - 2, 3, 0, Math.PI * 2);
  ctx.fill();

  // Mouth (smile)
  ctx.strokeStyle = '#4e342e';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(baseX, baseY + 10, 12, 0, Math.PI, false);
  ctx.stroke();

  // Speech bubble
  ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
  ctx.strokeStyle = '#4e342e';
  ctx.lineWidth = 2;
  const bubbleX = baseX - 210;
  const bubbleY = baseY - 70;
  const bubbleWidth = 200;
  const bubbleHeight = 70;
  const radius = 15;

  ctx.beginPath();
  ctx.moveTo(bubbleX + radius, bubbleY);
  ctx.lineTo(bubbleX + bubbleWidth - radius, bubbleY);
  ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + radius);
  ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - radius);
  ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - radius, bubbleY + bubbleHeight);
  ctx.lineTo(bubbleX + 70, bubbleY + bubbleHeight);
  ctx.lineTo(bubbleX + 60, bubbleY + bubbleHeight + 15);
  ctx.lineTo(bubbleX + 60, bubbleY + bubbleHeight);
  ctx.lineTo(bubbleX + radius, bubbleY + bubbleHeight);
  ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - radius);
  ctx.lineTo(bubbleX, bubbleY + radius);
  ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + radius, bubbleY);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Text inside bubble
  ctx.fillStyle = '#222222';
  ctx.font = '16px Comic Sans MS';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  wrapText(ctx, text, bubbleX + 15, bubbleY + 15, bubbleWidth - 30, 20);
}

// Utility for multiline text in speech bubble
function wrapText(context, text, x, y, maxWidth, lineHeight) {
  const words = text.split(' ');
  let line = '';
  let testLine;
  let metrics;
  let testWidth;
  for (let n = 0; n < words.length; n++) {
    testLine = line + words[n] + ' ';
    metrics = context.measureText(testLine);
    testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0) {
      context.fillText(line, x, y);
      line = words[n] + ' ';
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  context.fillText(line, x, y);
}

// Spawn shapes randomly, values meaning: circle=1, square=2, triangle=3
function spawnShapes() {
  collectibleShapes = [];
  for (let i = 0; i < 7; i++) {
    const typeIndex = Math.floor(Math.random() * shapes.length);
    const type = shapes[typeIndex];
    let value;
    switch(type) {
      case 'circle': value = 1; break;
      case 'square': value = 2; break;
      case 'triangle': value = 3; break;
    }
    const x = Math.random() * (gameWidth - 2*shapeSize) + shapeSize;
    const y = Math.random() * (gameHeight - 2*shapeSize - 80) + 80; // leave space for guide
    collectibleShapes.push({x, y, type, color: shapeColors[typeIndex], value, collected: false});
  }
}

// Movement controls and collection detection
function update() {
  // Move explorer based on keys pressed
  if (keysPressed.ArrowUp || keysPressed.KeyW) {
    explorer.y -= explorer.speed;
    if (explorer.y - explorer.radius < 0) explorer.y = explorer.radius;
  }
  if (keysPressed.ArrowDown || keysPressed.KeyS) {
    explorer.y += explorer.speed;
    if (explorer.y + explorer.radius > gameHeight) explorer.y = gameHeight - explorer.radius;
  }
  if (keysPressed.ArrowLeft || keysPressed.KeyA) {
    explorer.x -= explorer.speed;
    if (explorer.x - explorer.radius < 0) explorer.x = explorer.radius;
  }
  if (keysPressed.ArrowRight || keysPressed.KeyD) {
    explorer.x += explorer.speed;
    if (explorer.x + explorer.radius > gameWidth) explorer.x = gameWidth - explorer.radius;
  }

  // Check collection
  collectibleShapes.forEach(shape => {
    if (!shape.collected) {
      const dx = explorer.x - shape.x;
      const dy = explorer.y - shape.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < explorer.radius + shapeSize/2 - 5) {
        shape.collected = true;
        collected.push(shape.value);
        playCorrectSound();
      }
    }
  });

  // When enough shapes collected, show question
  if (!showQuestion && collected.length >= 3) {
    createQuestion();
    showQuestion = true;
    message = 'Type the answer and press Enter';
  }
}

// Create a math question about sum of collected shapes
function createQuestion() {
  const sum = collected.reduce((acc, v) => acc + v, 0);
  question = {
    text: `Ellie collected shapes worth these numbers: ${collected.join(', ')}. What is the total?`,
    correctAnswer: sum
  };
}

// Drawing the collected shapes in HUD bar
function drawCollectedShapes() {
  ctx.fillStyle = '#333333cc';
  ctx.fillRect(0, 0, gameWidth, 60);
  ctx.fillStyle = '#ffffff';
  ctx.font = '18px Comic Sans MS';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('Collected shapes:', 12, 6);

  collected.forEach((val, i) => {
    const x = 150 + i * 40;
    const y = 30;
    ctx.fillStyle = '#d1e7dd';
    ctx.strokeStyle = '#0f5132';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#0f5132';
    ctx.font = 'bold 16px Comic Sans MS';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(val, x, y);
  });
}

// Draw input box and current answer being typed
let userInput = '';

function drawInputBox() {
  if (!showQuestion) return;
  const boxX = 100;
  const boxY = 420;
  const boxW = 520;
  const boxH = 50;

  ctx.fillStyle = '#ffffffdd';
  ctx.strokeStyle = '#30475e';
  ctx.lineWidth = 3;
  ctx.fillRect(boxX, boxY, boxW, boxH);
  ctx.strokeRect(boxX, boxY, boxW, boxH);

  ctx.fillStyle = '#30475e';
  ctx.font = '24px Comic Sans MS';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText('Your answer: ' + userInput, boxX + 15, boxY + boxH / 2);

  // Accessibility text alternative
  canvas.setAttribute('aria-live', 'polite');
  // No direct text input aria support on canvas; guided by on-screen text and instructions
}

// Draw messages center screen
function drawMessage() {
  if (!message) return;
  ctx.fillStyle = 'rgba(255 255 255 / 0.85)';
  ctx.strokeStyle = '#30475e';
  ctx.lineWidth = 4;
  const w = 400;
  const h = 90;
  const x = (gameWidth - w) / 2;
  const y = gameHeight / 2 - h / 2;
  ctx.fillRect(x, y, w, h);
  ctx.strokeRect(x, y, w, h);

  ctx.fillStyle = '#30475e';
  ctx.font = '22px Comic Sans MS';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(message, x + w/2, y + h/2);
}

// Animation loop
let startTime = null;
let bgTone = playBackgroundTone();

function gameLoop(timestamp) {
  if (!startTime) startTime = timestamp;
  const elapsed = timestamp - startTime;

  update();
  drawBackground(elapsed);

  drawCollectedShapes();
  collectibleShapes.forEach(shape => {
    if (!shape.collected) drawShape(shape);
  });

  drawExplorer(explorer.x, explorer.y);
  if (showQuestion) {
    drawInputBox();
    drawMessage();
  }

  drawGuide(showQuestion ? question.text : `Hello, I'm Wobbly! Find shapes and collect their numbers. Then answer the math puzzle!`);

  requestAnimationFrame(gameLoop);
}

// Keyboard events for controls
window.addEventListener('keydown', e => {
  if (e.repeat) return;
  const k = e.code;
  keysPressed[k] = true;

  // If question visible, handle input keys
  if (showQuestion) {
    if (k === 'Enter') {
      // Check answer validity (only digits)
      if (/^\d+$/.test(userInput)) {
        const userAnswer = parseInt(userInput);
        if (userAnswer === question.correctAnswer) {
          message = 'Correct! Well done!';
          playCorrectSound();
          resetGameAfterDelay();
        } else {
          message = 'Oops, try again!';
          playWrongSound();
        }
      } else {
        message = 'Please enter a number!';
        playWrongSound();
      }
      userInput = '';
      e.preventDefault();
    } else if (k === 'Backspace') {
      e.preventDefault();
      userInput = userInput.slice(0, -1);
    } else if (/Digit[0-9]/.test(k) || /^[0-9]$/.test(e.key)) {
      if (userInput.length < 3) {
        userInput += e.key;
      }
      e.preventDefault();
    }
  } else {
    // Show instructions on H
    if (k === 'KeyH') {
      message = instructions;
      if (messageTimeout) clearTimeout(messageTimeout);
      messageTimeout = setTimeout(() => message = '', 10000);
    }
  }
});

window.addEventListener('keyup', e => {
  keysPressed[e.code] = false;
});

function resetGameAfterDelay() {
  setTimeout(() => {
    collected = [];
    userInput = '';
    showQuestion = false;
    message = '';
    spawnShapes();
  }, 4000);
}

// Init game
spawnShapes();
message = instructions;
messageTimeout = setTimeout(() => message = '', 10000);
requestAnimationFrame(gameLoop);
---

