# Game of the Day - 2025-08-26

## Metadata
- **Generated Date:** 2025-08-26
- **Generated Time:** 2025-08-26T00:21:20.287716
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-26.js
- **File Size:** 21836 bytes
- **Tokens Used:** 7672

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-26.js` - The playable game
- `2025-08-26.meta.json` - Machine-readable metadata
- `2025-08-26.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 15960

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 17621

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Game of the Day: Electricity Math Adventure
// Renders inside element with id "game-of-the-day-stage"
// Canvas 720x480, Web Audio API sounds, keyboard accessibility, canvas-only graphics

(() => {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const MAX_BUBBLES = 6;
  const TARGET_MIN = 6;
  const TARGET_MAX = 15;
  const FONT_FAMILY = "16px sans-serif";

  // Get container element
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Cannot find element with id 'game-of-the-day-stage'.");
    return;
  }
  // Make container focusable and set ARIA attributes for accessibility
  container.setAttribute("tabindex", "0");
  container.setAttribute("role", "application");
  container.setAttribute(
    "aria-label",
    "Electric Sparks math game. Use keyboard or mouse to select number bubbles and sum to the target voltage."
  );
  container.style.position = "relative";
  container.style.outline = "none";

  // Create a visually-hidden status div for screen readers
  const statusDiv = document.createElement("div");
  statusDiv.setAttribute("role", "status");
  statusDiv.setAttribute("aria-live", "polite");
  statusDiv.style.position = "absolute";
  statusDiv.style.left = "-9999px";
  statusDiv.style.width = "1px";
  statusDiv.style.height = "1px";
  statusDiv.style.overflow = "hidden";
  container.appendChild(statusDiv);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = "block";
  canvas.style.background = "#F6FBFF";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Audio setup with error handling
  let audioCtx = null;
  let audioEnabled = true;
  let bgHum = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
  } catch (e) {
    console.warn("Web Audio API not available or blocked:", e);
    audioEnabled = false;
    audioCtx = null;
  }

  // Audio utilities
  function safeCreateGain() {
    if (!audioEnabled || !audioCtx) return null;
    try {
      return audioCtx.createGain();
    } catch (e) {
      console.warn("Error creating gain:", e);
      audioEnabled = false;
      return null;
    }
  }

  function playTone({ freq = 440, type = "sine", duration = 0.2, gain = 0.08, detune = 0 }) {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      o.type = type;
      o.frequency.value = freq;
      o.detune.value = detune;
      const g = safeCreateGain();
      if (!g) return;
      g.gain.setValueAtTime(gain, audioCtx.currentTime);
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
      o.stop(audioCtx.currentTime + duration + 0.02);
    } catch (e) {
      console.warn("Error playing tone:", e);
      audioEnabled = false;
    }
  }

  function playCorrect() {
    // Pleasant arpeggio
    playTone({ freq: 660, type: "sine", duration: 0.12, gain: 0.06 });
    setTimeout(() => playTone({ freq: 880, type: "sine", duration: 0.16, gain: 0.06 }), 110);
    setTimeout(() => playTone({ freq: 990, type: "sine", duration: 0.18, gain: 0.06 }), 240);
  }

  function playWrong() {
    // Short buzzer using square and frequency drop
    playTone({ freq: 300, type: "square", duration: 0.12, gain: 0.12 });
    setTimeout(() => playTone({ freq: 180, type: "square", duration: 0.12, gain: 0.09 }), 80);
  }

  function startBackgroundHum() {
    if (!audioEnabled || !audioCtx) return;
    stopBackgroundHum();
    try {
      const o = audioCtx.createOscillator();
      o.type = "sine";
      o.frequency.value = 60;
      const g = safeCreateGain();
      if (!g) return;
      g.gain.value = 0.01;
      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 400;
      o.connect(filter);
      filter.connect(g);
      g.connect(audioCtx.destination);
      o.start();
      bgHum = { osc: o, gain: g, filter };
    } catch (e) {
      console.warn("Error starting background hum:", e);
      audioEnabled = false;
    }
  }

  function stopBackgroundHum() {
    if (!bgHum) return;
    try {
      bgHum.gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
      bgHum.osc.stop(audioCtx.currentTime + 0.22);
    } catch (e) {
      // ignore
    }
    bgHum = null;
  }

  // Game state
  let bubbles = [];
  let target = 10;
  let currentSum = 0;
  let score = 0;
  let attemptsLeft = 3;
  let selectedIndex = 0;
  let message = "Welcome! Select bubbles summing to the battery voltage.";
  let level = 1;
  let sparkX = WIDTH * 0.15;
  let sparkY = HEIGHT * 0.5;
  let sparkAnim = 0;
  let muted = false;
  let showAudioIndicator = true;

  // Utility random numbers
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Initialize level
  function setupLevel(lv = 1) {
    level = lv;
    target = randInt(TARGET_MIN + lv - 1, Math.min(TARGET_MAX + lv - 1, TARGET_MAX + 4));
    bubbles = [];
    const count = Math.min(MAX_BUBBLES, 3 + Math.floor(Math.random() * 4));
    // create bubbles with values ensuring there is at least one combination equal to target
    // naive approach: pick some values, then adjust one to ensure solution
    for (let i = 0; i < count; i++) {
      bubbles.push({
        value: randInt(1, Math.max(3, Math.floor(target / 2))),
        x: WIDTH * 0.5 + Math.cos((i / count) * Math.PI * 2) * 160 + randInt(-30, 30),
        y: HEIGHT * 0.35 + Math.sin((i / count) * Math.PI * 2) * 80 + randInt(-20, 20),
        picked: false,
        wobble: Math.random() * Math.PI * 2
      });
    }
    // Ensure solvable: pick a subset and set their sum to target by adjusting last item's value
    const subsetSize = Math.min(3, bubbles.length);
    let sum = 0;
    for (let i = 0; i < subsetSize - 1; i++) {
      sum += bubbles[i].value;
    }
    const lastNeeded = Math.max(1, target - sum);
    bubbles[subsetSize - 1].value = lastNeeded;
    // reset other state
    currentSum = 0;
    attemptsLeft = 3;
    selectedIndex = 0;
    score = Math.max(0, score);
    sparkX = WIDTH * 0.15;
    sparkY = HEIGHT * 0.5;
    message = `Level ${level}. Help Sparky reach ${target} volts!`;
    announce(message);
  }

  // Announce via ARIA friendly status
  function announce(text) {
    statusDiv.textContent = text;
  }

  // Drawing helpers
  function drawRoundedRect(x, y, w, h, r = 8, fillStyle = "#fff", strokeStyle = "#000") {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fillStyle = fillStyle;
    ctx.fill();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Draw characters using canvas only
  function drawSparky(x, y, size = 48, awake = true) {
    // Body (spark)
    ctx.save();
    ctx.translate(x, y);
    // glow
    const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 1.5);
    grd.addColorStop(0, "rgba(255,210,100,0.6)");
    grd.addColorStop(1, "rgba(255,210,100,0)");
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, size * 1.2, 0, Math.PI * 2);
    ctx.fill();

    // Zigzag spark lines
    ctx.beginPath();
    ctx.moveTo(-size * 0.6, -size * 0.2);
    ctx.lineTo(-size * 0.2, -size * 0.6);
    ctx.lineTo(size * 0.1, -size * 0.1);
    ctx.lineTo(size * 0.5, -size * 0.3);
    ctx.lineTo(size * 0.1, size * 0.2);
    ctx.lineTo(size * 0.6, size * 0.6);
    ctx.strokeStyle = "#FFD66B";
    ctx.lineWidth = 4;
    ctx.lineJoin = "round";
    ctx.stroke();

    // face
    ctx.fillStyle = awake ? "#222" : "#666";
    ctx.beginPath();
    ctx.arc(-8, -4, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(12, -6, 4, 0, Math.PI * 2);
    ctx.fill();

    // Smile
    ctx.beginPath();
    ctx.strokeStyle = "#332200";
    ctx.lineWidth = 2;
    ctx.arc(2, 6, 8, 0, Math.PI);
    ctx.stroke();

    ctx.restore();
  }

  function drawBulb(x, y, lit = false) {
    ctx.save();
    ctx.translate(x, y);
    // bulb glass
    ctx.beginPath();
    ctx.ellipse(0, -10, 32, 40, 0, 0, Math.PI * 2);
    ctx.fillStyle = lit ? "rgba(255,245,170,0.95)" : "rgba(240,255,255,0.9)";
    ctx.fill();
    ctx.strokeStyle = lit ? "#FFD66B" : "#C0E7FF";
    ctx.lineWidth = 3;
    ctx.stroke();

    // filament (wacky)
    ctx.beginPath();
    ctx.moveTo(-12, -6);
    ctx.quadraticCurveTo(0, -24, 12, -6);
    ctx.strokeStyle = lit ? "#FFAA33" : "#A0C0D0";
    ctx.lineWidth = 3;
    ctx.stroke();

    // base
    drawRoundedRect(-24, 20, 48, 14, 3, "#B0B0B0", "#888");

    ctx.restore();
  }

  function drawWire(x1, y1, x2, y2, on = false) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    const midx = (x1 + x2) / 2;
    ctx.quadraticCurveTo(midx, y1 - 30, x2, y2);
    ctx.strokeStyle = on ? "#FFD66B" : "#8BB4D0";
    ctx.lineWidth = on ? 6 : 4;
    ctx.lineCap = "round";
    ctx.stroke();
    // little sparks along wire if on
    if (on) {
      for (let t = 0; t <= 1; t += 0.2) {
        const sx = x1 + (x2 - x1) * t + Math.sin((Date.now() / 200) + t * 10) * 4;
        const sy = y1 + (y2 - y1) * t + Math.cos((Date.now() / 200) + t * 10) * 4;
        ctx.beginPath();
        ctx.fillStyle = "#FFF1C4";
        ctx.arc(sx, sy, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Draw bubble with number
  function drawBubble(b, index, isSelected) {
    const { x, y, value, picked } = b;
    ctx.save();
    ctx.translate(x, y);
    const wob = Math.sin(b.wobble + Date.now() / 400) * 2;
    ctx.translate(0, wob);
    // outer ring
    ctx.beginPath();
    ctx.arc(0, 0, picked ? 34 : 30, 0, Math.PI * 2);
    ctx.fillStyle = picked ? "#E8FDF5" : "#EAF6FF";
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = isSelected ? "#FFCC55" : "#8BB4D0";
    ctx.stroke();
    // inner pattern (circuity)
    ctx.beginPath();
    ctx.moveTo(-12, 0);
    ctx.lineTo(0, -10);
    ctx.lineTo(12, 0);
    ctx.moveTo(0, 10);
    ctx.lineTo(0, -10);
    ctx.strokeStyle = "#C0E7FF";
    ctx.lineWidth = 2;
    ctx.stroke();

    // number
    ctx.fillStyle = "#133D4D";
    ctx.font = "20px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(value), 0, 0);

    // small label for keyboard index
    ctx.fillStyle = "#666";
    ctx.font = "12px sans-serif";
    ctx.fillText(String(index + 1), -20, -20);

    ctx.restore();
  }

  // Main render
  function render() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // background grid with wacky nodes
    ctx.fillStyle = "#EAF8FF";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // subtle circuit lines background
    ctx.save();
    ctx.lineWidth = 1;
    for (let i = 0; i < 6; i++) {
      ctx.beginPath();
      ctx.strokeStyle = i % 2 === 0 ? "rgba(200,230,255,0.6)" : "rgba(220,245,255,0.4)";
      const y = 80 + i * 60 + Math.sin(Date.now() / 1000 + i) * 6;
      ctx.moveTo(40, y);
      ctx.bezierCurveTo(160, y - 20, 320, y + 20, 680, y);
      ctx.stroke();
    }
    ctx.restore();

    // left: power station
    drawRoundedRect(30, 60, 180, 140, 12, "#FFF8E6", "#FFDB7B");
    ctx.fillStyle = "#3B6B86";
    ctx.font = "18px sans-serif";
    ctx.fillText("Battery Lab", 55, 85);
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#333";
    ctx.fillText(`Target: ${target} V`, 60, 110);
    ctx.fillText(`Sum: ${currentSum} V`, 60, 132);
    ctx.fillText(`Attempts: ${attemptsLeft}`, 60, 154);
    ctx.fillText(`Score: ${score}`, 60, 174);

    // big bulb on right
    const bulbX = WIDTH - 140;
    const bulbY = HEIGHT * 0.5 - 10;
    const bulbLit = currentSum === target;
    drawWire(220, 130, bulbX - 20, bulbY - 20, bulbLit);
    drawBulb(bulbX, bulbY, bulbLit);

    // Sparky near battery
    drawSparky(sparkX + Math.sin(sparkAnim) * 4, sparkY, 40, attemptsLeft > 0);

    // draw bubbles
    bubbles.forEach((b, i) => drawBubble(b, i, i === selectedIndex));

    // draw instruction semi-transparent box at bottom
    drawRoundedRect(40, HEIGHT - 110, WIDTH - 80, 90, 10, "rgba(255,255,255,0.9)", "#CDE9FF");
    ctx.fillStyle = "#0D3A49";
    ctx.font = "16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Instructions: Select number bubbles to add up to the battery voltage.", 60, HEIGHT - 78);
    ctx.font = "14px sans-serif";
    ctx.fillText("Click a bubble or press 1-6. Use ← → to move, Space/Enter to pick. R to reset, M to mute.", 60, HEIGHT - 56);
    ctx.fillStyle = "#555";
    ctx.font = "12px sans-serif";
    ctx.fillText(message, 60, HEIGHT - 34);

    // small audio indicator
    ctx.save();
    ctx.translate(WIDTH - 40, 20);
    ctx.beginPath();
    ctx.rect(-18, -12, 36, 24);
    ctx.fillStyle = muted || !audioEnabled ? "#F2F2F2" : "#FFF6D6";
    ctx.fill();
    ctx.strokeStyle = "#CCC";
    ctx.stroke();
    ctx.fillStyle = muted || !audioEnabled ? "#888" : "#FFB64D";
    ctx.font = "12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(muted || !audioEnabled ? "Muted" : "Audio", 0, 2);
    ctx.restore();

    // visual cue for audio (small speaker waves if enabled)
    if (!muted && audioEnabled) {
      ctx.save();
      ctx.translate(WIDTH - 90, 22);
      ctx.beginPath();
      ctx.arc(-6, 0, 6, 0.2 * Math.PI, 1.8 * Math.PI);
      ctx.strokeStyle = "#FFBB55";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(6, 0, 10, 0.2 * Math.PI, 1.8 * Math.PI);
      ctx.stroke();
      ctx.restore();
    }

    // small decorative wacky elements: floating little electrons
    for (let e = 0; e < 5; e++) {
      const ex = (e * 130 + (Date.now() / 6)) % WIDTH;
      const ey = 40 + ((e * 73) % 420) + Math.sin(Date.now() / 300 + e) * 8;
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.arc(ex, ey, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "rgba(200,230,255,0.8)";
      ctx.stroke();
    }
  }

  // Game logic: pick bubble
  function pickBubble(i) {
    if (i < 0 || i >= bubbles.length) return;
    const b = bubbles[i];
    if (b.picked) {
      message = "You already used that charge bubble.";
      announce(message);
      return;
    }
    // pick it
    const newSum = currentSum + b.value;
    b.picked = true;
    if (!muted && audioEnabled) playTone({ freq: 520, type: "triangle", duration: 0.06, gain: 0.05 });
    // animate spark toward bulb proportional to sum
    // update sum then check
    currentSum = newSum;
    message = `Added ${b.value} V. Sum is now ${currentSum} V.`;
    announce(message);

    // If exceed target
    if (currentSum > target) {
      attemptsLeft -= 1;
      message = `Oh no! Overheated: ${currentSum} > ${target}. Attempts left: ${attemptsLeft}.`;
      announce(message);
      if (!muted && audioEnabled) playWrong();
      // flash red by temporarily setting message color — handled by draw text
      // reset bubbles' picked state and partial reset behavior
      setTimeout(() => {
        // reset: unpick all except maybe keep them used? easier: unpick all, reduce score
        bubbles.forEach((bb) => (bb.picked = false));
        currentSum = 0;
        selectedIndex = 0;
        if (attemptsLeft <= 0) {
          message = `Sparky needs a break! Press R to try again.`;
          announce(message);
          if (!muted && audioEnabled) {
            playTone({ freq: 220, type: "sine", duration: 0.25, gain: 0.04 });
          }
        } else {
          message = `Try a different combination to reach ${target} V.`;
          announce(message);
        }
      }, 800);
      score = Math.max(0, score - 1);
      return;
    }

    // If exact
    if (currentSum === target) {
      score += 1;
      message = `Perfect! The bulb lights up at ${target} V! Press R for next level.`;
      announce(message);
      if (!muted && audioEnabled) playCorrect();
      // animate bulb lit and spark travel
      // set spark close to bulb
      sparkX = WIDTH * 0.55;
      sparkY = HEIGHT * 0.4;
      // prepare next level after short delay
      setTimeout(() => {
        setupLevel(level + 1);
        if (!muted && audioEnabled) playTone({ freq: 480, type: "sawtooth", duration: 0.12, gain: 0.06 });
      }, 1600);
      return;
    }

    // otherwise continue
    // tiny reward ping
    if (!muted && audioEnabled) playTone({ freq: 660 - currentSum * 8, type: "sine", duration: 0.08, gain: 0.04 });
    // move spark a bit
    sparkX += 30;
    if (sparkX > WIDTH * 0.45) sparkX = WIDTH * 0.45;
  }

  // mouse handling: click on bubble
  function onCanvasClick(e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // check bubbles
    for (let i = 0; i < bubbles.length; i++) {
      const b = bubbles[i];
      const dx = mx - b.x;
      const dy = my - b.y;
      if (dx * dx + dy * dy <= 34 * 34) {
        selectedIndex = i;
        pickBubble(i);
        return;
      }
    }
    // click other areas: audio toggle if clicked on audio indicator
    if (mx > WIDTH - 120 && mx < WIDTH - 20 && my > 0 && my < 40) {
      toggleMute();
      return;
    }
  }

  // keyboard handling
  function onContainerKeyDown(e) {
    // ensure audio context resumed on user gesture
    if (audioEnabled && audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume().catch(() => {});
    }
    if (e.key === "ArrowRight") {
      selectedIndex = (selectedIndex + 1) % bubbles.length;
      e.preventDefault();
      announce(`Selected bubble ${selectedIndex + 1} with ${bubbles[selectedIndex].value} volts.`);
    } else if (e.key === "ArrowLeft") {
      selectedIndex = (selectedIndex - 1 + bubbles.length) % bubbles.length;
      e.preventDefault();
      announce(`Selected bubble ${selectedIndex + 1} with ${bubbles[selectedIndex].value} volts.`);
    } else if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") {
      pickBubble(selectedIndex);
      e.preventDefault();
    } else if (e.key.toLowerCase() === "r") {
      setupLevel(1);
      announce("Game reset. New level started.");
      e.preventDefault();
    } else if (e.key.toLowerCase() === "m") {
      toggleMute();
      e.preventDefault();
    } else {
      // number keys 1-6
      const num = parseInt(e.key, 10);
      if (!isNaN(num) && num >= 1 && num <= bubbles.length) {
        selectedIndex = num - 1;
        pickBubble(selectedIndex);
        e.preventDefault();
      }
    }
  }

  // Mute toggle
  function toggleMute() {
    muted = !muted;
    if (muted) {
      stopBackgroundHum();
      message = "Audio muted. Press M to unmute.";
      announce("Audio muted.");
    } else {
      if (audioEnabled) startBackgroundHum();
      message = "Audio enabled. Sounds on!";
      announce("Audio enabled.");
      // small sound to confirm
      if (audioEnabled) playTone({ freq: 660, duration: 0.08, gain: 0.05 });
    }
  }

  // Game loop
  let lastTime = 0;
  function loop(ts) {
    const dt = (ts - lastTime) / 1000 || 0;
    lastTime = ts;
    // animate wobble
    bubbles.forEach((b) => (b.wobble += dt * 2));
    sparkAnim += dt * 6;
    // gentle movement of spark toward bulb when lit
    if (currentSum === target) {
      sparkX += (WIDTH - 200 - sparkX) * dt * 2;
      sparkY += (HEIGHT * 0.42 - sparkY) * dt * 2;
    } else {
      // idle breathing
      sparkX += Math.sin(Date.now() / 400) * 0.01;
    }
    render();
    requestAnimationFrame(loop);
  }

  // Event listeners
  canvas.addEventListener("click", onCanvasClick);
  container.addEventListener("keydown", onContainerKeyDown);
  // make sure container gets focus so keyboard works
  container.addEventListener("mousedown", () => container.focus());
  container.addEventListener("touchstart", () => container.focus());

  // Initialize
  function startGame() {
    // Start background hum if possible and not muted
    if (audioEnabled) {
      try {
        startBackgroundHum();
      } catch (e) {
        console.warn("Failed to start background audio:", e);
        audioEnabled = false;
      }
    }
    setupLevel(1);
    requestAnimationFrame(loop);
  }

  // Graceful fallback if audio is blocked (autoplay policy)
  if (audioEnabled && audioCtx && audioCtx.state === "suspended") {
    // wait for first user gesture to resume
    message = "Tap or press any key to enable sound and start the game.";
    announce(message);
    const resumeHandler = () => {
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {
          audioEnabled = false;
        });
      }
      startGame();
      window.removeEventListener("click", resumeHandler);
      window.removeEventListener("keydown", resumeHandler);
      window.removeEventListener("touchstart", resumeHandler);
    };
    window.addEventListener("click", resumeHandler);
    window.addEventListener("keydown", resumeHandler);
    window.addEventListener("touchstart", resumeHandler);
  } else {
    startGame();
  }

  // Expose a small API on container for testing or external controls (non-essential)
  container.gameAPI = {
    reset: () => setupLevel(1),
    mute: () => {
      if (!muted) toggleMute();
    },
    unmute: () => {
      if (muted) toggleMute();
    },
    getState: () => ({ target, currentSum, score, level, attemptsLeft })
  };

  // Error handling demo: if any uncaught errors, show message in status
  window.addEventListener("error", (ev) => {
    message = "An error occurred. Try reloading the game.";
    announce(message);
    console.error("Game error:", ev.error);
  });
})();
---

