# Game of the Day - 2025-08-09

## Metadata
- **Generated Date:** 2025-08-09
- **Generated Time:** 2025-08-09T00:21:14.535301
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-09.js
- **File Size:** 25464 bytes
- **Tokens Used:** 8749

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-09.js` - The playable game
- `2025-08-09.meta.json` - Machine-readable metadata
- `2025-08-09.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18201

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19972

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Electricity-themed Math Game for ages 7-9
  // Renders entirely inside element with id "game-of-the-day-stage"
  // Uses canvas-only graphics and Web Audio API generated sounds
  // Keyboard accessible and includes error handling for audio and resources

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const BUBBLE_RADIUS = 20;
  const BULB_COUNT = 4;
  const START_LIVES = 3;
  const TARGET_MIN = 6;
  const TARGET_MAX = 14;
  const SPAWN_INTERVAL_MS = 1500; // starting spawn pace
  const DIFFICULTY_INCREASE_EVERY = 15000; // ms
  const MAX_BUBBLE_VALUE = 5; // values 1..5

  // Colors (calming and wacky palette)
  const COLORS = {
    bg: "#E8F6FF",
    panel: "#F4FAFF",
    bolt: "#FFD166",
    spark: "#60D394",
    bulbOff: "#E0E6EE",
    bulbOn: "#FFF9B1",
    text: "#05386B",
    wrong: "#FF6B6B",
    correct: "#2ECC71",
    collector: "#6D9BF1",
    bubbleFill: "#9ED9CC",
    battery: "#FFD166",
  };

  // Elements and Canvas
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("No container with id 'game-of-the-day-stage' found.");
    return;
  }

  // Create accessible instructions area for screen readers
  const srInstructions = document.createElement("div");
  srInstructions.setAttribute("aria-live", "polite");
  srInstructions.style.position = "absolute";
  srInstructions.style.left = "-9999px";
  srInstructions.style.width = "1px";
  srInstructions.style.height = "1px";
  srInstructions.style.overflow = "hidden";
  srInstructions.id = "game-of-the-day-sr";
  srInstructions.innerText =
    "Electric Math: Move the collector with arrow keys or mouse. Catch number charges and press 1-4 to send them to matching bulbs. Match sums exactly to light bulbs.";
  container.appendChild(srInstructions);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Electric Math game canvas");
  canvas.style.display = "block";
  canvas.style.background = COLORS.bg;
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");

  // Audio setup with error handling
  let audioCtx = null;
  let audioEnabled = true;
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) {
      throw new Error("Web Audio API not supported in this browser.");
    }
    audioCtx = new AC();
  } catch (err) {
    console.warn("Audio unavailable:", err.message);
    audioEnabled = false;
    audioCtx = null;
  }

  // State
  let lastTime = performance.now();
  let spawnTimer = 0;
  let spawnInterval = SPAWN_INTERVAL_MS;
  let difficultyTimer = 0;
  let running = false;
  let muted = !audioEnabled; // if audio unavailable, control muted state
  let score = 0;
  let lives = START_LIVES;
  let level = 1;
  let bulbs = [];
  let bubbles = [];
  let collector = {
    x: WIDTH / 2,
    y: HEIGHT - 80,
    width: 120,
    height: 40,
    speed: 300, // pixels per second
    carrying: null, // holds bubble reference
  };
  let keys = {};
  let lastSpawnId = 0;
  let messages = []; // floating text messages

  // Accessibility: announce function
  function announce(text) {
    srInstructions.innerText = text;
  }

  // Create initial bulbs
  function initBulbs() {
    bulbs = [];
    const padding = 40;
    const usableWidth = WIDTH - padding * 2;
    const spacing = usableWidth / BULB_COUNT;
    for (let i = 0; i < BULB_COUNT; i++) {
      const target = randInt(TARGET_MIN, TARGET_MAX);
      bulbs.push({
        id: i + 1,
        x: padding + spacing * i + spacing / 2,
        y: HEIGHT - 160,
        radius: 36,
        current: 0,
        target: target,
        lit: false,
        overloaded: false,
      });
    }
  }

  // Utility functions
  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }
  function randInt(min, max) {
    return Math.floor(rand(min, max + 1));
  }

  // Bubble creation
  function spawnBubble() {
    const x = rand(40, WIDTH - 40);
    const val = randInt(1, MAX_BUBBLE_VALUE);
    const id = ++lastSpawnId;
    bubbles.push({
      id,
      x,
      y: -BUBBLE_RADIUS,
      vy: rand(30, 60) + level * 5,
      radius: BUBBLE_RADIUS,
      value: val,
      caught: false,
      targetBulb: null,
      returning: false,
    });
  }

  // Audio helper functions with safe checks
  function safeCreateGain() {
    if (!audioCtx) return null;
    try {
      return audioCtx.createGain();
    } catch (e) {
      return null;
    }
  }

  function playBeep(type = "correct") {
    if (muted || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      let freq = 660;
      let dur = 0.18;
      if (type === "correct") {
        freq = 880;
        dur = 0.22;
        osc.type = "sine";
      } else if (type === "wrong") {
        freq = 150;
        dur = 0.24;
        osc.type = "square";
      } else if (type === "pickup") {
        freq = 520;
        dur = 0.12;
        osc.type = "triangle";
      } else if (type === "light") {
        freq = 1200;
        dur = 0.26;
        osc.type = "sine";
      } else if (type === "spark") {
        freq = 1000;
        dur = 0.08;
        osc.type = "sawtooth";
      }
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      osc.frequency.setValueAtTime(freq, now);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + dur + 0.05);
    } catch (err) {
      console.warn("Sound playback failed:", err);
    }
  }

  // Gentle background hum using oscillator - resumed on user gesture
  let humOsc = null;
  function startBackgroundHum() {
    if (muted || !audioCtx) return;
    if (humOsc) return;
    try {
      humOsc = audioCtx.createOscillator();
      const humGain = audioCtx.createGain();
      humOsc.type = "sine";
      humOsc.frequency.value = 60;
      humGain.gain.value = 0.01;
      // slight detune movement
      humOsc.connect(humGain);
      humGain.connect(audioCtx.destination);
      humOsc.start();
    } catch (err) {
      console.warn("Background hum failed:", err);
      humOsc = null;
    }
  }
  function stopBackgroundHum() {
    if (humOsc) {
      try {
        humOsc.stop();
      } catch (e) {}
      humOsc = null;
    }
  }

  // Input handling
  document.addEventListener("keydown", (e) => {
    keys[e.key] = true;

    // Allow space for pickup in addition to automatic grab
    if (e.key === " " || e.key === "Spacebar") {
      // attempt to pick up nearest bubble if in range
      attemptPickup();
      e.preventDefault();
    }

    // Send carried bubble to bulb 1-4
    if (["1", "2", "3", "4"].includes(e.key)) {
      const bulbIndex = Number(e.key) - 1;
      sendToBulb(bulbIndex);
    }

    // mute toggle
    if (e.key.toLowerCase() === "m") {
      toggleMute();
    }

    // Start sounds on first user gesture
    if (!running) {
      startGame();
    }
  });
  document.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });

  // Mouse
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    collector.x = Math.min(
      WIDTH - collector.width / 2,
      Math.max(collector.width / 2, e.clientX - rect.left)
    );
  });
  canvas.addEventListener("click", (e) => {
    // click to start or pick up
    if (!running) {
      startGame();
      return;
    }
    // on click while carrying bubble, choose bulb by clicking near it
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    for (let i = 0; i < bulbs.length; i++) {
      const b = bulbs[i];
      const dx = x - b.x;
      const dy = y - b.y;
      if (dx * dx + dy * dy <= (b.radius + 10) * (b.radius + 10)) {
        sendToBulb(i);
        return;
      }
    }
    // otherwise attempt to pick up if near
    attemptPickup();
  });

  // Game actions
  function attemptPickup() {
    if (collector.carrying) return;
    for (let bub of bubbles) {
      if (bub.caught || bub.returning) continue;
      // detect overlap with collector box
      const withinX = bub.x >= collector.x - collector.width / 2 - bub.radius &&
        bub.x <= collector.x + collector.width / 2 + bub.radius;
      const withinY = bub.y + bub.radius >= collector.y - collector.height / 2 &&
        bub.y - bub.radius <= collector.y + collector.height / 2;
      if (withinX && withinY) {
        bub.caught = true;
        collector.carrying = bub;
        playBeep("pickup");
        announce(`Picked up a ${bub.value} charge. Press 1 to 4 to send to a bulb.`);
        break;
      }
    }
  }

  function sendToBulb(index) {
    if (!collector.carrying) {
      announce("No charge to send. Move to a falling charge and catch it.");
      return;
    }
    if (index < 0 || index >= bulbs.length) return;
    const bub = collector.carrying;
    bub.caught = false;
    bub.returning = true;
    bub.targetBulb = index;
    // set velocity to move towards bulb
    const b = bulbs[index];
    const dx = b.x - bub.x;
    const dy = b.y - bub.y;
    const dist = Math.hypot(dx, dy);
    const travelTime = 0.5; // seconds
    bub.vx = dx / travelTime;
    bub.vy = dy / travelTime;
    collector.carrying = null;
    playBeep("spark");
    announce(`Sent a ${bub.value} charge to bulb ${index + 1}.`);
  }

  // Game start and reset
  function startGame() {
    running = true;
    score = 0;
    lives = START_LIVES;
    level = 1;
    spawnInterval = SPAWN_INTERVAL_MS;
    difficultyTimer = 0;
    messages = [];
    initBulbs();
    bubbles = [];
    collector.x = WIDTH / 2;
    collector.carrying = null;
    lastTime = performance.now();
    spawnTimer = 0;
    lastSpawnId = 0;
    muted = muted && !audioCtx ? true : muted; // keep disabled if no audio
    // resume audio context on user gesture if available
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume().catch((err) => {
        console.warn("AudioContext resume failed:", err);
      });
    }
    if (audioCtx) startBackgroundHum();
    announce("Game started. Catch charges and send to bulbs to light them.");
    requestAnimationFrame(loop);
  }

  // End game
  function endGame(win = false) {
    running = false;
    stopBackgroundHum();
    if (win) {
      announce(`Congratulations! You lit all the bulbs. Score ${score}. Press any key to play again.`);
      playBeep("light");
    } else {
      announce(`Game over. Score ${score}. Press any key to try again.`);
    }
  }

  // Message system for floating text
  function pushMessage(text, x, y, color = COLORS.text) {
    messages.push({
      text,
      x,
      y,
      life: 2000,
      created: performance.now(),
      color,
    });
  }

  // Update and draw loop
  function loop(ts) {
    const dt = Math.min(50, ts - lastTime) / 1000; // delta seconds, clamp
    lastTime = ts;
    if (!running) {
      // draw static screen with instructions
      drawIntro();
      return;
    }
    // Update timers
    spawnTimer += dt * 1000;
    difficultyTimer += dt * 1000;

    if (difficultyTimer >= DIFFICULTY_INCREASE_EVERY) {
      difficultyTimer = 0;
      level++;
      spawnInterval = Math.max(600, spawnInterval - 120);
      pushMessage(`Level ${level}! Bubbles fall faster.`, WIDTH / 2, 60, COLORS.spark);
    }

    if (spawnTimer >= spawnInterval) {
      spawnTimer = 0;
      spawnBubble();
    }

    // Move collector with keyboard
    if (keys["ArrowLeft"] || keys["a"]) {
      collector.x -= collector.speed * dt;
    }
    if (keys["ArrowRight"] || keys["d"]) {
      collector.x += collector.speed * dt;
    }
    // clamp
    collector.x = Math.max(collector.width / 2, Math.min(WIDTH - collector.width / 2, collector.x));

    // Update bubbles
    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      if (b.caught && b !== collector.carrying) {
        // should not happen, but fix
        b.caught = false;
      }
      if (b.caught && b === collector.carrying) {
        // follow collector
        b.x = collector.x;
        b.y = collector.y - collector.height / 2 - b.radius - 4;
      } else if (b.returning && b.targetBulb != null) {
        // move to bulb location
        const tb = bulbs[b.targetBulb];
        // simple linear movement using vx, vy
        // Convert vx, vy per second to per dt
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        // check arrival
        const dx = b.x - tb.x;
        const dy = b.y - tb.y;
        if (Math.hypot(dx, dy) < tb.radius + b.radius) {
          // arrive
          b.returning = false;
          b.vx = 0;
          b.vy = 0;
          resolveBubbleArrival(b, tb);
          // remove bubble from array
          bubbles.splice(i, 1);
        }
      } else {
        // falling normally
        b.y += b.vy * dt;
      }

      // if off-screen bottom (not caught), lose life
      if (b.y - b.radius > HEIGHT + 40) {
        // remove
        if (b.caught) {
          collector.carrying = null;
        }
        bubbles.splice(i, 1);
        // penalty: lose life
        lives--;
        pushMessage("Missed!", WIDTH / 2, 80, COLORS.wrong);
        playBeep("wrong");
        announce(`You missed a charge. Lives remaining ${lives}.`);
        if (lives <= 0) {
          endGame(false);
          return;
        }
      }
    }

    // Update messages
    const now = performance.now();
    messages = messages.filter((m) => now - m.created < m.life);

    // Check win: all bulbs lit
    if (bulbs.every((b) => b.lit)) {
      endGame(true);
      return;
    }

    // Draw everything
    draw();

    requestAnimationFrame(loop);
  }

  function resolveBubbleArrival(bubble, bulb) {
    // Add bubble value to bulb
    bulb.current += bubble.value;
    // Visual feedback and sounds
    if (bulb.current === bulb.target) {
      bulb.lit = true;
      bulb.overloaded = false;
      score += 10;
      pushMessage("Perfect! Bulb lit.", bulb.x, bulb.y - 60, COLORS.correct);
      playBeep("light");
      announce(`Bulb ${bulb.id} lit! Good job. Score ${score}.`);
    } else if (bulb.current < bulb.target) {
      score += 1;
      pushMessage(`+${bubble.value}`, bulb.x, bulb.y - 30, COLORS.spark);
      playBeep("correct");
      announce(`Added ${bubble.value} to bulb ${bulb.id}. It now has ${bulb.current} of ${bulb.target}.`);
    } else {
      // overload
      bulb.overloaded = true;
      bulb.lit = false;
      score = Math.max(0, score - 3);
      lives = Math.max(0, lives - 1);
      pushMessage("Overloaded!", bulb.x, bulb.y - 50, COLORS.wrong);
      playBeep("wrong");
      announce(`Oh no! Bulb ${bulb.id} overloaded. Lives ${lives}.`);
      // reset bulb after small delay
      setTimeout(() => {
        bulb.current = 0;
        bulb.overloaded = false;
      }, 900);
      if (lives <= 0) {
        endGame(false);
      }
    }
  }

  // Drawing functions
  function draw() {
    // background
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();

    // top panel with characters and text
    drawTopPanel();

    // bulbs
    for (let i = 0; i < bulbs.length; i++) {
      drawBulb(bulbs[i], i);
      // number label (1-4) for keyboard reference
      ctx.save();
      ctx.fillStyle = COLORS.text;
      ctx.font = "16px Arial";
      ctx.textAlign = "center";
      ctx.fillText(`(${i + 1})`, bulbs[i].x, bulbs[i].y + bulbs[i].radius + 22);
      ctx.restore();
    }

    // bubbles
    for (let b of bubbles) {
      drawBubble(b);
    }

    // collector
    drawCollector();

    // HUD: score, lives, instructions
    drawHUD();

    // messages
    drawMessages();
  }

  function drawBackground() {
    // gentle gradient (calming)
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#E8F6FF");
    g.addColorStop(1, "#F8FFFF");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft wavy circuits doodles
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = COLORS.bolt;
    ctx.lineWidth = 3;
    for (let i = 0; i < 6; i++) {
      ctx.beginPath();
      const y = 40 + i * 70;
      ctx.moveTo(20, y);
      ctx.bezierCurveTo(160, y - 20, 300, y + 40, WIDTH - 20, y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawTopPanel() {
    // Left character: Sparky the squirrel battery friend
    drawSparky(80, 100);

    // Right character: Volt the friendly robot
    drawVolt(WIDTH - 110, 100);

    // Title and instructions
    ctx.save();
    ctx.fillStyle = COLORS.text;
    ctx.font = "24px Comic Sans MS, Arial";
    ctx.textAlign = "center";
    ctx.fillText("Electric Math: Charge the Bulbs!", WIDTH / 2, 50);

    ctx.font = "14px Arial";
    ctx.fillStyle = "#27496D";
    ctx.fillText(
      "Catch numbered charges and press 1-4 to send them to bulbs. Match the sums exactly to light them!",
      WIDTH / 2,
      72
    );

    // audio indicator
    ctx.fillStyle = muted ? COLORS.wrong : COLORS.correct;
    ctx.beginPath();
    ctx.arc(WIDTH - 30, 30, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.font = "12px Arial";
    ctx.fillStyle = "#fff";
    ctx.fillText(muted ? "M" : "S", WIDTH - 30, 34);
    ctx.restore();
  }

  function drawSparky(cx, cy) {
    // Cute battery-squirrel hybrid
    ctx.save();
    // body
    ctx.fillStyle = COLORS.battery;
    roundRect(ctx, cx - 36, cy - 28, 72, 56, 12);
    ctx.fill();

    // face
    ctx.fillStyle = "#FFF";
    circle(ctx, cx - 6, cy - 6, 10);
    circle(ctx, cx + 14, cy - 6, 10);
    // eyes
    ctx.fillStyle = "#05386B";
    circle(ctx, cx - 8, cy - 6, 3);
    circle(ctx, cx + 12, cy - 6, 3);
    // smile
    ctx.strokeStyle = "#05386B";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx + 3, cy + 2, 8, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.stroke();

    // tail (wacky spark tail)
    ctx.fillStyle = COLORS.spark;
    ctx.beginPath();
    ctx.moveTo(cx - 40, cy + 8);
    ctx.quadraticCurveTo(cx - 70, cy - 30, cx - 30, cy - 40);
    ctx.quadraticCurveTo(cx - 10, cy - 20, cx - 20, cy - 10);
    ctx.fill();

    // little bolt on battery
    ctx.fillStyle = COLORS.bolt;
    ctx.beginPath();
    ctx.moveTo(cx + 20, cy + 8);
    ctx.lineTo(cx + 10, cy + 2);
    ctx.lineTo(cx + 16, cy + 2);
    ctx.lineTo(cx + 6, cy - 8);
    ctx.lineTo(cx + 22, cy + 6);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  function drawVolt(cx, cy) {
    // Friendly robot with antenna spark
    ctx.save();
    // head
    ctx.fillStyle = "#DDEBFF";
    roundRect(ctx, cx - 30, cy - 34, 60, 44, 8);
    ctx.fill();

    // eyes
    ctx.fillStyle = "#05386B";
    circle(ctx, cx - 10, cy - 14, 5);
    circle(ctx, cx + 10, cy - 14, 5);

    // antenna
    ctx.strokeStyle = COLORS.bolt;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(cx, cy - 34);
    ctx.lineTo(cx, cy - 52);
    ctx.stroke();
    ctx.fillStyle = COLORS.spark;
    circle(ctx, cx, cy - 56, 6);

    // body
    ctx.fillStyle = "#BEE3F8";
    roundRect(ctx, cx - 36, cy + 12, 72, 52, 10);
    ctx.fill();

    // smile
    ctx.strokeStyle = "#05386B";
    ctx.beginPath();
    ctx.moveTo(cx - 8, cy + 6);
    ctx.quadraticCurveTo(cx, cy + 14, cx + 8, cy + 6);
    ctx.stroke();
    ctx.restore();
  }

  function drawBulb(bulb, index) {
    ctx.save();
    // socket base
    ctx.fillStyle = "#D1D9E6";
    roundRect(ctx, bulb.x - 30, bulb.y + 24, 60, 18, 6);
    ctx.fill();

    // glass bulb
    ctx.beginPath();
    ctx.arc(bulb.x, bulb.y, bulb.radius, 0, Math.PI * 2);
    ctx.fillStyle = bulb.lit ? COLORS.bulbOn : COLORS.bulbOff;
    ctx.fill();

    // filament drawing
    ctx.strokeStyle = bulb.lit ? COLORS.bolt : "#A0A8B6";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(bulb.x - 10, bulb.y);
    ctx.lineTo(bulb.x, bulb.y + 8);
    ctx.lineTo(bulb.x + 10, bulb.y);
    ctx.stroke();

    // value text
    ctx.fillStyle = COLORS.text;
    ctx.font = "bold 16px Arial";
    ctx.textAlign = "center";
    ctx.fillText(`${bulb.current} / ${bulb.target}`, bulb.x, bulb.y + 6);

    // small overload flash
    if (bulb.overloaded) {
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = COLORS.wrong;
      ctx.beginPath();
      ctx.arc(bulb.x, bulb.y, bulb.radius + 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawBubble(b) {
    ctx.save();
    // rim
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius + 2, 0, Math.PI * 2);
    ctx.fillStyle = "#BEECE6";
    ctx.fill();

    // fill with gradient
    const g = ctx.createLinearGradient(b.x - b.radius, b.y - b.radius, b.x + b.radius, b.y + b.radius);
    g.addColorStop(0, COLORS.bubbleFill);
    g.addColorStop(1, "#DFF6F0");
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();

    // number
    ctx.fillStyle = COLORS.text;
    ctx.font = "bold 18px Arial";
    ctx.textAlign = "center";
    ctx.fillText(String(b.value), b.x, b.y + 6);

    // tiny spark if returning
    if (b.returning) {
      ctx.fillStyle = COLORS.spark;
      ctx.beginPath();
      ctx.arc(b.x + b.radius - 6, b.y - b.radius + 6, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawCollector() {
    ctx.save();
    // collector base
    ctx.fillStyle = COLORS.collector;
    roundRect(ctx, collector.x - collector.width / 2, collector.y - collector.height / 2, collector.width, collector.height, 10);
    ctx.fill();

    // cute face
    ctx.fillStyle = "#fff";
    circle(ctx, collector.x - 24, collector.y - 6, 6);
    circle(ctx, collector.x - 10, collector.y - 6, 6);
    ctx.fillStyle = "#05386B";
    circle(ctx, collector.x - 24, collector.y - 6, 2);
    circle(ctx, collector.x - 10, collector.y - 6, 2);
    ctx.strokeStyle = "#05386B";
    ctx.beginPath();
    ctx.moveTo(collector.x - 18, collector.y + 0);
    ctx.quadraticCurveTo(collector.x - 14, collector.y + 10, collector.x - 6, collector.y + 0);
    ctx.stroke();

    // display carried number
    if (collector.carrying) {
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(collector.x + 26, collector.y - 6, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = COLORS.text;
      ctx.font = "bold 14px Arial";
      ctx.fillText(String(collector.carrying.value), collector.x + 26, collector.y - 2);
    }

    ctx.restore();
  }

  function drawHUD() {
    ctx.save();
    ctx.fillStyle = COLORS.text;
    ctx.font = "16px Arial";
    ctx.textAlign = "left";
    ctx.fillText(`Score: ${score}`, 20, 30);
    ctx.fillText(`Lives: ${lives}`, 20, 52);
    ctx.fillText(`Level: ${level}`, 140, 30);
    ctx.font = "12px Arial";
    ctx.fillStyle = "#27496D";
    ctx.fillText(`Move: ← →  or mouse • Catch: move into charge • Send: 1-4 or click a bulb`, 20, 74);
    ctx.restore();
  }

  function drawMessages() {
    ctx.save();
    for (let m of messages) {
      const age = performance.now() - m.created;
      const alpha = 1 - age / m.life;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = m.color;
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.fillText(m.text, m.x, m.y - age / 30);
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawIntro() {
    // show start instructions and static scene
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawTopPanel();
    drawCollector();
    initBulbs();
    for (let i = 0; i < bulbs.length; i++) {
      drawBulb(bulbs[i], i);
    }
    ctx.save();
    ctx.fillStyle = COLORS.text;
    ctx.font = "20px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Click or press any key to begin", WIDTH / 2, HEIGHT / 2 + 20);
    ctx.font = "14px Arial";
    ctx.fillText("Use arrows or mouse to move. Catch number charges and press 1-4 to send them to bulbs.", WIDTH / 2, HEIGHT / 2 + 46);
    ctx.restore();
  }

  // Drawing helpers
  function circle(ctx, x, y, r) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
  }
  function roundRect(ctx, x, y, w, h, r) {
    const radius = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  // Toggle mute
  function toggleMute() {
    muted = !muted;
    if (muted) {
      stopBackgroundHum();
      playBeep("wrong"); // small click to indicate
      announce("Audio muted");
    } else {
      // resume audio
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch((err) => {
          console.warn("Audio resume failed:", err);
        });
      }
      startBackgroundHum();
      playBeep("correct");
      announce("Audio unmuted");
    }
  }

  // Initialize and draw initial screen
  initBulbs();
  drawIntro();

  // Provide instructions in SR for initial state
  announce("Electric Math ready. Click or press any key to start.");

  // Expose some debugging to window (optional, harmless)
  window.__electricMath = {
    startGame,
    endGame,
    toggleMute,
  };
})();
---

