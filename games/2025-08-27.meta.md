# Game of the Day - 2025-08-27

## Metadata
- **Generated Date:** 2025-08-27
- **Generated Time:** 2025-08-27T00:22:14.035164
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-27.js
- **File Size:** 29105 bytes
- **Tokens Used:** 9592

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-27.js` - The playable game
- `2025-08-27.meta.json` - Machine-readable metadata
- `2025-08-27.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18823

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20295

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Educational Math Game: "Zap the Sum"
  // Ages 7-9. Theme: Electricity. Math focus: addition (subset-sum to target).
  // Renders inside element with id "game-of-the-day-stage".
  // Canvas 720x480. All graphics drawn with canvas methods.
  // Sounds synthesized with Web Audio API. Accessible live text via aria-live region.

  // ---------- Basic setup ----------
  const STAGE_ID = "game-of-the-day-stage";
  const WIDTH = 720;
  const HEIGHT = 480;

  const stageEl = document.getElementById(STAGE_ID);
  if (!stageEl) {
    console.error(`Element with id "${STAGE_ID}" not found.`);
    return;
  }

  // Clear stage element
  stageEl.innerHTML = "";
  stageEl.style.position = "relative";
  stageEl.style.userSelect = "none";

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make focusable for keyboard
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Zap the Sum math game. Use mouse or keyboard to play.");
  canvas.style.outline = "none";
  canvas.style.display = "block";
  canvas.style.margin = "0";
  canvas.style.background = "#091827"; // dark blue background for contrast
  stageEl.appendChild(canvas);

  const ctx = canvas.getContext("2d", { alpha: false });

  // Accessible live region for screen readers and text alternatives
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.setAttribute("role", "status");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  liveRegion.style.width = "1px";
  liveRegion.style.height = "1px";
  liveRegion.style.overflow = "hidden";
  stageEl.appendChild(liveRegion);

  // Size and layout constants
  const HUD_HEIGHT = 120;
  const GAME_Y = HUD_HEIGHT;
  const GAME_HEIGHT = HEIGHT - HUD_HEIGHT;

  // ---------- Utility ----------
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }
  function arraySum(arr) {
    return arr.reduce((s, v) => s + v, 0);
  }

  // ---------- Accessibility text updates ----------
  function announce(text) {
    liveRegion.textContent = text;
  }

  // ---------- Audio Manager ----------
  class AudioManager {
    constructor() {
      this.ctx = null;
      this.backgroundGain = null;
      this.backgroundOsc = null;
      this.enabled = false;
      this.available = true;
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) {
          this.available = false;
          console.warn("Web Audio API is not supported in this browser.");
          return;
        }
        // Do not instantiate context until user gesture; created on first enable.
      } catch (e) {
        this.available = false;
        console.error("Error checking Web Audio API:", e);
      }
    }

    async init() {
      if (!this.available) return;
      if (this.ctx) return;
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioCtx();
        // Start a gentle background hum but paused until enabled
        this.backgroundGain = this.ctx.createGain();
        this.backgroundGain.gain.value = 0.0;
        this.backgroundGain.connect(this.ctx.destination);

        this.backgroundOsc = this.ctx.createOscillator();
        this.backgroundOsc.type = "sine";
        this.backgroundOsc.frequency.value = 55; // low hum
        // Add a subtle filter
        const filter = this.ctx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = 600;
        this.backgroundOsc.connect(filter);
        filter.connect(this.backgroundGain);
        this.backgroundOsc.start();

      } catch (err) {
        this.available = false;
        console.error("Failed creating AudioContext:", err);
      }
    }

    async enable() {
      if (!this.available) return false;
      try {
        await this.init();
        // Some browsers require resume() on gesture
        if (this.ctx.state === "suspended") {
          await this.ctx.resume();
        }
        this.enabled = true;
        if (this.backgroundGain) {
          // gently raise hum
          this.backgroundGain.gain.cancelScheduledValues(this.ctx.currentTime);
          this.backgroundGain.gain.setValueAtTime(0.0, this.ctx.currentTime);
          this.backgroundGain.gain.linearRampToValueAtTime(0.03, this.ctx.currentTime + 1.0);
        }
        return true;
      } catch (err) {
        console.error("Audio enable error:", err);
        this.enabled = false;
        return false;
      }
    }

    disable() {
      if (!this.available || !this.ctx) return;
      this.enabled = false;
      if (this.backgroundGain) {
        this.backgroundGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.backgroundGain.gain.setValueAtTime(this.backgroundGain.gain.value, this.ctx.currentTime);
        this.backgroundGain.gain.linearRampToValueAtTime(0.0, this.ctx.currentTime + 0.3);
      }
    }

    // Short success melody: ascending notes
    playSuccess() {
      if (!this.available || !this.enabled || !this.ctx) return;
      try {
        const now = this.ctx.currentTime;
        const g = this.ctx.createGain();
        g.connect(this.ctx.destination);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);

        const osc = this.ctx.createOscillator();
        osc.type = "sine";
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.linearRampToValueAtTime(660, now + 0.25);
        osc.connect(g);
        osc.start(now);
        osc.stop(now + 0.5);

      } catch (err) {
        console.warn("playSuccess error", err);
      }
    }

    // Short incorrect buzz
    playFail() {
      if (!this.available || !this.enabled || !this.ctx) return;
      try {
        const now = this.ctx.currentTime;
        const g = this.ctx.createGain();
        g.connect(this.ctx.destination);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.09, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);

        const osc = this.ctx.createOscillator();
        osc.type = "square";
        osc.frequency.setValueAtTime(120, now);
        const filt = this.ctx.createBiquadFilter();
        filt.type = "lowpass";
        filt.frequency.setValueAtTime(600, now);
        osc.connect(filt);
        filt.connect(g);
        // little pitch wobble
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.linearRampToValueAtTime(90, now + 0.15);

        osc.start(now);
        osc.stop(now + 0.35);
      } catch (err) {
        console.warn("playFail error", err);
      }
    }

    // gentle click for selection
    playClick() {
      if (!this.available || !this.enabled || !this.ctx) return;
      try {
        const now = this.ctx.currentTime;
        const g = this.ctx.createGain();
        g.connect(this.ctx.destination);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.06, now + 0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);

        const osc = this.ctx.createOscillator();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(880, now);
        osc.connect(g);
        osc.start(now);
        osc.stop(now + 0.15);
      } catch (err) {
        console.warn("playClick error", err);
      }
    }
  }

  const audio = new AudioManager();

  // ---------- Game Entities ----------
  class Battery {
    constructor(x, y, value, id) {
      this.x = x;
      this.y = y;
      this.w = 120;
      this.h = 64;
      this.value = value;
      this.id = id;
      this.selected = false;
      this.hover = false;
      this.pulse = 0; // for animation
    }

    contains(px, py) {
      return px >= this.x && px <= this.x + this.w && py >= this.y && py <= this.y + this.h;
    }

    toggleSelected() {
      this.selected = !this.selected;
      this.pulse = 1.0;
    }

    draw(ctx) {
      // Battery body
      ctx.save();
      ctx.translate(this.x, this.y);
      // Outer rounded rect
      ctx.beginPath();
      roundRectPath(ctx, 0, 0, this.w, this.h, 12);
      ctx.fillStyle = this.selected ? "#FFD166" : this.hover ? "#8FD3FF" : "#FFFFFF";
      ctx.fill();
      // Outline
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#072A40";
      ctx.stroke();

      // Terminals: little prongs
      ctx.fillStyle = "#072A40";
      ctx.fillRect(this.w - 10, this.h / 2 - 6, 8, 12);

      // Number big
      ctx.fillStyle = "#072A40";
      ctx.font = "bold 32px 'Arial'";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(this.value.toString(), this.w / 2, this.h / 2);

      // tiny label
      ctx.font = "12px 'Arial'";
      ctx.textAlign = "left";
      ctx.fillStyle = "#072A40";
      ctx.fillText("mAh", 8, this.h - 8);

      // glow pulse if selected
      if (this.selected || this.pulse > 0) {
        ctx.beginPath();
        ctx.arc(this.w / 2, -8, 28 + this.pulse * 6, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,210,100,${0.08 + this.pulse * 0.15})`;
        ctx.fill();
      }

      ctx.restore();
    }

    update(dt) {
      if (this.pulse > 0) {
        this.pulse = Math.max(0, this.pulse - dt * 2);
      }
    }
  }

  // RoundRect helper
  function roundRectPath(ctx, x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Characters (drawn each frame). A friendly bulb "Dr. Amp" and a spark "Sparkle".
  function drawDrAmp(ctx, x, y, mood = "happy") {
    ctx.save();
    ctx.translate(x, y);
    // Bulb glass
    ctx.beginPath();
    ctx.ellipse(0, -28, 34, 38, 0, 0, Math.PI * 2);
    const g = ctx.createRadialGradient(-10, -34, 6, 0, -28, 60);
    g.addColorStop(0, "#FFF7C2");
    g.addColorStop(1, "#FFD166");
    ctx.fillStyle = g;
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#8A5A00";
    ctx.stroke();

    // Filament
    ctx.beginPath();
    ctx.moveTo(-12, -20);
    ctx.quadraticCurveTo(0, -10 + (mood === "sad" ? 4 : 0), 12, -20);
    ctx.strokeStyle = "#FFD166";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Base
    ctx.fillStyle = "#6C7A89";
    ctx.fillRect(-22, 4, 44, 18);
    ctx.strokeRect(-22, 4, 44, 18);

    // Face
    ctx.fillStyle = "#072A40";
    ctx.beginPath();
    ctx.arc(-8, -30, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(8, -30, 4, 0, Math.PI * 2);
    ctx.fill();

    // mouth
    ctx.beginPath();
    if (mood === "happy") ctx.arc(0, -14, 8, 0, Math.PI, false);
    else if (mood === "surprised") {
      ctx.arc(0, -14, 5, 0, Math.PI * 2);
    } else {
      ctx.arc(0, -12, 8, 0, Math.PI, true);
    }
    ctx.stroke();

    ctx.restore();
  }

  function drawSpark(ctx, x, y, t) {
    ctx.save();
    ctx.translate(x, y);
    // wacky star shape
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const r = i % 2 === 0 ? 12 : 6;
      const px = Math.cos(angle) * r;
      const py = Math.sin(angle) * r;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    const hue = 50 + Math.sin(t * 6) * 10;
    ctx.fillStyle = `hsl(${hue} 90% 60%)`;
    ctx.shadowColor = "rgba(255,215,90,0.6)";
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;

    // eyes
    ctx.fillStyle = "#072A40";
    ctx.fillRect(-4, -2, 3, 3);
    ctx.fillRect(2, -2, 3, 3);

    ctx.restore();
  }

  // ---------- Game Logic ----------
  class Game {
    constructor(ctx) {
      this.ctx = ctx;
      this.batteries = [];
      this.target = 0;
      this.level = 1;
      this.score = 0;
      this.lives = 3;
      this.selectionIndex = 0;
      this.lastTick = performance.now();
      this.running = true;
      this.hintTimer = 0;
      this.feedbackText = "";
      this.feedbackTimer = 0;
      this.audioOn = false;
      this.mouse = { x: 0, y: 0, down: false };
      this.time = 0;
      this.generateRound();

      // Input
      canvas.addEventListener("keydown", (e) => this.onKeyDown(e));
      canvas.addEventListener("mousemove", (e) => this.onMouseMove(e));
      canvas.addEventListener("mousedown", (e) => this.onMouseDown(e));
      canvas.addEventListener("mouseup", (e) => this.onMouseUp(e));
      canvas.addEventListener("mouseleave", (e) => this.onMouseLeave(e));
      canvas.addEventListener("click", (e) => {
        // On first click, try to enable audio (gesture)
        if (!audio.enabled && audio.available) {
          audio.enable().then((ok) => {
            this.audioOn = ok;
            this.updateAnnounce();
          });
        }
      });

      // Touch also maps to mouse (basic)
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        this.onMouseMove({ clientX: t.clientX, clientY: t.clientY });
        this.onMouseDown({ clientX: t.clientX, clientY: t.clientY });
      }, { passive: false });
      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        this.onMouseUp({});
      });

      // Initial announcement
      announce("Welcome! Help Dr. Amp light the lamp by selecting batteries that add up to the target. Use mouse or keyboard. Press A to toggle audio.");
      this.updateAnnounce();
    }

    generateRound() {
      // create a solvable set of 4 batteries by first selecting 2-3 random numbers to sum to target
      const nPick = randInt(2, 3);
      const chosen = [];
      while (chosen.length < nPick) {
        const v = randInt(1, 9);
        if (!chosen.includes(v)) chosen.push(v);
      }
      const targetSum = arraySum(chosen);
      // add distractors to total 4 batteries
      const batteries = [...chosen];
      while (batteries.length < 4) {
        const cand = randInt(1, 9);
        // allow duplicates sometimes but try not to have exact duplicates of chosen unless needed
        if (batteries.length < 3 || Math.random() > 0.3) {
          batteries.push(cand);
        }
      }
      // Shuffle and create Battery objects
      batteries.sort(() => Math.random() - 0.5);
      this.batteries = [];
      const startX = 48;
      const gap = 28;
      for (let i = 0; i < 4; i++) {
        const bx = startX + i * (120 + gap);
        const by = GAME_Y + 28;
        this.batteries.push(new Battery(bx, by, batteries[i], i));
      }
      this.target = targetSum;
      this.selectionIndex = 0;
      this.feedbackText = "";
      this.feedbackTimer = 0;
      this.hintTimer = 5.0;
      this.time = 0;

      announce(`Level ${this.level}. Target ${this.target} volts. Select batteries to add to ${this.target}.`);
      this.updateAnnounce();
    }

    updateAnnounce() {
      const selectedVals = this.batteries.filter(b => b.selected).map(b => b.value);
      const sum = arraySum(selectedVals);
      const audioText = audio.available ? (this.audioOn ? "Audio on." : "Audio off. Press A to enable.") : "Audio not available.";
      announce(`Target ${this.target}. Selected ${selectedVals.join(", ") || "none"}. Sum ${sum}. ${audioText} Score ${this.score}. Lives ${this.lives}.`);
    }

    onKeyDown(e) {
      if (!this.running) return;
      if (e.key === "ArrowRight") {
        this.selectionIndex = (this.selectionIndex + 1) % this.batteries.length;
        audio.playClick();
        this.updateAnnounce();
      } else if (e.key === "ArrowLeft") {
        this.selectionIndex = (this.selectionIndex - 1 + this.batteries.length) % this.batteries.length;
        audio.playClick();
        this.updateAnnounce();
      } else if (e.key === " " || e.key === "Enter") {
        // toggle selected
        this.toggleBattery(this.selectionIndex);
      } else if (e.key >= "1" && e.key <= "4") {
        const idx = Number(e.key) - 1;
        if (idx >= 0 && idx < this.batteries.length) this.toggleBattery(idx);
      } else if (e.key.toLowerCase() === "a") {
        // toggle audio
        if (!audio.available) {
          announce("Audio is not supported in this browser.");
        } else {
          if (!audio.enabled) {
            audio.enable().then(ok => {
              this.audioOn = ok;
              announce(ok ? "Audio enabled." : "Audio could not be enabled.");
              this.updateAnnounce();
            });
          } else {
            audio.disable();
            this.audioOn = false;
            announce("Audio disabled.");
            this.updateAnnounce();
          }
        }
      }
    }

    toggleBattery(idx) {
      const b = this.batteries[idx];
      if (!b) return;
      b.toggleSelected();
      audio.playClick();
      this.updateAnnounce();
      // Check sum
      const selectedVals = this.batteries.filter(b => b.selected).map(b => b.value);
      const sum = arraySum(selectedVals);
      if (sum === this.target) {
        // success
        this.onSuccess();
      } else if (sum > this.target) {
        // immediate negative feedback
        this.onOver();
      }
    }

    onSuccess() {
      audio.playSuccess();
      this.feedbackText = "Zap! Perfect match!";
      this.feedbackTimer = 2.0;
      this.score += 10 * this.level;
      this.level += 1;
      // small celebration; regenerate after short delay
      setTimeout(() => {
        this.generateRound();
      }, 900);
      this.updateAnnounce();
    }

    onOver() {
      audio.playFail();
      this.feedbackText = "Too much! Try again or unselect a battery.";
      this.feedbackTimer = 2.0;
      this.lives -= 1;
      if (this.lives <= 0) {
        this.onGameOver();
      } else {
        this.updateAnnounce();
      }
    }

    onGameOver() {
      this.running = false;
      this.feedbackText = "Oh no — the circuit fizzled out! Game over. Press R to restart.";
      this.feedbackTimer = 6.0;
      announce(`Game over. Your score ${this.score}. Press R to restart.`);
      // Listen for restart
      const restartHandler = (e) => {
        if (e.key.toLowerCase() === "r") {
          window.removeEventListener("keydown", restartHandler);
          this.reset();
        }
      };
      window.addEventListener("keydown", restartHandler);
    }

    reset() {
      this.level = 1;
      this.score = 0;
      this.lives = 3;
      this.running = true;
      this.generateRound();
    }

    onMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX || 0) - rect.left;
      const my = (e.clientY || 0) - rect.top;
      this.mouse.x = mx;
      this.mouse.y = my;
      // update hover states
      for (const b of this.batteries) {
        b.hover = b.contains(mx, my);
      }
      // check if hovering audio icon or speaker etc (we'll use click)
    }

    onMouseDown(e) {
      this.mouse.down = true;
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX || 0) - rect.left;
      const my = (e.clientY || 0) - rect.top;
      // check battery clicked
      for (let i = 0; i < this.batteries.length; i++) {
        const b = this.batteries[i];
        if (b.contains(mx, my)) {
          this.selectionIndex = i;
          this.toggleBattery(i);
          return;
        }
      }
      // check speaker icon area top-right 44x44
      if (mx > WIDTH - 54 && my < 54) {
        // toggle audio
        if (!audio.available) {
          announce("Audio not available on this device.");
        } else {
          if (!audio.enabled) {
            audio.enable().then(ok => {
              this.audioOn = ok;
              announce(ok ? "Audio enabled." : "Audio could not be enabled.");
              this.updateAnnounce();
            });
          } else {
            audio.disable();
            this.audioOn = false;
            announce("Audio disabled.");
            this.updateAnnounce();
          }
        }
      }
    }

    onMouseUp(e) {
      this.mouse.down = false;
    }

    onMouseLeave(e) {
      this.mouse.down = false;
      for (const b of this.batteries) b.hover = false;
    }

    update(dt) {
      this.time += dt;
      for (const b of this.batteries) b.update(dt);
      if (this.feedbackTimer > 0) this.feedbackTimer = Math.max(0, this.feedbackTimer - dt);
      if (this.hintTimer > 0) this.hintTimer = Math.max(0, this.hintTimer - dt);

      // subtle animated spark near lamp if partially correct
      // no additional logic needed here for now
    }

    draw() {
      // Clear with calming gradient background
      const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
      g.addColorStop(0, "#091827");
      g.addColorStop(1, "#0f2540");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // Draw top HUD area with target and characters
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.02)";
      ctx.fillRect(0, 0, WIDTH, HUD_HEIGHT);
      ctx.restore();

      // Draw Dr. Amp on left
      drawDrAmp(ctx, 72, HUD_HEIGHT / 2 + 8, this.feedbackText.includes("Too") ? "sad" : "happy");

      // Draw lamp and wire in center HUD
      const lampX = WIDTH / 2;
      const lampY = HUD_HEIGHT / 2 + 8;
      // Wire
      ctx.beginPath();
      ctx.moveTo(160, lampY + 40);
      ctx.quadraticCurveTo(lampX, lampY + 120, WIDTH - 160, lampY + 40);
      ctx.lineWidth = 6;
      ctx.strokeStyle = "#3ddc84";
      ctx.stroke();

      // Target lamp
      ctx.save();
      ctx.translate(lampX, lampY);
      // lamp stand
      ctx.fillStyle = "#30475e";
      ctx.fillRect(-30, 36, 60, 10);

      // bulb
      ctx.beginPath();
      ctx.ellipse(0, 0, 48, 60, 0, 0, Math.PI * 2);
      const lit = arraySum(this.batteries.filter(b => b.selected).map(b => b.value)) === this.target;
      const bulbGradient = ctx.createRadialGradient(-12, -10, 6, 0, 0, 90);
      bulbGradient.addColorStop(0, lit ? "#FFFAD1" : "#C9E6FF");
      bulbGradient.addColorStop(1, lit ? "#FFD166" : "#6FA8DC");
      ctx.fillStyle = bulbGradient;
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#072A40";
      ctx.stroke();

      // Lamp face
      ctx.fillStyle = "#072A40";
      ctx.beginPath();
      ctx.arc(-12, -8, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(12, -8, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      if (lit) ctx.arc(0, 8, 8, 0, Math.PI, false);
      else ctx.arc(0, 12, 8, 0, Math.PI, true);
      ctx.stroke();

      // Target text on lamp
      ctx.fillStyle = "#072A40";
      ctx.font = "bold 18px Arial";
      ctx.textAlign = "center";
      ctx.fillText(`${this.target} V`, 0, 28);

      ctx.restore();

      // Draw batteries
      for (let i = 0; i < this.batteries.length; i++) {
        const b = this.batteries[i];
        // Slight hover bounce
        const hoverOffset = b.hover ? -4 : 0;
        b.y = GAME_Y + 28 + hoverOffset;
        b.draw(ctx);
        // Draw selection outline if current keyboard selection
        if (i === this.selectionIndex) {
          ctx.save();
          ctx.strokeStyle = "#FFD166";
          ctx.lineWidth = 3;
          ctx.beginPath();
          roundRectPath(ctx, b.x - 6, b.y - 6, b.w + 12, b.h + 12, 14);
          ctx.stroke();
          ctx.restore();
        }
      }

      // HUD right-side: score, lives, audio icon
      ctx.save();
      ctx.fillStyle = "#FFFFFF";
      ctx.font = "bold 18px Arial";
      ctx.textAlign = "right";
      ctx.fillText(`Score: ${this.score}`, WIDTH - 12, 26);
      ctx.fillText(`Lives: ${this.lives}`, WIDTH - 12, 52);
      ctx.restore();

      // Audio icon top-right
      ctx.save();
      const spX = WIDTH - 32;
      const spY = 32;
      ctx.translate(spX, spY);
      // speaker shape
      ctx.fillStyle = audio.available ? (audio.enabled && this.audioOn ? "#3ddc84" : "#FFFFFF") : "#888888";
      ctx.beginPath();
      ctx.moveTo(-12, -10);
      ctx.lineTo(-2, -10);
      ctx.lineTo(6, -16);
      ctx.lineTo(6, 16);
      ctx.lineTo(-2, 10);
      ctx.lineTo(-12, 10);
      ctx.closePath();
      ctx.fill();

      if (!audio.available) {
        // X overlay
        ctx.strokeStyle = "#ff7b7b";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-18, -18);
        ctx.lineTo(18, 18);
        ctx.moveTo(18, -18);
        ctx.lineTo(-18, 18);
        ctx.stroke();
      } else if (!audio.enabled) {
        // small mute slash
        ctx.strokeStyle = "#072A40";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(12, -12);
        ctx.lineTo(18, -18);
        ctx.stroke();
      } else {
        // sound waves
        ctx.strokeStyle = "#3ddc84";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(12, 0, 6, -0.6, 0.6);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(12, 0, 10, -0.6, 0.6);
        ctx.stroke();
      }

      ctx.restore();

      // Draw live instruction text on HUD bottom-left
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "14px Arial";
      ctx.textAlign = "left";
      const instr = "Click batteries or use ← → and Enter to select. Reach the target voltage.";
      ctx.fillText(instr, 12, HUD_HEIGHT - 8);
      ctx.restore();

      // Feedback bubble near Dr. Amp
      if (this.feedbackTimer > 0) {
        ctx.save();
        const bx = 160;
        const by = 44;
        // bubble
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        roundRectDraw(ctx, bx, by, 320, 40, 10, "#072A40");
        ctx.fillStyle = "#072A40";
        ctx.font = "bold 15px Arial";
        ctx.textAlign = "left";
        ctx.fillText(this.feedbackText, bx + 10, by + 24);
        ctx.restore();
      }

      // small spark characters across HUD
      drawSpark(ctx, WIDTH - 120, HUD_HEIGHT / 2 - 6, this.time);
      drawSpark(ctx, 120, HUD_HEIGHT / 2 - 14, this.time + 0.6);

      // Draw subtle grid and decorative wacky elements in game area
      ctx.save();
      ctx.translate(0, GAME_Y);
      // floating dashed lines (wires)
      ctx.strokeStyle = "rgba(255,255,255,0.03)";
      ctx.lineWidth = 1;
      for (let i = 20; i < WIDTH; i += 60) {
        ctx.setLineDash([6, 8]);
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i - 20, GAME_HEIGHT);
        ctx.stroke();
      }
      ctx.setLineDash([]);
      ctx.restore();

      // bottom-right hint box (if needed)
      if (this.hintTimer < 4.0) {
        ctx.save();
        const hx = WIDTH - 260;
        const hy = HEIGHT - 88;
        roundRectDraw(ctx, hx, hy, 240, 72, 12, "rgba(255,255,255,0.06)");
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "13px Arial";
        ctx.textAlign = "left";
        ctx.fillText("Hint: Try combining batteries to make the target!", hx + 12, hy + 28);
        ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.font = "12px Arial";
        ctx.fillText("Select/unselect to change the sum.", hx + 12, hy + 48);
        ctx.restore();
      }

      // If game over draw overlay
      if (!this.running) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = "#FFD166";
        ctx.font = "bold 36px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Circuit Fizzled!", WIDTH / 2, HEIGHT / 2 - 6);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "20px Arial";
        ctx.fillText(`Score: ${this.score}`, WIDTH / 2, HEIGHT / 2 + 28);
        ctx.restore();
      }
    }
  }

  function roundRectDraw(ctx, x, y, w, h, r, fillStyle) {
    ctx.beginPath();
    roundRectPath(ctx, x, y, w, h, r);
    ctx.fillStyle = fillStyle;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.stroke();
  }

  // ---------- Main Loop ----------
  const game = new Game(ctx);

  function loop(now) {
    const dt = Math.min(0.05, (now - game.lastTick) / 1000);
    game.lastTick = now;
    if (game.running) game.update(dt);
    game.draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame((t) => {
    game.lastTick = t;
    requestAnimationFrame(loop);
  });

  // Focus canvas for keyboard events
  canvas.addEventListener("focus", () => {
    // draw focus ring visually as well
  });
  canvas.addEventListener("blur", () => {});

  // Expose a few helpful console actions for debugging (non-essential)
  window.__zapTheSum = {
    audio,
    game,
  };

  // Error handling: ensure audio context creation errors are shown gently
  if (!audio.available) {
    announce("Audio unavailable — sounds are disabled. Use keyboard or mouse to play.");
  }

  // Provide clear instructions visually (redraw will keep them)
  // End of script
})();
---

