{
  "generated_date": "2025-08-12",
  "generated_timestamp": "2025-08-12T00:22:33.914075",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 11583,
  "game_filename": "2025-08-12.js",
  "game_size_bytes": 35686,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Electricity-themed Math Game for ages 7-9\n// Renders inside element with ID \"game-of-the-day-stage\" using a 720x480 canvas.\n// All visuals are drawn on canvas. All sounds generated with Web Audio API.\n// Accessible via keyboard, includes aria-label instructions on canvas.\n\n// Immediately-invoked function to avoid polluting global scope\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const CONTAINER_ID = 'game-of-the-day-stage';\n\n  // Utility: safe query and canvas setup\n  const container = document.getElementById(CONTAINER_ID);\n  if (!container) {\n    console.error(`Container element with id \"${CONTAINER_ID}\" not found.`);\n    return;\n  }\n  // Clear container\n  container.innerHTML = '';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make focusable for keyboard controls\n  canvas.style.outline = 'none';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label',\n    'Sparky the Squirrel needs help powering houses! ' +\n    'Use mouse or keyboard to pick battery cards (numbers) and drop them onto bulbs to match target sums. ' +\n    'Arrow keys to select, Enter to pick/place, Space to toggle sound. ' +\n    'Solve all bulbs to finish the level.'\n  );\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // Accessibility: live text fallback if available\n  try {\n    const live = document.createElement('div');\n    live.setAttribute('aria-live', 'polite');\n    live.style.position = 'absolute';\n    live.style.left = '-9999px';\n    live.style.width = '1px';\n    live.style.height = '1px';\n    live.style.overflow = 'hidden';\n    container.appendChild(live);\n    var liveRegion = live;\n  } catch (e) {\n    var liveRegion = null;\n  }\n\n  // Audio setup with error handling\n  let audioEnabled = true;\n  let audioCtx = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContext) {\n      audioEnabled = false;\n      throw new Error('Web Audio API not supported.');\n    }\n    audioCtx = new AudioContext();\n  } catch (err) {\n    console.warn('Audio context could not be created:', err);\n    audioEnabled = false;\n  }\n\n  // We'll not start background oscillators until user interacts due to autoplay rules\n  let audioSuspended = audioEnabled && audioCtx && audioCtx.state === 'suspended';\n\n  // Master gain for controlling overall volume\n  let masterGain = null;\n  if (audioEnabled && audioCtx) {\n    try {\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.18; // gentle volume\n      masterGain.connect(audioCtx.destination);\n    } catch (e) {\n      console.warn('Audio master gain error:', e);\n      audioEnabled = false;\n      masterGain = null;\n    }\n  }\n\n  // Background hum oscillator (gentle)\n  let humOsc = null;\n  let humStarted = false;\n  function startBackgroundHum() {\n    if (!audioEnabled || !audioCtx || !masterGain || humStarted) return;\n    try {\n      humOsc = audioCtx.createOscillator();\n      const humGain = audioCtx.createGain();\n      humOsc.type = 'sine';\n      humOsc.frequency.value = 60; // 60 Hz hum - subtle\n      humGain.gain.value = 0.02;\n      humOsc.connect(humGain);\n      // gentle low-pass\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = 400;\n      humGain.connect(filter);\n      filter.connect(masterGain);\n      humOsc.start();\n      humStarted = true;\n    } catch (e) {\n      console.warn('background hum failed to start:', e);\n    }\n  }\n\n  // Sound helpers: play beep, chime, buzz, spark\n  function playBeep(freq = 880, duration = 0.18, type = 'sine') {\n    if (!audioEnabled || !audioCtx || !masterGain) return Promise.resolve();\n    try {\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = type;\n      osc.frequency.value = freq;\n      // envelope\n      gain.gain.value = 0.0001;\n      osc.connect(gain);\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = Math.max(600, freq * 1.2);\n      gain.connect(filter);\n      filter.connect(masterGain);\n      const now = audioCtx.currentTime;\n      gain.gain.cancelScheduledValues(now);\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(0.18, now + 0.02);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      osc.start(now);\n      osc.stop(now + duration + 0.02);\n      return new Promise((resolve) => {\n        osc.onended = resolve;\n      });\n    } catch (e) {\n      console.warn('beep failed:', e);\n    }\n    return Promise.resolve();\n  }\n\n  function playChime() {\n    if (!audioEnabled) return;\n    // A little harmony arpeggio\n    const freqs = [880, 660, 990];\n    let t = 0;\n    freqs.forEach((f, i) => {\n      setTimeout(() => {\n        playBeep(f, 0.18, 'triangle');\n      }, i * 140);\n    });\n  }\n\n  function playBuzz() {\n    if (!audioEnabled) return;\n    try {\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      osc.type = 'square';\n      osc.frequency.value = 120;\n      gain.gain.value = 0.0001;\n      osc.connect(filter);\n      filter.connect(masterGain);\n      filter.frequency.value = 800;\n      const now = audioCtx.currentTime;\n      gain.connect(filter);\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);\n      osc.connect(gain);\n      osc.start(now);\n      osc.stop(now + 0.18);\n    } catch (e) {\n      console.warn('buzz failed:', e);\n    }\n  }\n\n  function playSpark() {\n    if (!audioEnabled) return;\n    try {\n      const now = audioCtx.currentTime;\n      const length = 0.06;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = 'sawtooth';\n      osc.frequency.setValueAtTime(1200, now);\n      osc.frequency.exponentialRampToValueAtTime(300, now + length);\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(0.18, now + length * 0.4);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + length);\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = 'highpass';\n      filter.frequency.value = 800;\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(masterGain);\n      osc.start(now);\n      osc.stop(now + length + 0.02);\n    } catch (e) {\n      console.warn('spark failed:', e);\n    }\n  }\n\n  // Game objects and logic\n  const state = {\n    level: 1,\n    score: 0,\n    bulbs: [], // {x,y,target,connectedBatteries:[],lit:boolean}\n    batteries: [], // {x,y,value,placedOn:bulbIndex or null, id}\n    selectedBatteryIndex: 0, // keyboard focus index\n    holdingBattery: null, // id of battery being held\n    draggingBatteryId: null,\n    mouse: { x: 0, y: 0, down: false },\n    hintVisible: true,\n    soundOn: !!audioEnabled,\n    message: '',\n    messageTimer: 0,\n    roundActive: true\n  };\n\n  // Layout constants\n  const leftArea = { x: 20, y: 90, w: 220, h: 360 };\n  const rightArea = { x: 260, y: 60, w: 440, h: 400 };\n\n  // Character definitions for fun\n  const characters = {\n    sparky: { // squirrel electrician\n      x: 130, y: 420, scale: 0.9\n    },\n    volt: { // friendly lightbulb mascot\n      x: 600, y: 420, scale: 1.0\n    }\n  };\n\n  // Helpers for random generation\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Initialize a new level\n  function initLevel(level = 1) {\n    state.level = level;\n    state.score = 0;\n    state.bulbs = [];\n    state.batteries = [];\n    state.selectedBatteryIndex = 0;\n    state.holdingBattery = null;\n    state.draggingBatteryId = null;\n    state.message = '';\n    state.messageTimer = 0;\n    state.roundActive = true;\n    // number of bulbs increases slowly\n    const bulbCount = Math.min(4, 2 + Math.floor((level - 1) / 2));\n    // generate target sums for bulbs 5..15 appropriate to ages 7-9\n    const targets = [];\n    for (let i = 0; i < bulbCount; i++) {\n      targets.push(randInt(5, 15));\n    }\n    // place bulbs in right area\n    for (let i = 0; i < bulbCount; i++) {\n      const bx = rightArea.x + 80 + (i % 2) * 220;\n      const by = rightArea.y + 80 + Math.floor(i / 2) * 140;\n      state.bulbs.push({\n        x: bx,\n        y: by,\n        target: targets[i],\n        connectedBatteries: [],\n        lit: false,\n        glow: 0\n      });\n    }\n    // generate batteries: ensure solvability - create numbers that can combine to match targets\n    // We'll produce batteries that include the digits needed\n    let batteryValues = [];\n    // First ensure each bulb can be matched by picking at most 3 batteries of 1-9\n    for (let t of targets) {\n      // create 1 or 2 or 3 numbers that sum to t\n      const parts = randInt(1, 3);\n      let remaining = t;\n      const partsVals = [];\n      for (let p = parts; p >= 1; p--) {\n        let val;\n        if (p === 1) {\n          val = remaining;\n        } else {\n          // choose 1..min(9, remaining - (p-1)*1)\n          const maxVal = Math.min(9, remaining - (p - 1));\n          val = randInt(1, Math.max(1, maxVal));\n        }\n        partsVals.push(val);\n        remaining -= val;\n      }\n      batteryValues = batteryValues.concat(partsVals);\n    }\n    // Add a few distractor batteries\n    const targetBatteryCount = Math.max(6, batteryValues.length + 2);\n    while (batteryValues.length < targetBatteryCount) {\n      batteryValues.push(randInt(1, 9));\n    }\n    // shuffle\n    for (let i = batteryValues.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [batteryValues[i], batteryValues[j]] = [batteryValues[j], batteryValues[i]];\n    }\n    // Create battery objects placed in left area grid\n    const cols = 2;\n    const rows = Math.ceil(batteryValues.length / cols);\n    const spacingX = leftArea.w / cols;\n    const spacingY = Math.min(80, leftArea.h / rows);\n    for (let i = 0; i < batteryValues.length; i++) {\n      const col = i % cols;\n      const row = Math.floor(i / cols);\n      const bx = leftArea.x + spacingX * col + spacingX * 0.5;\n      const by = leftArea.y + spacingY * row + spacingY * 0.5;\n      state.batteries.push({\n        id: 'b' + i,\n        x: bx,\n        y: by,\n        baseX: bx,\n        baseY: by,\n        value: batteryValues[i],\n        placedOn: null,\n        pickedOffset: { x: 0, y: 0 },\n        wobble: Math.random() * Math.PI * 2\n      });\n    }\n\n    // announcement\n    announce(`Level ${level}. Help Sparky light ${state.bulbs.length} houses!`);\n  }\n\n  // Accessibility announcement helper\n  function announce(text) {\n    if (liveRegion) {\n      liveRegion.textContent = text;\n      setTimeout(() => {\n        liveRegion.textContent = '';\n      }, 2000);\n    }\n    state.message = text;\n    state.messageTimer = 160; // frames to display\n  }\n\n  // Drawing functions\n  function clearScreen() {\n    // calming gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#EAF6FF');\n    g.addColorStop(1, '#FFFDF6');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawHeader() {\n    ctx.save();\n    ctx.fillStyle = '#2a2a2a';\n    ctx.font = '18px \"Segoe UI\", Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Score: ${state.score}`, 12, 24);\n    ctx.fillText(`Level: ${state.level}`, 120, 24);\n    ctx.textAlign = 'center';\n    ctx.fillText('Electricity Math Lab \u2014 Connect batteries to match the bulb sums!', WIDTH / 2, 24);\n    ctx.restore();\n  }\n\n  function drawSoundIcon() {\n    ctx.save();\n    const x = WIDTH - 36;\n    const y = 20;\n    ctx.fillStyle = state.soundOn ? '#ffdd57' : '#ddd';\n    ctx.beginPath();\n    ctx.arc(x, y, 12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#444';\n    ctx.stroke();\n    ctx.fillStyle = '#222';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(state.soundOn ? '\u266a' : '\u2022', x, y);\n    ctx.restore();\n  }\n\n  // Draw left area with batteries\n  function drawBatteries() {\n    for (let i = 0; i < state.batteries.length; i++) {\n      const b = state.batteries[i];\n      // if placed font slightly smaller; if dragging, follow mouse\n      const isPicked = state.holdingBattery === b.id || state.draggingBatteryId === b.id;\n      const x = isPicked ? state.mouse.x + b.pickedOffset.x : b.x;\n      const y = isPicked ? state.mouse.y + b.pickedOffset.y : b.y;\n      b.drawX = x; b.drawY = y;\n      // card rectangle with playful edges\n      ctx.save();\n      // shadow\n      ctx.fillStyle = 'rgba(20,20,20,0.08)';\n      roundRect(ctx, x - 36, y - 28, 72, 56, 10, true, false);\n      // card\n      const cardColors = ['#fffef6', '#fff7f0', '#f0fff6', '#f7f5ff'];\n      const fill = cardColors[i % cardColors.length];\n      ctx.fillStyle = fill;\n      roundRect(ctx, x - 36, y - 28, 72, 56, 10, true, true);\n      // battery icon\n      ctx.fillStyle = '#222';\n      // small cap\n      ctx.fillRect(x + 24, y - 10, 6, 20);\n      // battery body stripes to indicate value visually\n      const val = b.value;\n      ctx.fillStyle = '#ffb74d';\n      ctx.fillRect(x - 24, y - 12, 40 * Math.min(1, val / 9), 24);\n      // number\n      ctx.font = '20px \"Segoe UI\", Arial';\n      ctx.fillStyle = '#222';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(b.value, x - 6, y);\n      // selection ring if keyboard focus\n      if (i === state.selectedBatteryIndex) {\n        ctx.strokeStyle = '#2b8cff';\n        ctx.lineWidth = 3;\n        roundRect(ctx, x - 40, y - 32, 80, 64, 12, false, false);\n      }\n      // opacity if placed\n      if (b.placedOn !== null) {\n        ctx.globalAlpha = 0.6;\n      }\n      ctx.restore();\n    }\n  }\n\n  // Draw bulbs and houses on right\n  function drawBulbs() {\n    for (let i = 0; i < state.bulbs.length; i++) {\n      const bulb = state.bulbs[i];\n      const x = bulb.x, y = bulb.y;\n      // house base\n      ctx.save();\n      ctx.fillStyle = '#fff';\n      ctx.strokeStyle = '#c7d7ff';\n      ctx.lineWidth = 2;\n      roundRect(ctx, x - 60, y + 30, 120, 70, 10, true, true);\n      // roof\n      ctx.fillStyle = '#ffd1dc';\n      ctx.beginPath();\n      ctx.moveTo(x - 70, y + 30);\n      ctx.lineTo(x, y - 10);\n      ctx.lineTo(x + 70, y + 30);\n      ctx.closePath();\n      ctx.fill();\n      ctx.stroke();\n      // bulb\n      // glow effect if lit\n      if (bulb.lit) {\n        bulb.glow = Math.min(1, bulb.glow + 0.06);\n      } else {\n        bulb.glow = Math.max(0, bulb.glow - 0.06);\n      }\n      const glow = bulb.glow;\n      if (glow > 0) {\n        const g2 = ctx.createRadialGradient(x, y - 10, 4, x, y - 10, 80);\n        g2.addColorStop(0, `rgba(255,250,200,${0.45 * glow})`);\n        g2.addColorStop(1, 'rgba(255,250,200,0)');\n        ctx.fillStyle = g2;\n        ctx.beginPath();\n        ctx.arc(x, y - 10, 80, 0, Math.PI * 2);\n        ctx.fill();\n      }\n      // bulb body\n      ctx.beginPath();\n      ctx.fillStyle = bulb.lit ? '#fff9c4' : '#fff';\n      ctx.arc(x, y - 10, 34, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = '#999';\n      ctx.stroke();\n\n      // filament/coils\n      ctx.beginPath();\n      ctx.strokeStyle = bulb.lit ? '#ffb300' : '#c0c0c0';\n      ctx.lineWidth = 2;\n      ctx.moveTo(x - 10, y - 2);\n      ctx.quadraticCurveTo(x, y + 10, x + 10, y - 2);\n      ctx.stroke();\n\n      // socket\n      ctx.fillStyle = '#cfcfcf';\n      ctx.fillRect(x - 18, y + 24, 36, 18);\n      ctx.strokeRect(x - 18, y + 24, 36, 18);\n\n      // show target number\n      ctx.fillStyle = '#333';\n      ctx.font = '20px \"Segoe UI\", Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(`Need ${bulb.target}`, x, y + 70);\n\n      // connected battery icons around the bulb\n      const count = bulb.connectedBatteries.length;\n      for (let j = 0; j < count; j++) {\n        const bid = bulb.connectedBatteries[j];\n        const battery = state.batteries.find(bb => bb.id === bid);\n        if (!battery) continue;\n        const angle = -Math.PI / 2 + (j - (count - 1) / 2) * 0.5;\n        const rx = x + Math.cos(angle) * 70;\n        const ry = y + Math.sin(angle) * 70;\n        ctx.save();\n        ctx.fillStyle = '#fffef6';\n        roundRect(ctx, rx - 20, ry - 14, 40, 28, 6, true, true);\n        ctx.fillStyle = '#222';\n        ctx.font = '16px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(battery.value, rx, ry);\n        ctx.restore();\n      }\n\n      // ring for accept area\n      ctx.beginPath();\n      ctx.strokeStyle = '#b0c4ff';\n      ctx.lineWidth = 2;\n      ctx.arc(x, y - 10, 52, 0, Math.PI * 2);\n      ctx.stroke();\n\n      // if lit, draw smiling face on bulb\n      if (bulb.lit) {\n        ctx.fillStyle = '#333';\n        ctx.beginPath();\n        ctx.arc(x - 10, y - 14, 3, 0, Math.PI * 2);\n        ctx.arc(x + 10, y - 14, 3, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.strokeStyle = '#333';\n        ctx.lineWidth = 2;\n        ctx.arc(x, y - 6, 8, 0, Math.PI);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  // Draw connectors (lines) from battery to bulb if placed, and from held battery to mouse\n  function drawConnectors() {\n    ctx.save();\n    ctx.lineWidth = 6;\n    for (let b of state.batteries) {\n      if (b.placedOn !== null) {\n        const bulb = state.bulbs[b.placedOn];\n        if (!bulb) continue;\n        const sx = b.drawX || b.x;\n        const sy = b.drawY || b.y;\n        const tx = bulb.x;\n        const ty = bulb.y - 10;\n        // gradient line\n        const grad = ctx.createLinearGradient(sx, sy, tx, ty);\n        grad.addColorStop(0, '#f6b042');\n        grad.addColorStop(1, '#ffd966');\n        ctx.strokeStyle = grad;\n        ctx.beginPath();\n        ctx.moveTo(sx, sy);\n        // nice curve\n        ctx.quadraticCurveTo((sx + tx) / 2, sy - 40, tx, ty);\n        ctx.stroke();\n      }\n    }\n    // dragging line\n    if (state.holdingBattery) {\n      const bat = state.batteries.find(bb => bb.id === state.holdingBattery);\n      if (bat) {\n        const sx = state.mouse.x + bat.pickedOffset.x;\n        const sy = state.mouse.y + bat.pickedOffset.y;\n        const tx = state.mouse.x;\n        const ty = state.mouse.y;\n        ctx.strokeStyle = '#bdbdbd';\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n        ctx.moveTo(sx, sy);\n        ctx.lineTo(tx, ty);\n        ctx.stroke();\n      }\n    }\n    ctx.restore();\n  }\n\n  // Draw characters: Sparky and Volt\n  function drawCharacters(frame) {\n    // Sparky the Squirrel electrician on left\n    ctx.save();\n    const s = characters.sparky;\n    ctx.translate(s.x, s.y);\n    ctx.scale(s.scale, s.scale);\n    // body\n    ctx.fillStyle = '#db8b3f';\n    ctx.beginPath();\n    ctx.ellipse(0, -8, 28, 36, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // tail - wacky\n    ctx.fillStyle = '#f0bfa0';\n    ctx.beginPath();\n    ctx.ellipse(-35, -26, 18, 32, -0.6, 0, Math.PI * 2);\n    ctx.fill();\n    // helmet\n    ctx.fillStyle = '#2b8cff';\n    ctx.beginPath();\n    ctx.arc(0, -36, 18, Math.PI, 0, false);\n    ctx.fill();\n    // goggles\n    ctx.fillStyle = '#fff';\n    ctx.beginPath();\n    ctx.ellipse(-6, -30, 6, 4, 0, 0, Math.PI * 2);\n    ctx.ellipse(10, -30, 6, 4, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.ellipse(-6, -30, 3, 2, 0, 0, Math.PI * 2);\n    ctx.ellipse(10, -30, 3, 2, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // wrench in hand\n    ctx.strokeStyle = '#666';\n    ctx.lineWidth = 4;\n    ctx.beginPath();\n    ctx.moveTo(16, -10);\n    ctx.lineTo(36, -18);\n    ctx.stroke();\n    ctx.restore();\n\n    // Volt the lightbulb mascot on right\n    ctx.save();\n    const v = characters.volt;\n    ctx.translate(v.x, v.y);\n    ctx.scale(v.scale, v.scale);\n    // body bulb\n    ctx.fillStyle = '#fff9c4';\n    ctx.beginPath();\n    ctx.arc(0, -12, 28, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#f6bb00';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    // face\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(-9, -18, 3, 0, Math.PI * 2);\n    ctx.arc(9, -18, 3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    ctx.arc(0, -10, 8, 0, Math.PI);\n    ctx.stroke();\n    // little spark icon near Volt when sound is on\n    if (state.soundOn) {\n      ctx.fillStyle = '#ffb300';\n      ctx.beginPath();\n      ctx.moveTo(20, -40);\n      ctx.lineTo(30, -28);\n      ctx.lineTo(22, -30);\n      ctx.lineTo(32, -18);\n      ctx.lineTo(18, -26);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  // UI hints and messages\n  function drawUI() {\n    ctx.save();\n    // instructions box\n    ctx.fillStyle = 'rgba(255,255,255,0.6)';\n    roundRect(ctx, 260, 8, 440, 56, 10, true, true);\n    ctx.fillStyle = '#114b8c';\n    ctx.font = '14px \"Segoe UI\", Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Pick batteries (numbers) and drop them onto bulbs to make the sums match.', 276, 28);\n    ctx.fillText('Use arrows to select, Enter to pick/place, Space to toggle sound.', 276, 48);\n\n    // message overlay\n    if (state.messageTimer > 0 && state.message) {\n      ctx.fillStyle = 'rgba(40,40,40,0.75)';\n      roundRect(ctx, WIDTH / 2 - 180, 60, 360, 36, 8, true, true);\n      ctx.fillStyle = '#fff';\n      ctx.textAlign = 'center';\n      ctx.font = '16px \"Segoe UI\", Arial';\n      ctx.fillText(state.message, WIDTH / 2, 86);\n    }\n\n    // level progress\n    const litCount = state.bulbs.filter(b => b.lit).length;\n    ctx.fillStyle = '#333';\n    ctx.textAlign = 'left';\n    ctx.font = '14px \"Segoe UI\", Arial';\n    ctx.fillText(`Houses lit: ${litCount} / ${state.bulbs.length}`, 12, 48);\n\n    // sound icon\n    drawSoundIcon();\n\n    ctx.restore();\n  }\n\n  // Utility: rounded rectangle\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === 'undefined') r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Check if point inside battery card bounds\n  function pointInBattery(x, y, bat) {\n    const bx = bat.drawX || bat.x;\n    const by = bat.drawY || bat.y;\n    return x >= bx - 36 && x <= bx + 36 && y >= by - 28 && y <= by + 28;\n  }\n\n  // Check if point near bulb center (for dropping)\n  function pointInBulb(x, y, bulb) {\n    const dx = x - bulb.x;\n    const dy = y - (bulb.y - 10);\n    return Math.sqrt(dx * dx + dy * dy) <= 52;\n  }\n\n  // Place battery on bulb (or remove)\n  function placeBatteryOn(batteryId, bulbIndex) {\n    const bat = state.batteries.find(b => b.id === batteryId);\n    if (!bat) return;\n    // If placing on same bulb, remove it (toggle)\n    if (bulbIndex === null) {\n      if (bat.placedOn !== null) {\n        // remove from previous bulb\n        const prevBulb = state.bulbs[bat.placedOn];\n        prevBulb.connectedBatteries = prevBulb.connectedBatteries.filter(id => id !== bat.id);\n      }\n      bat.placedOn = null;\n      return;\n    }\n    const bulb = state.bulbs[bulbIndex];\n    if (!bulb) return;\n    // remove from previous bulb first\n    if (bat.placedOn !== null) {\n      const prev = state.bulbs[bat.placedOn];\n      if (prev) prev.connectedBatteries = prev.connectedBatteries.filter(id => id !== bat.id);\n    }\n    // attach\n    bat.placedOn = bulbIndex;\n    bulb.connectedBatteries.push(bat.id);\n    // Immediately play spark sound\n    if (state.soundOn) {\n      playSpark();\n    }\n    // Check bulb sum\n    checkBulb(bulbIndex);\n  }\n\n  // Check if bulb's connected battery sum matches target\n  function checkBulb(idx) {\n    const bulb = state.bulbs[idx];\n    const sum = bulb.connectedBatteries.reduce((s, bid) => {\n      const b = state.batteries.find(bb => bb.id === bid);\n      return s + (b ? b.value : 0);\n    }, 0);\n    if (sum === bulb.target) {\n      if (!bulb.lit) {\n        bulb.lit = true;\n        playChime();\n        state.score += 10;\n        announce(`Great! You lit a house!`);\n        // visual sparkle: increase glow\n        bulb.glow = 1;\n      }\n    } else {\n      // if not equal and previously lit, turn off\n      if (bulb.lit) {\n        bulb.lit = false;\n      }\n      // wrong partial sums: small buzz if sum exceeds target\n      if (sum > bulb.target) {\n        if (state.soundOn) playBuzz();\n        // minor penalty\n        state.score = Math.max(0, state.score - 2);\n      }\n    }\n    // check if all lit -> next level\n    if (state.bulbs.every(b => b.lit)) {\n      state.roundActive = false;\n      announce('All houses glowing! Next round starting...');\n      setTimeout(() => {\n        initLevel(state.level + 1);\n      }, 1800);\n    }\n  }\n\n  // Remove battery if placed on bulb and user picks it up\n  function pickUpBattery(batteryId) {\n    const bat = state.batteries.find(b => b.id === batteryId);\n    if (!bat) return;\n    if (bat.placedOn !== null) {\n      const bulb = state.bulbs[bat.placedOn];\n      if (bulb) {\n        bulb.connectedBatteries = bulb.connectedBatteries.filter(id => id !== batteryId);\n        // if bulb was lit, re-evaluate\n        checkBulb(bat.placedOn);\n      }\n      bat.placedOn = null;\n    }\n    state.holdingBattery = batteryId;\n    // offset so cursor isn't at center\n    bat.pickedOffset.x = bat.x - state.mouse.x;\n    bat.pickedOffset.y = bat.y - state.mouse.y;\n    if (state.soundOn) playBeep(1000, 0.06, 'sine');\n  }\n\n  // Drop currently held battery, determining target bulb if any\n  function dropHeldBattery() {\n    if (!state.holdingBattery) return;\n    const bat = state.batteries.find(b => b.id === state.holdingBattery);\n    if (!bat) {\n      state.holdingBattery = null;\n      return;\n    }\n    // find bulb under cursor\n    let targetIndex = null;\n    for (let i = 0; i < state.bulbs.length; i++) {\n      if (pointInBulb(state.mouse.x, state.mouse.y, state.bulbs[i])) {\n        targetIndex = i;\n        break;\n      }\n    }\n    if (targetIndex !== null) {\n      placeBatteryOn(bat.id, targetIndex);\n      // animate battery position to anchored spot near bulb for clarity\n      const bulb = state.bulbs[targetIndex];\n      const assignmentCount = bulb.connectedBatteries.length - 1;\n      const angle = -Math.PI / 2 + (assignmentCount - ((bulb.connectedBatteries.length - 1) / 2)) * 0.5;\n      const rx = bulb.x + Math.cos(angle) * 70;\n      const ry = bulb.y + Math.sin(angle) * 70;\n      bat.x = rx; bat.y = ry;\n    } else {\n      // return to original spot\n      bat.x = bat.baseX;\n      bat.y = bat.baseY;\n      if (state.soundOn) playBeep(380, 0.08, 'square');\n    }\n    state.holdingBattery = null;\n    if (state.soundOn) playBeep(600, 0.05, 'sine');\n  }\n\n  // Input handling\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    state.mouse.x = e.clientX - rect.left;\n    state.mouse.y = e.clientY - rect.top;\n    state.mouse.down = true;\n    // resume audio if required\n    resumeAudioOnInteraction();\n\n    // Check for clicking on sound icon\n    if (distance(state.mouse.x, state.mouse.y, WIDTH - 36, 20) <= 18) {\n      toggleSound();\n      return;\n    }\n\n    // pick a battery if clicked\n    for (let i = 0; i < state.batteries.length; i++) {\n      const b = state.batteries[i];\n      if (pointInBattery(state.mouse.x, state.mouse.y, b)) {\n        pickUpBattery(b.id);\n        state.draggingBatteryId = b.id;\n        state.selectedBatteryIndex = i;\n        return;\n      }\n    }\n    // If clicked on placed battery icons near bulbs, pick up that battery\n    for (let i = 0; i < state.bulbs.length; i++) {\n      const bulb = state.bulbs[i];\n      for (let j = 0; j < bulb.connectedBatteries.length; j++) {\n        const bid = bulb.connectedBatteries[j];\n        const b = state.batteries.find(bb => bb.id === bid);\n        if (!b) continue;\n        const angle = -Math.PI / 2 + (j - (bulb.connectedBatteries.length - 1) / 2) * 0.5;\n        const rx = bulb.x + Math.cos(angle) * 70;\n        const ry = bulb.y + Math.sin(angle) * 70;\n        if (distance(state.mouse.x, state.mouse.y, rx, ry) <= 20) {\n          pickUpBattery(b.id);\n          state.draggingBatteryId = b.id;\n          return;\n        }\n      }\n    }\n  });\n\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    state.mouse.x = e.clientX - rect.left;\n    state.mouse.y = e.clientY - rect.top;\n    if (state.holdingBattery) {\n      // update location of held battery visually\n      const bat = state.batteries.find(b => b.id === state.holdingBattery);\n      if (bat) {\n        bat.drawX = state.mouse.x + bat.pickedOffset.x;\n        bat.drawY = state.mouse.y + bat.pickedOffset.y;\n      }\n    }\n  });\n\n  canvas.addEventListener('mouseup', (e) => {\n    state.mouse.down = false;\n    if (state.draggingBatteryId) {\n      dropHeldBattery();\n      state.draggingBatteryId = null;\n    }\n  });\n\n  canvas.addEventListener('mouseleave', (e) => {\n    state.mouse.down = false;\n    // if dragging outside, drop to base\n    if (state.holdingBattery) dropHeldBattery();\n  });\n\n  // Keyboard handling for accessibility\n  canvas.addEventListener('keydown', (e) => {\n    // resume audio on keyboard interaction\n    resumeAudioOnInteraction();\n\n    if (e.code === 'Space') {\n      e.preventDefault();\n      toggleSound();\n      return;\n    }\n    if (e.key === 'ArrowDown') {\n      e.preventDefault();\n      state.selectedBatteryIndex = Math.min(state.batteries.length - 1, state.selectedBatteryIndex + 1);\n      return;\n    }\n    if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      state.selectedBatteryIndex = Math.max(0, state.selectedBatteryIndex - 1);\n      return;\n    }\n    if (e.key === 'ArrowLeft') {\n      e.preventDefault();\n      state.selectedBatteryIndex = Math.max(0, state.selectedBatteryIndex - 1);\n      return;\n    }\n    if (e.key === 'ArrowRight') {\n      e.preventDefault();\n      state.selectedBatteryIndex = Math.min(state.batteries.length - 1, state.selectedBatteryIndex + 1);\n      return;\n    }\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      // pick or place battery\n      const selected = state.batteries[state.selectedBatteryIndex];\n      if (!selected) return;\n      if (!state.holdingBattery) {\n        // pick up\n        pickUpBattery(selected.id);\n      } else {\n        // find if focused bulb exists under keyboard selection maybe cycle bulbs\n        // simple: drop onto nearest bulb by distance\n        let nearest = null;\n        let dist = Infinity;\n        for (let i = 0; i < state.bulbs.length; i++) {\n          const b = state.bulbs[i];\n          const d = distance(selected.x, selected.y, b.x, b.y - 10);\n          if (d < dist) {\n            dist = d; nearest = i;\n          }\n        }\n        if (nearest !== null) {\n          placeBatteryOn(state.holdingBattery, nearest);\n          // move battery to anchored spot\n          const bulb = state.bulbs[nearest];\n          const assignmentCount = bulb.connectedBatteries.length - 1;\n          const angle = -Math.PI / 2 + (assignmentCount - ((bulb.connectedBatteries.length - 1) / 2)) * 0.5;\n          const rx = bulb.x + Math.cos(angle) * 70;\n          const ry = bulb.y + Math.sin(angle) * 70;\n          const bat = state.batteries.find(bb => bb.id === state.holdingBattery);\n          if (bat) { bat.x = rx; bat.y = ry; }\n          state.holdingBattery = null;\n        } else {\n          // place back\n          const bat = state.batteries.find(b => b.id === state.holdingBattery);\n          if (bat) { bat.x = bat.baseX; bat.y = bat.baseY; }\n          state.holdingBattery = null;\n        }\n      }\n      return;\n    }\n    if (e.key === 'Escape') {\n      e.preventDefault();\n      // cancel holding\n      if (state.holdingBattery) {\n        const bat = state.batteries.find(b => b.id === state.holdingBattery);\n        if (bat) { bat.x = bat.baseX; bat.y = bat.baseY; }\n        state.holdingBattery = null;\n      }\n      return;\n    }\n  });\n\n  // Toggle sound\n  function toggleSound() {\n    state.soundOn = !state.soundOn;\n    if (state.soundOn) {\n      if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {\n        resumeAudioOnInteraction();\n      }\n      announce('Sound on');\n    } else {\n      announce('Sound off');\n    }\n  }\n\n  // Resume audio context on user gesture if needed\n  function resumeAudioOnInteraction() {\n    if (!audioEnabled || !audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().then(() => {\n        startBackgroundHum();\n        announce('Audio ready');\n      }).catch(e => {\n        console.warn('Audio resume failed:', e);\n      });\n    } else {\n      startBackgroundHum();\n    }\n  }\n\n  // Distance helper\n  function distance(x1, y1, x2, y2) {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  // Animation loop\n  let frame = 0;\n  function tick() {\n    frame++;\n    // gentle background movement of batteries\n    for (let b of state.batteries) {\n      b.wobble += 0.02;\n      if (!state.holdingBattery || state.holdingBattery !== b.id) {\n        // small breathing motion\n        b.x = b.baseX + Math.sin(b.wobble) * 2;\n        b.y = b.baseY + Math.cos(b.wobble * 0.9) * 1.5;\n      }\n    }\n\n    // reduce message timer\n    if (state.messageTimer > 0) state.messageTimer--;\n\n    // draw everything\n    clearScreen();\n    drawHeader();\n    drawBatteries();\n    drawConnectors();\n    drawBulbs();\n    drawCharacters(frame);\n    drawUI();\n\n    // draw helpful hint overlay if needed\n    if (state.hintVisible) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.85)';\n      roundRect(ctx, 60, HEIGHT - 64, 600, 46, 10, true, true);\n      ctx.fillStyle = '#333';\n      ctx.font = '14px \"Segoe UI\", Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText('Tip: Try combining two or three batteries if the number is bigger! Click Space to toggle sound.', WIDTH / 2, HEIGHT - 36);\n      ctx.restore();\n    }\n\n    requestAnimationFrame(tick);\n  }\n\n  // Start the game\n  initLevel(1);\n  tick();\n\n  // If audio is enabled, wait for user gesture to start background hum\n  // Also provide a small friendly hint drawn when audio unavailable\n  if (audioEnabled) {\n    // Show an overlay indicating user should tap/click to enable sound if suspended\n    function showAudioHintOnce() {\n      if (audioCtx && audioCtx.state === 'suspended') {\n        // Drawn in canvas already through message; set message\n        announce('Tap the game or press any key to enable sound and start the lab!');\n      }\n      // Remove this event listener after one use\n      window.removeEventListener('pointerdown', showAudioHintOnce);\n      window.removeEventListener('keydown', showAudioHintOnce);\n    }\n    window.addEventListener('pointerdown', showAudioHintOnce);\n    window.addEventListener('keydown', showAudioHintOnce);\n  } else {\n    announce('Audio not available on this device. Visual cues will guide you instead.');\n  }\n\n  // Safety: if audio operations throw errors elsewhere, catch them globally on this context\n  window.addEventListener('unhandledrejection', (e) => {\n    console.warn('Unhandled promise rejection in game:', e.reason);\n  });\n\n  // Expose a small control function for debugging (optional)\n  try {\n    Object.defineProperty(window, '__electricGameDebug', {\n      value: {\n        restart: () => initLevel(1),\n        currentState: () => JSON.parse(JSON.stringify(state))\n      },\n      writable: false\n    });\n  } catch (e) {\n    // ignore if we can't define global\n  }\n\n})();\n---\n",
  "improve_response_tokens": 22915,
  "formatted_code": true,
  "formatting_response_tokens": 24262,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}