# Game of the Day - 2025-08-10

## Metadata
- **Generated Date:** 2025-08-10
- **Generated Time:** 2025-08-10T00:25:14.443378
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-10.js
- **File Size:** 26201 bytes
- **Tokens Used:** 9417

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
â€¢ Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
â€¢ Reinforce the math concept through a real-world narratives tied to theme.
â€¢ Include fun, unique memorable characters tied to the theme.
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-10.js` - The playable game
- `2025-08-10.meta.json` - Machine-readable metadata
- `2025-08-10.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20195

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22867

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Electricity Math Game for ages 7-9
  // Renders inside element with ID 'game-of-the-day-stage'
  // All graphics drawn on canvas. Sound via Web Audio API (oscillators).
  // Keyboard controls and accessible live text included.

  // === Setup DOM and Canvas ===
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container element with ID "game-of-the-day-stage" not found.');
    return;
  }
  container.style.position = 'relative';
  container.style.width = '720px';
  container.style.height = '480px';
  container.setAttribute('role', 'application');

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.outline = 'none';
  canvas.setAttribute('tabindex', '0'); // make focusable for keyboard
  canvas.setAttribute('aria-label', 'Spark City math game. Use arrow keys to move the spark. Press M to mute. Press Enter or Space to start or interact.');
  container.appendChild(canvas);

  // Accessible live region (visually hidden) for screen readers
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '0';
  live.style.top = '0';
  live.style.width = '1px';
  live.style.height = '1px';
  live.style.overflow = 'hidden';
  live.style.clip = 'rect(1px, 1px, 1px, 1px)';
  live.style.whiteSpace = 'nowrap';
  live.style.clipPath = 'inset(50%)';
  container.appendChild(live);

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('2D canvas context not available.');
    return;
  }

  // === Audio Setup with error handling ===
  let audioCtx = null;
  let masterGain = null;
  let ambientOsc = null;
  let audioEnabled = true;
  let audioAllowed = false;

  function initAudio() {
    if (audioCtx) return;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.6;
      masterGain.connect(audioCtx.destination);

      // ambient hum (gentle)
      ambientOsc = audioCtx.createOscillator();
      const ambientGain = audioCtx.createGain();
      ambientOsc.frequency.value = 110; // low hum
      ambientOsc.type = 'sine';
      ambientGain.gain.value = 0.02;
      ambientOsc.connect(ambientGain);
      ambientGain.connect(masterGain);
      ambientOsc.start();

      audioAllowed = true;
    } catch (e) {
      console.warn('AudioContext creation failed or blocked by browser:', e);
      audioAllowed = false;
      audioCtx = null;
    }
  }

  function resumeAudioOnGesture() {
    // Some browsers require resume on user gesture
    if (!audioCtx) initAudio();
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().catch((e) => {
        console.warn('Failed to resume audio context:', e);
      });
    }
  }

  function playTone({freq = 440, duration = 0.2, type = 'sine', gain = 0.1, detune = 0}) {
    if (!audioAllowed || !audioCtx || !audioEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      o.detune.value = detune;
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.linearRampToValueAtTime(gain, now + 0.01);
      g.gain.linearRampToValueAtTime(0.0001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.05);
    } catch (e) {
      console.warn('playTone error:', e);
    }
  }

  function playPluck(value) {
    // pluck with pitch related to value
    const base = 220 + (value * 40);
    playTone({freq: base, duration: 0.18, type: 'triangle', gain: 0.12});
    // small second harmonic
    setTimeout(() => playTone({freq: base * 1.5, duration: 0.12, type: 'sine', gain: 0.06}), 60);
  }

  function playSuccessMelody() {
    if (!audioAllowed || !audioEnabled) return;
    playTone({freq: 660, duration: 0.18, type: 'sine', gain: 0.14});
    setTimeout(() => playTone({freq: 880, duration: 0.16, type: 'sine', gain: 0.12}), 160);
    setTimeout(() => playTone({freq: 990, duration: 0.22, type: 'sine', gain: 0.12}), 320);
  }

  function playBuzzer() {
    if (!audioAllowed || !audioEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const f = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      o.type = 'sawtooth';
      o.frequency.value = 120;
      f.type = 'lowpass';
      f.frequency.value = 800;
      g.gain.value = 0.0001;
      o.connect(f);
      f.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.linearRampToValueAtTime(0.16, now + 0.01);
      g.gain.linearRampToValueAtTime(0.0001, now + 0.36);
      o.start(now);
      o.stop(now + 0.38);
    } catch (e) {
      console.warn('playBuzzer error:', e);
    }
  }

  // === Game Variables ===
  const W = canvas.width;
  const H = canvas.height;

  let state = 'start'; // start, playing, success, gameover
  let level = 1;
  let score = 0;
  let lives = 3;

  // Player spark
  const player = {
    x: 90,
    y: H / 2,
    r: 16,
    vx: 0,
    vy: 0,
    speed: 140, // pixels per second
    collected: [], // numbers collected (values)
    color: '#FFD166'
  };

  // Bulbs (targets)
  let bulbs = [];

  // Number orbs scattered
  let orbs = [];

  // Time
  let lastTs = null;
  let running = true;

  // Input
  const keys = {};

  // Visual style palette
  const palette = {
    bg: '#E8F6FF',
    panel: '#CFF6EA',
    wire: '#7D8AFA',
    sparkGlow: '#FFEDB6',
    text: '#05386B',
    soft: '#F6F7FD',
    accent: '#FF7B7B'
  };

  // Characters descriptions for narrative and memory
  const characters = {
    wattson: {
      name: 'Wattson',
      role: 'Lightning Squirrel',
      desc: 'A zippy squirrel who loves counting charges!'
    },
    ampy: {
      name: 'Ampy',
      role: 'Friendly Bulb',
      desc: 'A gentle bulb who lights up when you give the right charge.'
    },
    gearhead: {
      name: 'Gearhead',
      role: 'Helper Robot',
      desc: 'Keeps the city circuits tidy and gives hints.'
    }
  };

  // Accessibility status to be read by screen readers
  function announce(text) {
    live.textContent = text;
  }

  // === Utility Functions ===
  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function randInt(min, max) {
    return Math.floor(rand(min, max + 1));
  }

  function distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // === Game Logic ===
  function newLevel(lv = 1) {
    level = lv;
    player.x = 90;
    player.y = H / 2;
    player.collected = [];
    score = score;
    lives = Math.max(1, lives);
    // Generate bulbs based on level
    bulbs = [];
    const bulbCount = Math.min(4, 2 + Math.floor(level / 2));
    const rightX = W - 120;
    const spacing = H / (bulbCount + 1);
    for (let i = 0; i < bulbCount; i++) {
      // Targets between 3 and 18 scaled by level difficulty
      const minTarget = 3;
      const maxTarget = Math.min(20, 6 + level * 2);
      const target = randInt(minTarget, maxTarget);
      bulbs.push({
        x: rightX,
        y: spacing * (i + 1),
        r: 36,
        target: target,
        lit: false,
        tries: 0
      });
    }

    // Generate orbs (numbers) scattered around the left and middle area
    const orbCount = Math.max(6, 6 + level);
    orbs = [];
    for (let i = 0; i < orbCount; i++) {
      const val = randInt(1, Math.min(9, 3 + Math.floor(level)));
      const px = rand(160, W - 240);
      const py = rand(60, H - 60);
      orbs.push({
        x: px,
        y: py,
        r: 14,
        value: val,
        collected: false,
        floatPhase: rand(0, Math.PI * 2)
      });
    }

    announce(`Level ${level} started. Bulbs need: ${bulbs.map(b => b.target).join(', ')}. Use arrow keys to move the spark and add numbers to match the bulbs.`);
  }

  // Player collects orb
  function collectOrb(orb) {
    orb.collected = true;
    player.collected.push(orb.value);
    playPluck(orb.value);
    announce(`You collected ${orb.value}. Current charge is ${player.collected.reduce((a, b) => a + b, 0)}.`);
  }

  // Attempt to deliver to bulb
  function deliverToBulb(bulb) {
    const current = player.collected.reduce((a, b) => a + b, 0);
    bulb.tries++;
    if (current === bulb.target) {
      bulb.lit = true;
      score += Math.max(10, bulb.target * 2);
      playSuccessMelody();
      announce(`${characters.ampy.name} lit up! You matched ${current}. Score ${score}.`);
      // Clear player's collected
      player.collected = [];
      // Remove any orbs that were placed (they are already collected)
      // Check level complete
      if (bulbs.every(b => b.lit)) {
        state = 'levelComplete';
        announce(`Level complete! Score ${score}. Press Enter to go to next level.`);
      }
    } else {
      // Wrong attempt
      playBuzzer();
      lives -= 1;
      announce(`Oh no! ${characters.gearhead.name} says try again. Delivered ${current} but needed ${bulb.target}. Lives left ${lives}.`);
      // penalty: drop one collected orb back into play near player
      if (player.collected.length > 0) {
        const droppedValue = player.collected.pop();
        orbs.push({
          x: player.x + rand(-40, 40),
          y: player.y + rand(-20, 20),
          r: 14,
          value: droppedValue,
          collected: false,
          floatPhase: 0
        });
        playPluck(droppedValue);
      }
      if (lives <= 0) {
        state = 'gameover';
        announce('Game over. Press Enter to restart.');
      }
    }
  }

  // === Input Handling ===
  window.addEventListener('keydown', (e) => {
    // Prevent page from scrolling on arrow keys
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
      e.preventDefault();
    }
    keys[e.key] = true;

    // Start/resume audio on any key press
    resumeAudioOnGesture();

    if (state === 'start' && (e.key === 'Enter' || e.key === ' ')) {
      state = 'playing';
      newLevel(1);
      lastTs = performance.now();
      announce('Game started. Move the spark to collect numbers and match the bulbs.');
    } else if ((state === 'levelComplete' || state === 'gameover' || state === 'success') && (e.key === 'Enter' || e.key === ' ')) {
      if (state === 'levelComplete') {
        newLevel(level + 1);
        state = 'playing';
        lastTs = performance.now();
      } else {
        // restart
        level = 1;
        score = 0;
        lives = 3;
        newLevel(1);
        state = 'playing';
        lastTs = performance.now();
      }
    } else if (e.key.toLowerCase() === 'm') {
      audioEnabled = !audioEnabled;
      announce(audioEnabled ? 'Audio enabled.' : 'Audio muted.');
    }
  }, {passive: false});

  window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
  });

  canvas.addEventListener('click', (e) => {
    // focus canvas for keyboard
    canvas.focus();
    resumeAudioOnGesture();
    if (state === 'start') {
      state = 'playing';
      newLevel(1);
      lastTs = performance.now();
      announce('Game started. Move the spark to collect numbers and match the bulbs.');
    } else if (state === 'levelComplete') {
      newLevel(level + 1);
      state = 'playing';
      lastTs = performance.now();
    } else if (state === 'gameover') {
      level = 1;
      score = 0;
      lives = 3;
      newLevel(1);
      state = 'playing';
      lastTs = performance.now();
    }
  });

  // Touch support for mobile: simple directional swipe handling
  let touchStart = null;
  canvas.addEventListener('touchstart', (e) => {
    resumeAudioOnGesture();
    touchStart = e.touches[0];
  }, {passive: true});
  canvas.addEventListener('touchend', (e) => {
    touchStart = null;
  });
  canvas.addEventListener('touchmove', (e) => {
    if (!touchStart) return;
    const t = e.touches[0];
    const dx = t.clientX - touchStart.clientX;
    const dy = t.clientY - touchStart.clientY;
    // map to keys temporarily
    keys['ArrowRight'] = dx > 10;
    keys['ArrowLeft'] = dx < -10;
    keys['ArrowDown'] = dy > 10;
    keys['ArrowUp'] = dy < -10;
  }, {passive: true});

  // === Drawing Helpers ===
  function drawRoundedRect(x, y, w, h, r, fillStyle, strokeStyle) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if (strokeStyle) {
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }

  function drawSpark(p) {
    const glow = ctx.createRadialGradient(p.x, p.y, 2, p.x, p.y, p.r + 20);
    glow.addColorStop(0, 'rgba(255,255,200,0.9)');
    glow.addColorStop(0.5, 'rgba(255,210,100,0.25)');
    glow.addColorStop(1, 'rgba(255,210,100,0.02)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r + 22, 0, Math.PI * 2);
    ctx.fill();

    // main body
    ctx.beginPath();
    ctx.fillStyle = p.color;
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#FFA500';
    ctx.stroke();

    // cute eyes (Wattson's style)
    ctx.fillStyle = '#2E2E2E';
    ctx.beginPath();
    ctx.ellipse(p.x - 6, p.y - 4, 2.6, 3.6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(p.x + 6, p.y - 4, 2.6, 3.6, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawOrb(orb) {
    // gentle float motion
    const fp = 6 * Math.sin(performance.now() / 600 + orb.floatPhase);
    ctx.beginPath();
    const grad = ctx.createLinearGradient(orb.x - orb.r, orb.y - orb.r + fp, orb.x + orb.r, orb.y + orb.r + fp);
    grad.addColorStop(0, '#FFF9C4');
    grad.addColorStop(1, '#FFE082');
    ctx.fillStyle = grad;
    ctx.arc(orb.x, orb.y + fp, orb.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#E0A800';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // number text
    ctx.fillStyle = '#2E2E2E';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(orb.value.toString(), orb.x, orb.y + fp);
  }

  function drawBulb(b) {
    // base wire connector
    ctx.save();
    // wire
    ctx.strokeStyle = palette.wire;
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(b.x - 80, b.y);
    ctx.quadraticCurveTo(b.x - 40, b.y - 30, b.x - 20, b.y - 10);
    ctx.stroke();

    // Bulb glass
    const glow = ctx.createRadialGradient(b.x, b.y - 8, 4, b.x, b.y - 8, b.r + 18);
    if (b.lit) {
      glow.addColorStop(0, 'rgba(255,255,180,0.95)');
      glow.addColorStop(0.6, 'rgba(255,230,120,0.5)');
      glow.addColorStop(1, 'rgba(255,230,120,0.04)');
    } else {
      glow.addColorStop(0, 'rgba(220,235,255,0.9)');
      glow.addColorStop(1, 'rgba(200,220,255,0.02)');
    }
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.ellipse(b.x, b.y - 8, b.r, b.r + 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // socket
    ctx.fillStyle = '#9AA5D1';
    ctx.fillRect(b.x - 12, b.y + b.r - 6, 24, 12);
    ctx.strokeStyle = '#6C7390';
    ctx.strokeRect(b.x - 12, b.y + b.r - 6, 24, 12);

    // target number
    ctx.fillStyle = '#153243';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(b.target.toString(), b.x, b.y - 8);

    // small halo text if lit
    if (b.lit) {
      ctx.fillStyle = 'rgba(255,220,120,0.9)';
      ctx.font = '12px sans-serif';
      ctx.fillText('Lit!', b.x, b.y + b.r + 18);
    } else {
      ctx.fillStyle = '#153243';
      ctx.font = '12px sans-serif';
      ctx.fillText(`Tries: ${b.tries}`, b.x, b.y + b.r + 18);
    }
    ctx.restore();
  }

  function drawCharacters() {
    // Wattson the Lightning Squirrel (left bottom)
    const wx = 48, wy = H - 60;
    // tail
    ctx.beginPath();
    ctx.fillStyle = '#F7C59F';
    ctx.ellipse(wx - 24, wy - 4, 24, 12, -0.6, 0, Math.PI * 2);
    ctx.fill();
    // body
    ctx.beginPath();
    ctx.fillStyle = '#FFD7A6';
    ctx.arc(wx, wy, 18, 0, Math.PI * 2);
    ctx.fill();
    // face
    ctx.fillStyle = '#2E2E2E';
    ctx.beginPath();
    ctx.ellipse(wx - 4, wy - 4, 3, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(wx + 6, wy - 4, 3, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    // text
    ctx.fillStyle = '#2E2E2E';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`${characters.wattson.name} the ${characters.wattson.role}`, wx + 36, wy - 6);

    // Ampy the bulb (top-left)
    const ax = 80, ay = 60;
    ctx.save();
    // bulb glow
    const g = ctx.createRadialGradient(ax, ay, 2, ax, ay, 40);
    g.addColorStop(0, 'rgba(255,255,200,0.9)');
    g.addColorStop(1, 'rgba(255,230,160,0.02)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(ax, ay, 28, 0, Math.PI * 2);
    ctx.fill();
    // filament
    ctx.fillStyle = '#222';
    ctx.fillRect(ax - 6, ay + 6, 12, 8);
    ctx.fillStyle = '#2E2E2E';
    ctx.font = '12px sans-serif';
    ctx.fillText(`${characters.ampy.name}`, ax + 44, ay - 4);
    ctx.restore();

    // Gearhead robot (bottom-right)
    const rx = W - 48, ry = H - 60;
    ctx.fillStyle = '#C7D3FF';
    ctx.fillRect(rx - 18, ry - 22, 36, 36);
    ctx.fillStyle = '#2E2E2E';
    ctx.fillRect(rx - 10, ry - 10, 6, 6);
    ctx.fillRect(rx + 4, ry - 10, 6, 6);
    ctx.fillStyle = '#2E2E2E';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(`${characters.gearhead.name}`, rx - 42, ry + 10);
  }

  // === Game Update & Render ===
  function update(dt) {
    if (state !== 'playing') return;

    // Input movement
    let dirX = 0, dirY = 0;
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) dirX -= 1;
    if (keys['ArrowRight'] || keys['d'] || keys['D']) dirX += 1;
    if (keys['ArrowUp'] || keys['w'] || keys['W']) dirY -= 1;
    if (keys['ArrowDown'] || keys['s'] || keys['S']) dirY += 1;

    // Normalize
    if (dirX !== 0 || dirY !== 0) {
      const len = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
      dirX /= len;
      dirY /= len;
    }

    player.vx = dirX * player.speed;
    player.vy = dirY * player.speed;

    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // Keep inside play area (avoid bulbs area on right)
    player.x = clamp(player.x, 40, W - 140);
    player.y = clamp(player.y, 40, H - 40);

    // Check orb collisions
    orbs.forEach((orb) => {
      if (orb.collected) return;
      const dx = player.x - orb.x;
      const dy = player.y - orb.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < player.r + orb.r - 2) {
        collectOrb(orb);
      }
    });

    // Check bulb collisions (delivery on touch)
    bulbs.forEach((b) => {
      const dx = player.x - b.x;
      const dy = player.y - (b.y - 8); // align with bulb center
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < player.r + b.r - 6 && !b.lit) {
        // deliver
        deliverToBulb(b);
      }
    });

    // float phases for orbs
    orbs.forEach(o => o.floatPhase += dt * 2);

    // Remove collected orbs from array over time (visual)
    orbs = orbs.filter(o => !o.collected || o.collected === false);
  }

  function render() {
    // background
    ctx.clearRect(0, 0, W, H);
    // gradient background
    const bg = ctx.createLinearGradient(0, 0, 0, H);
    bg.addColorStop(0, palette.bg);
    bg.addColorStop(1, '#F6FCFF');
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, W, H);

    // Soft panel for play area
    drawRoundedRect(16, 16, W - 32, H - 32, 12, palette.panel, '#DDEBFF');

    // Title and instructions area (top)
    ctx.fillStyle = palette.text;
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Spark City â€” Help Wattson deliver exact energy!', 24, 40);
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#345';
    ctx.fillText('Collect number charges and bring the exact total to each bulb to light it.', 24, 60);

    // Draw characters
    drawCharacters();

    // draw bulbs
    bulbs.forEach(drawBulb);

    // draw orbs
    orbs.forEach((orb) => {
      if (!orb.collected) drawOrb(orb);
    });

    // draw wires and fun elements (wacky shapes)
    // zigzag resistor area
    ctx.strokeStyle = '#C390FF';
    ctx.lineWidth = 2;
    ctx.beginPath();
    const startX = 140;
    const startY = H - 40;
    ctx.moveTo(startX, startY);
    for (let i = 0; i < 8; i++) {
      const x = startX + i * 22;
      const y = startY + (i % 2 === 0 ? -12 : 12);
      ctx.lineTo(x, y);
    }
    ctx.stroke();

    // render collected small badges near player to show current charge values
    const badX = player.x + 28, badY = player.y - 10;
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#123';
    ctx.fillText('Charge:', player.x - 26, player.y + 40);
    let offset = 0;
    player.collected.forEach((v, idx) => {
      ctx.fillStyle = '#FFF1B6';
      ctx.beginPath();
      ctx.arc(player.x + offset - 12, player.y + 40, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#EAB308';
      ctx.stroke();
      ctx.fillStyle = '#2E2E2E';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(String(v), player.x + offset - 12, player.y + 40);
      offset += 28;
    });

    // draw player spark
    drawSpark(player);

    // HUD: level, score, lives
    ctx.fillStyle = '#123';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(`Level ${level}`, W - 24, 36);
    ctx.fillText(`Score ${score}`, W - 24, 56);
    ctx.fillText(`Lives ${lives}`, W - 24, 76);

    // audio visual cue
    ctx.save();
    ctx.translate(W - 48, 96);
    ctx.fillStyle = audioEnabled && audioAllowed ? '#FFD4A3' : '#CCC';
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#222';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(audioEnabled ? 'ðŸ”Š' : 'ðŸ”ˆ', 0, 0);
    ctx.restore();

    // bottom instructions and controls
    ctx.fillStyle = '#0B2545';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Controls: Arrow keys or WASD to move. Touch drag on mobile. Press M to mute/unmute. Collect numbers and touch a bulb to deliver.', 24, H - 18);

    // contextual overlays
    if (state === 'start') {
      ctx.fillStyle = 'rgba(8, 20, 40, 0.6)';
      ctx.fillRect(80, 100, W - 160, 240);
      ctx.fillStyle = '#FFF';
      ctx.font = 'bold 28px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Spark City', W / 2, 160);
      ctx.font = '16px sans-serif';
      ctx.fillText('Wattson needs help delivering exact charges to the bulbs!', W / 2, 200);
      ctx.font = '14px sans-serif';
      ctx.fillText('Collect numbers (1â€“9) and bring the exact total to light each bulb.', W / 2, 232);
      ctx.fillStyle = '#FFD166';
      drawRoundedRect(W / 2 - 74, 260, 148, 42, 10, '#FFD166', '#F0A500');
      ctx.fillStyle = '#123';
      ctx.font = 'bold 16px sans-serif';
      ctx.fillText('Start Game', W / 2, 286);
    } else if (state === 'levelComplete') {
      ctx.fillStyle = 'rgba(10, 80, 60, 0.65)';
      ctx.fillRect(120, 120, W - 240, H - 240);
      ctx.fillStyle = '#E6FFFA';
      ctx.font = 'bold 22px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Great job! Level complete!', W / 2, H / 2 - 12);
      ctx.font = '16px sans-serif';
      ctx.fillText('Press Enter to continue to the next exciting circuit!', W / 2, H / 2 + 18);
    } else if (state === 'gameover') {
      ctx.fillStyle = 'rgba(80, 10, 10, 0.6)';
      ctx.fillRect(120, 120, W - 240, H - 240);
      ctx.fillStyle = '#FFF2F2';
      ctx.font = 'bold 24px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Oh no â€” the city is out of spark!', W / 2, H / 2 - 8);
      ctx.font = '16px sans-serif';
      ctx.fillText('Press Enter to try again.', W / 2, H / 2 + 20);
    }

    // small helpful hint area for screen readers
    // (also visuals)
    ctx.fillStyle = '#0B2545';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Bulb targets: ${bulbs.map(b => b.target).join(', ')}`, 24, 92);
  }

  // === Main Loop ===
  function loop(ts) {
    if (!lastTs) lastTs = ts;
    const dt = Math.min(0.06, (ts - lastTs) / 1000);
    lastTs = ts;

    try {
      update(dt);
      render();
    } catch (e) {
      console.error('Error during game update/render:', e);
      announce('An error occurred. Please reload the page to try again.');
      running = false;
    }

    if (running) requestAnimationFrame(loop);
  }

  // === Initialization ===
  function start() {
    // Initialize audio if possible but don't block main UI
    try {
      initAudio();
    } catch (e) {
      console.warn('Audio init failed:', e);
    }

    // initial screen
    render();
    announce('Welcome to Spark City! Press Enter or click to start. Use arrow keys to move. Press M to mute or unmute audio.');
    // start loop
    lastTs = null;
    requestAnimationFrame(loop);
  }

  // Start after a short delay so container style settle
  setTimeout(start, 250);

  // Expose minimal debug in window (non-intrusive)
  window.sparkCity = {
    restart: () => {
      level = 1; score = 0; lives = 3; state = 'start';
      player.collected = [];
      orbs = [];
      bulbs = [];
      lastTs = null;
      announce('Game reset. Press Enter to start.');
    },
    mute: (v) => {
      audioEnabled = !v ? false : true;
    }
  };

  // Ensure errors in audio are handled gracefully
  window.addEventListener('unhandledrejection', (ev) => {
    console.warn('Unhandled promise rejection:', ev.reason);
  });
})();
---

