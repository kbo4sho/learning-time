# Game of the Day - 2025-08-11

## Metadata
- **Generated Date:** 2025-08-11
- **Generated Time:** 2025-08-11T00:24:22.550079
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-11.js
- **File Size:** 26336 bytes
- **Tokens Used:** 9378

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-11.js` - The playable game
- `2025-08-11.meta.json` - Machine-readable metadata
- `2025-08-11.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18626

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20043

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Spark Squad: Electricity Math Game
  // Ages 7-9. Connect charges by guiding a spark to number nodes to match device target.
  // Renders entirely in the element with ID 'game-of-the-day-stage' using a 720x480 canvas.
  // All graphics drawn with Canvas API. Sounds generated with Web Audio API oscillators.
  // Accessible: keyboard controls, aria live text updates, visual audio indicator, clear instructions.

  // ---------- Setup and DOM ----------
  const STAGE_ID = 'game-of-the-day-stage';
  const WIDTH = 720;
  const HEIGHT = 480;

  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error(`Game requires an element with id="${STAGE_ID}" to render into.`);
    return;
  }

  // Clear existing contents
  stage.innerHTML = '';
  stage.style.position = 'relative';
  stage.style.width = WIDTH + 'px';
  stage.style.height = HEIGHT + 'px';
  stage.style.userSelect = 'none';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make focusable for keyboard
  canvas.style.outline = 'none';
  canvas.setAttribute('aria-label', 'Spark Squad math game: use arrow keys or WASD to move the spark, press Space or Enter to use a number node, press M to mute audio. Instructions appear on screen.');
  stage.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Create an ARIA live region for screen readers (text alternatives)
  const ariaLive = document.createElement('div');
  ariaLive.setAttribute('aria-live', 'polite');
  ariaLive.style.position = 'absolute';
  ariaLive.style.left = '-9999px';
  ariaLive.style.width = '1px';
  ariaLive.style.height = '1px';
  ariaLive.style.overflow = 'hidden';
  stage.appendChild(ariaLive);

  // ---------- Audio Setup ----------

  let audioEnabled = true;
  let audioCtx = null;
  let masterGain = null;
  let bgOsc = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    // Some browsers require user gesture; start/resume later on first interaction
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.18;
    masterGain.connect(audioCtx.destination);

    // Background gentle hum using oscillator + lowpass
    bgOsc = audioCtx.createOscillator();
    const bgGain = audioCtx.createGain();
    bgOsc.type = 'sine';
    bgOsc.frequency.value = 110; // gentle
    bgGain.gain.value = 0.03;
    const bgFilter = audioCtx.createBiquadFilter();
    bgFilter.type = 'lowpass';
    bgFilter.frequency.value = 600;
    bgOsc.connect(bgFilter);
    bgFilter.connect(bgGain);
    bgGain.connect(masterGain);
    bgOsc.start();
  } catch (err) {
    audioEnabled = false;
    console.warn('Web Audio API unavailable or denied by browser. Continuing without audio.', err);
  }

  function resumeAudioIfNeeded() {
    if (!audioEnabled || !audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch((e) => {
        console.warn('AudioContext resume failed:', e);
      });
    }
  }

  function playTone(freq, duration = 0.22, type = 'sine', when = 0, volume = 0.12) {
    if (!audioEnabled || !audioCtx) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc.type = type;
      osc.frequency.value = freq;
      filter.type = 'lowpass';
      filter.frequency.value = Math.max(300, freq * 2);
      gain.gain.value = volume;
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      const start = audioCtx.currentTime + when;
      osc.start(start);
      gain.gain.setValueAtTime(volume, start);
      gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
      osc.stop(start + duration + 0.02);
    } catch (e) {
      console.warn('playTone failed', e);
    }
  }

  function playChime() {
    // joyful chord
    playTone(740, 0.14, 'sine', 0, 0.06);
    playTone(1046, 0.2, 'triangle', 0.02, 0.06);
    playTone(523, 0.26, 'sine', 0.04, 0.06);
  }

  function playBuzzer() {
    // incorrect buzz
    if (!audioEnabled || !audioCtx) return;
    try {
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'square';
      o.frequency.value = 160;
      g.gain.value = 0.12;
      o.connect(g);
      g.connect(masterGain);
      o.start(t);
      o.frequency.exponentialRampToValueAtTime(60, t + 0.18);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.2);
      o.stop(t + 0.22);
    } catch (e) {
      console.warn('playBuzzer failed', e);
    }
  }

  // ---------- Game State ----------

  const characters = {
    battery: {
      name: 'Volt',
      color: '#FFD166',
      eyeColor: '#333'
    },
    helper: {
      name: 'Ohma',
      color: '#BDE0FE'
    }
  };

  let level = 1;
  const maxLevels = 5;

  // Game objects: nodes (number nodes), battery charge, device
  let nodes = [];
  let battery = {
    x: 90,
    y: 100,
    radius: 48,
    charge: 0
  };

  let device = {
    x: WIDTH - 130,
    y: 100,
    radius: 52,
    target: 0
  };

  // Spark controlled by player
  const spark = {
    x: 360,
    y: 320,
    r: 12,
    vx: 0,
    vy: 0,
    speed: 2.6
  };

  let usedNodes = new Set();
  let message = 'Welcome to Spark Squad! Move the spark to number nodes and press Space/Enter to change the battery charge. When the battery shows the same number as the device, go to the device and press Enter to finish!';
  let msgTimer = 0;
  let showHelp = true;
  let muted = false;

  // Keyboard state
  const keys = {};

  // Visual audio indicator tick state
  let audioIndicatorPulse = 0;

  // Accessibility announcements
  function announce(text) {
    ariaLive.textContent = text;
  }

  // ---------- Utilities ----------
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Ensure we generate nodes with unique positions and accessible sizes
  function generateLevel(lv) {
    nodes = [];
    usedNodes.clear();
    // battery and device baseline positions (left and right)
    battery.charge = randInt(0, 6);
    device.target = Math.min(20, Math.max(1, battery.charge + randInt(-3, 8)));
    // Ensure target positive
    device.target = Math.max(0, device.target);

    // number of nodes depends on level (3-6)
    const nodeCount = Math.min(7, 3 + Math.floor(lv / 1.5));
    const available = [];
    for (let i = 0; i < nodeCount; i++) {
      // nodes are scattered in play area avoiding battery and device
      let tries = 0;
      while (tries < 60) {
        const x = randInt(160, WIDTH - 160);
        const y = randInt(140, HEIGHT - 60);
        const r = 26;
        const distToBattery = Math.hypot(x - battery.x, y - battery.y);
        const distToDevice = Math.hypot(x - device.x, y - device.y);
        let ok = distToBattery > 110 && distToDevice > 100;
        for (const n of available) {
          if (Math.hypot(x - n.x, y - n.y) < 72) {
            ok = false;
            break;
          }
        }
        if (ok) {
          // number value: mostly small ints between -6 and +8; increase with level
          const magnitude = Math.min(9, 3 + Math.floor(lv / 2));
          // favor positive numbers slightly
          let val;
          if (Math.random() < 0.7) {
            val = randInt(1, magnitude);
          } else {
            val = -randInt(1, Math.max(1, Math.min(6, Math.floor(magnitude / 1.5))));
          }
          available.push({ x, y, r, val });
          break;
        }
        tries++;
      }
    }

    // Add a couple of operator-style nodes (double value or zeroing) occasionally as fun wacky elements for older levels
    if (lv >= 3 && Math.random() < 0.6) {
      const x = randInt(220, WIDTH - 220);
      const y = randInt(180, HEIGHT - 80);
      available.push({ x, y, r: 30, val: 'x2' });
    }

    nodes = available;
    // Reset spark to a safe spot
    spark.x = WIDTH / 2;
    spark.y = HEIGHT - 80;
    spark.vx = 0;
    spark.vy = 0;

    // Announce level
    announce(`Level ${lv}. Battery ${battery.charge}. Device target ${device.target}. Use number nodes to reach the target.`);
    message = `Level ${lv}: Guide the spark to nodes, press Space/Enter to apply. Battery shows ${battery.charge}. Target ${device.target}. Press M to mute/unmute.`;
    msgTimer = 300;
  }

  // ---------- Interaction Handlers ----------
  canvas.addEventListener('keydown', (e) => {
    // Ensure audio resumes on first interaction
    resumeAudioIfNeeded();
    keys[e.key.toLowerCase()] = true;

    // M mute toggle
    if (e.key.toLowerCase() === 'm') {
      muted = !muted;
      if (masterGain) masterGain.gain.value = muted ? 0 : 0.18;
      announce(muted ? 'Audio muted' : 'Audio unmuted');
    }

    // Enter/Space for interactions
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      handleUseNodeOrDevice();
    }

    // H toggles help overlay
    if (e.key.toLowerCase() === 'h') {
      showHelp = !showHelp;
      announce(showHelp ? 'Help shown' : 'Help hidden');
    }
  });

  canvas.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  // Mouse/touch controls: move spark by clicking/tapping position; click on node applies value
  canvas.addEventListener('mousedown', (e) => {
    resumeAudioIfNeeded();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // Teleport the spark toward click instantly for easy control
    spark.x = mx;
    spark.y = my;
    // If clicked on node or device, apply
    const targetNode = nodes.findIndex((n, i) => {
      const d = Math.hypot(mx - n.x, my - n.y);
      return d <= n.r + spark.r + 4 && !usedNodes.has(i);
    });
    if (targetNode >= 0) {
      applyNode(targetNode);
    } else {
      // check device
      const dDevice = Math.hypot(mx - device.x, my - device.y);
      if (dDevice <= device.radius + spark.r + 4) {
        submitToDevice();
      }
    }
  });

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    resumeAudioIfNeeded();
    const rect = canvas.getBoundingClientRect();
    const t = e.touches[0];
    const mx = t.clientX - rect.left;
    const my = t.clientY - rect.top;
    spark.x = mx;
    spark.y = my;
  }, { passive: false });

  // Use node or device at current spark location
  function handleUseNodeOrDevice() {
    // find overlapping unused node
    for (let i = 0; i < nodes.length; i++) {
      if (usedNodes.has(i)) continue;
      const n = nodes[i];
      if (Math.hypot(spark.x - n.x, spark.y - n.y) <= n.r + spark.r + 4) {
        applyNode(i);
        return;
      }
    }
    // if not on a node, check device
    if (Math.hypot(spark.x - device.x, spark.y - device.y) <= device.radius + spark.r + 4) {
      submitToDevice();
      return;
    }
    // nothing interactive
    message = 'Move closer to a node or the device, then press Space or Enter.';
    msgTimer = 120;
    playTone(220, 0.08, 'sawtooth', 0, 0.06);
  }

  function applyNode(i) {
    const n = nodes[i];
    // cannot apply non-number nodes more than once either
    if (usedNodes.has(i)) return;
    // Apply based on n.val
    if (typeof n.val === 'number') {
      const prev = battery.charge;
      battery.charge = Math.max(0, Math.min(99, battery.charge + n.val));
      usedNodes.add(i);
      msgTimer = 180;
      message = `${characters.battery.name} changed from ${prev} by ${n.val} → ${battery.charge}.`;
      announce(message);
      playTone(n.val > 0 ? 660 : 280, 0.12, n.val > 0 ? 'triangle' : 'sine', 0, 0.07);
    } else if (n.val === 'x2') {
      const prev = battery.charge;
      battery.charge = Math.max(0, Math.min(99, battery.charge * 2));
      usedNodes.add(i);
      msgTimer = 200;
      message = `${characters.battery.name}'s charge doubled: ${prev} → ${battery.charge}.`;
      announce(message);
      playTone(880, 0.16, 'sine', 0, 0.08);
      playTone(440, 0.12, 'sine', 0.06, 0.06);
    } else {
      // unknown node
      usedNodes.add(i);
      message = 'Hmm, this node flickered but nothing happened.';
      msgTimer = 140;
      playTone(300, 0.12, 'sine', 0, 0.05);
    }
  }

  function submitToDevice() {
    // Try to finish level
    if (battery.charge === device.target) {
      // success
      message = `Success! ${characters.battery.name} powered the device!`;
      announce(message);
      playChime();
      msgTimer = 240;
      level = Math.min(maxLevels, level + 1);
      setTimeout(() => {
        generateLevel(level);
      }, 900);
    } else {
      // incorrect
      const diff = battery.charge - device.target;
      message = `Not quite. Battery ${battery.charge} vs target ${device.target}. Try using nodes to adjust by ${Math.abs(diff)} ${diff > 0 ? 'less' : 'more'}.`;
      announce(message);
      msgTimer = 260;
      playBuzzer();
      // gentle shake: nudge spark away
      spark.vx = (Math.random() - 0.5) * 6;
      spark.vy = -Math.random() * 3 - 1;
    }
  }

  // ---------- Drawing ----------
  function drawBackground() {
    // Calming pastel gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#E8F6FF');
    g.addColorStop(1, '#F9FFF6');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Wacky floating shapes (soft pastel clouds and squiggles)
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      const cx = (i * 160 + (Date.now() / 100) % 160) % WIDTH;
      ctx.fillStyle = i % 2 ? 'rgba(189,224,254,0.12)' : 'rgba(255,209,102,0.08)';
      ctx.ellipse(cx, 60 + i * 8, 70 - i * 8, 22 + (i % 2) * 6, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawBattery(x, y, r, charge) {
    // Battery character (Volt)
    // body
    ctx.save();
    ctx.translate(x, y);
    // outer casing
    ctx.fillStyle = characters.battery.color;
    roundRect(ctx, -r + 8, -r + 6, r * 2 - 16, r * 2 - 12, 10);
    ctx.fill();
    // top and bottom terminals
    ctx.fillStyle = '#E9C46A';
    ctx.fillRect(-r + 18, -r - 6, r - 24, 8);
    ctx.fillRect(r - 18, -r - 6, r - 24, 8);
    // eyes
    ctx.fillStyle = characters.battery.eyeColor;
    ctx.beginPath();
    ctx.arc(-12, -4, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(12, -4, 4, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.strokeStyle = '#6B6B6B';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 6, 8, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.stroke();

    // charge text center
    ctx.fillStyle = '#333';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`${charge}C`, 0, 12);
    ctx.restore();

    // name tag
    ctx.fillStyle = 'rgba(0,0,0,0.05)';
    ctx.fillRect(x - 48, y + r - 6, 96, 20);
    ctx.fillStyle = '#333';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(characters.battery.name, x, y + r + 8);
  }

  function drawDevice(x, y, r, target) {
    // Device with whimsical plug and target number
    ctx.save();
    ctx.translate(x, y);
    // main circle
    ctx.fillStyle = '#C0F2D8';
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fill();

    // bolt icon
    ctx.fillStyle = '#3A86FF';
    ctx.beginPath();
    ctx.moveTo(-6, -18);
    ctx.lineTo(6, -18);
    ctx.lineTo(0, 6);
    ctx.lineTo(8, 6);
    ctx.lineTo(-2, 18);
    ctx.lineTo(0, 2);
    ctx.lineTo(-8, 2);
    ctx.closePath();
    ctx.fill();

    // target text
    ctx.fillStyle = '#073B4C';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`${target}C`, 0, 42);

    ctx.restore();

    // helper name
    ctx.fillStyle = '#333';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Gizmo', x, y + r + 12);
  }

  function drawNode(n, used) {
    // node orb with number inside
    ctx.save();
    ctx.translate(n.x, n.y);
    // outer glow
    const glow = ctx.createRadialGradient(0, 0, 4, 0, 0, n.r + 12);
    glow.addColorStop(0, used ? 'rgba(200,200,200,0.18)' : 'rgba(255,255,255,0.3)');
    glow.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0, 0, n.r + 14, 0, Math.PI * 2);
    ctx.fill();

    // circle
    ctx.beginPath();
    ctx.fillStyle = used ? '#E8EAF6' : '#FFFFFF';
    ctx.strokeStyle = used ? '#AAB7D6' : '#8DA1DF';
    ctx.lineWidth = 3;
    ctx.arc(0, 0, n.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // sign or number
    ctx.fillStyle = used ? '#7B8FB8' : '#2B3A67';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    if (typeof n.val === 'number') {
      const prefix = n.val > 0 ? '+' : '';
      ctx.fillText(`${prefix}${n.val}`, 0, 6);
    } else {
      ctx.fillText(`${n.val}`, 0, 6);
    }

    // tiny sparkles
    ctx.fillStyle = 'rgba(255,210,0,0.14)';
    ctx.beginPath();
    ctx.ellipse(-n.r / 2, -n.r / 2, 6, 3, Math.PI / 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawSpark() {
    // Glow circle that moves smoothly
    ctx.save();
    const gradient = ctx.createRadialGradient(spark.x, spark.y, 0, spark.x, spark.y, 28);
    gradient.addColorStop(0, 'rgba(255,246,204,0.9)');
    gradient.addColorStop(1, 'rgba(255,246,204,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(spark.x, spark.y, 28, 0, Math.PI * 2);
    ctx.fill();

    // core
    ctx.beginPath();
    ctx.fillStyle = '#FFD166';
    ctx.arc(spark.x, spark.y, spark.r, 0, Math.PI * 2);
    ctx.fill();

    // little tail flicker
    ctx.strokeStyle = 'rgba(255,200,80,0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(spark.x - 6, spark.y + 10);
    ctx.lineTo(spark.x + 10, spark.y + 18);
    ctx.stroke();
    ctx.restore();
  }

  function drawTopBar() {
    // top area with level and audio status
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.fillRect(0, 0, WIDTH, 64);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.strokeRect(0, 0, WIDTH, 64);

    ctx.fillStyle = '#073B4C';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Spark Squad - Level ${level}`, 14, 28);

    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#16697A';
    ctx.fillText('Theme: Electricity • Math: Addition/Subtraction', 14, 46);

    // audio indicator icon
    ctx.save();
    const ax = WIDTH - 60;
    const ay = 22;
    ctx.translate(ax, ay);
    ctx.fillStyle = muted ? '#bbb' : '#2B8A8A';
    ctx.strokeStyle = '#1C3B3B';
    ctx.lineWidth = 1;
    // speaker box
    ctx.beginPath();
    ctx.moveTo(-12, -8);
    ctx.lineTo(-4, -8);
    ctx.lineTo(4, -14);
    ctx.lineTo(4, 14);
    ctx.lineTo(-4, 8);
    ctx.lineTo(-12, 8);
    ctx.closePath();
    ctx.fill();
    // waves if unmuted
    if (!muted) {
      ctx.beginPath();
      ctx.strokeStyle = '#54B4B4';
      ctx.lineWidth = 2;
      ctx.arc(8, 0, 8 + Math.sin(audioIndicatorPulse) * 1.5, -0.6, 0.6);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#E07A5F';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(12, -10);
      ctx.lineTo(-2, 12);
      ctx.moveTo(-2, -10);
      ctx.lineTo(12, 12);
      ctx.stroke();
    }
    ctx.restore();

    // small help hint
    ctx.fillStyle = '#3A3A3A';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Arrows/WASD to move, Space/Enter to use node, M mute, H help', WIDTH - 14, 46);
  }

  // helper: rounded rectangle
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function drawMessagePanel() {
    // bottom panel with status and hints
    ctx.fillStyle = 'rgba(255,255,255,0.72)';
    roundRect(ctx, 10, HEIGHT - 100, WIDTH - 20, 90, 10);
    ctx.fill();

    ctx.fillStyle = '#233044';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    const wrapText = (text, x, y, maxW, lineH) => {
      const words = text.split(' ');
      let line = '';
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxW && n > 0) {
          ctx.fillText(line, x, y);
          line = words[n] + ' ';
          y += lineH;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, y);
    };
    wrapText(message, 28, HEIGHT - 70, WIDTH - 80, 18);

    // keyboard hint icon
    ctx.fillStyle = '#2B8A8A';
    ctx.fillRect(WIDTH - 140, HEIGHT - 86, 110, 58);
    ctx.fillStyle = '#FFF';
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Interact: Space / Enter', WIDTH - 85, HEIGHT - 50);
    ctx.fillText('Mute: M  Help: H', WIDTH - 85, HEIGHT - 34);
  }

  // ---------- Update Loop ----------
  let lastTime = performance.now();
  function update(now) {
    const dt = Math.min(50, now - lastTime) / 16.666;
    lastTime = now;

    // movement input
    let dx = 0;
    let dy = 0;
    if (keys['arrowleft'] || keys['a']) dx -= 1;
    if (keys['arrowright'] || keys['d']) dx += 1;
    if (keys['arrowup'] || keys['w']) dy -= 1;
    if (keys['arrowdown'] || keys['s']) dy += 1;
    // normalize
    if (dx !== 0 || dy !== 0) {
      const len = Math.sqrt(dx * dx + dy * dy);
      dx /= len;
      dy /= len;
      spark.vx += dx * spark.speed * 0.2 * dt;
      spark.vy += dy * spark.speed * 0.2 * dt;
    } else {
      // gentle drag
      spark.vx *= 0.92;
      spark.vy *= 0.92;
    }

    // clamp velocity
    spark.vx = Math.max(-6, Math.min(6, spark.vx));
    spark.vy = Math.max(-6, Math.min(6, spark.vy));

    spark.x += spark.vx;
    spark.y += spark.vy;

    // bounds
    spark.x = Math.max(16, Math.min(WIDTH - 16, spark.x));
    spark.y = Math.max(80, Math.min(HEIGHT - 16, spark.y));

    // audio indicator pulse increment
    audioIndicatorPulse += 0.09;

    // message timer
    if (msgTimer > 0) msgTimer--;

    // render
    render();

    requestAnimationFrame(update);
  }

  // ---------- Render ----------
  function render() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawTopBar();

    // left battery and right device
    drawBattery(battery.x, battery.y, battery.radius, battery.charge);
    drawDevice(device.x, device.y, device.radius, device.target);

    // nodes
    nodes.forEach((n, i) => {
      drawNode(n, usedNodes.has(i));
    });

    // spark
    drawSpark();

    // draw path ghost to nearest node (visual aid)
    let nearest = null;
    let minD = Infinity;
    for (let i = 0; i < nodes.length; i++) {
      if (usedNodes.has(i)) continue;
      const n = nodes[i];
      const d = Math.hypot(spark.x - n.x, spark.y - n.y);
      if (d < minD) {
        minD = d;
        nearest = n;
      }
    }
    if (nearest && minD < 220) {
      ctx.strokeStyle = 'rgba(58,134,255,0.18)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(spark.x, spark.y);
      ctx.quadraticCurveTo((spark.x + nearest.x) / 2, (spark.y + nearest.y) / 2 - 40, nearest.x, nearest.y);
      ctx.stroke();
    }

    // instructions and message panel
    drawMessagePanel();

    // help overlay if requested
    if (showHelp || msgTimer > 0) {
      // small translucent hint block near center if help
      if (showHelp) {
        ctx.fillStyle = 'rgba(255,255,255,0.88)';
        roundRect(ctx, 180, 74, 360, 110, 12);
        ctx.fill();
        ctx.fillStyle = '#1a3b3b';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('How to Play', WIDTH / 2, 100);
        ctx.font = '12px sans-serif';
        ctx.fillText('1) Move the spark with Arrow keys or WASD.', WIDTH / 2, 122);
        ctx.fillText('2) Press Space or Enter when touching a number node to change the battery charge.', WIDTH / 2, 142);
        ctx.fillText('3) When battery charge equals device target, go to the device and press Enter to finish the level.', WIDTH / 2, 162);
      }
    }
  }

  // ---------- Initialization ----------
  function init() {
    // Focus canvas for keyboard controls
    canvas.focus();

    // Start the first level
    generateLevel(level);

    // Start update loop
    lastTime = performance.now();
    requestAnimationFrame(update);

    // Announce starting instructions
    announce('Spark Squad started. ' + message);
  }

  // ---------- Error Handling & Start on User Interaction for Audio ----------
  // Some browsers block audio until user gestures; attach a one-time listener to resume/resumeAudioIfNeeded
  function initOnFirstGesture() {
    resumeAudioIfNeeded();
    canvas.removeEventListener('pointerdown', initOnFirstGesture);
    canvas.removeEventListener('mousedown', initOnFirstGesture);
    canvas.removeEventListener('touchstart', initOnFirstGesture);
  }

  canvas.addEventListener('pointerdown', initOnFirstGesture);
  canvas.addEventListener('mousedown', initOnFirstGesture);
  canvas.addEventListener('touchstart', initOnFirstGesture);

  // Focus on click to ensure keyboard works
  canvas.addEventListener('click', () => {
    canvas.focus();
  });

  // Accessibility: provide a small keyboard-only instruction if focus enters
  canvas.addEventListener('focus', () => {
    announce('Canvas focused. Use arrow keys or WASD to move the spark. Press Space or Enter to interact with nodes or the device. Press H to toggle help.');
  });

  // Kick off game
  try {
    init();
  } catch (e) {
    console.error('Game initialization failed', e);
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = '#000';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('An error occurred while starting the game. Please try reloading the page.', WIDTH / 2, HEIGHT / 2);
    announce('Game failed to start. Please reload the page.');
  }
})();
---

