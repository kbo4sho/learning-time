{
  "generated_date": "2025-08-26",
  "generated_timestamp": "2025-08-26T00:21:20.287716",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 7672,
  "game_filename": "2025-08-26.js",
  "game_size_bytes": 21836,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Game of the Day: Electricity Math Adventure\n// Renders inside element with id \"game-of-the-day-stage\"\n// Canvas 720x480, Web Audio API sounds, keyboard accessibility, canvas-only graphics\n\n(() => {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const MAX_BUBBLES = 6;\n  const TARGET_MIN = 6;\n  const TARGET_MAX = 15;\n  const FONT_FAMILY = \"16px sans-serif\";\n\n  // Get container element\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Cannot find element with id 'game-of-the-day-stage'.\");\n    return;\n  }\n  // Make container focusable and set ARIA attributes for accessibility\n  container.setAttribute(\"tabindex\", \"0\");\n  container.setAttribute(\"role\", \"application\");\n  container.setAttribute(\n    \"aria-label\",\n    \"Electric Sparks math game. Use keyboard or mouse to select number bubbles and sum to the target voltage.\"\n  );\n  container.style.position = \"relative\";\n  container.style.outline = \"none\";\n\n  // Create a visually-hidden status div for screen readers\n  const statusDiv = document.createElement(\"div\");\n  statusDiv.setAttribute(\"role\", \"status\");\n  statusDiv.setAttribute(\"aria-live\", \"polite\");\n  statusDiv.style.position = \"absolute\";\n  statusDiv.style.left = \"-9999px\";\n  statusDiv.style.width = \"1px\";\n  statusDiv.style.height = \"1px\";\n  statusDiv.style.overflow = \"hidden\";\n  container.appendChild(statusDiv);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = \"block\";\n  canvas.style.background = \"#F6FBFF\";\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let audioEnabled = true;\n  let bgHum = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    audioCtx = new AudioContext();\n  } catch (e) {\n    console.warn(\"Web Audio API not available or blocked:\", e);\n    audioEnabled = false;\n    audioCtx = null;\n  }\n\n  // Audio utilities\n  function safeCreateGain() {\n    if (!audioEnabled || !audioCtx) return null;\n    try {\n      return audioCtx.createGain();\n    } catch (e) {\n      console.warn(\"Error creating gain:\", e);\n      audioEnabled = false;\n      return null;\n    }\n  }\n\n  function playTone({ freq = 440, type = \"sine\", duration = 0.2, gain = 0.08, detune = 0 }) {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      o.type = type;\n      o.frequency.value = freq;\n      o.detune.value = detune;\n      const g = safeCreateGain();\n      if (!g) return;\n      g.gain.setValueAtTime(gain, audioCtx.currentTime);\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      o.start();\n      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);\n      o.stop(audioCtx.currentTime + duration + 0.02);\n    } catch (e) {\n      console.warn(\"Error playing tone:\", e);\n      audioEnabled = false;\n    }\n  }\n\n  function playCorrect() {\n    // Pleasant arpeggio\n    playTone({ freq: 660, type: \"sine\", duration: 0.12, gain: 0.06 });\n    setTimeout(() => playTone({ freq: 880, type: \"sine\", duration: 0.16, gain: 0.06 }), 110);\n    setTimeout(() => playTone({ freq: 990, type: \"sine\", duration: 0.18, gain: 0.06 }), 240);\n  }\n\n  function playWrong() {\n    // Short buzzer using square and frequency drop\n    playTone({ freq: 300, type: \"square\", duration: 0.12, gain: 0.12 });\n    setTimeout(() => playTone({ freq: 180, type: \"square\", duration: 0.12, gain: 0.09 }), 80);\n  }\n\n  function startBackgroundHum() {\n    if (!audioEnabled || !audioCtx) return;\n    stopBackgroundHum();\n    try {\n      const o = audioCtx.createOscillator();\n      o.type = \"sine\";\n      o.frequency.value = 60;\n      const g = safeCreateGain();\n      if (!g) return;\n      g.gain.value = 0.01;\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = \"lowpass\";\n      filter.frequency.value = 400;\n      o.connect(filter);\n      filter.connect(g);\n      g.connect(audioCtx.destination);\n      o.start();\n      bgHum = { osc: o, gain: g, filter };\n    } catch (e) {\n      console.warn(\"Error starting background hum:\", e);\n      audioEnabled = false;\n    }\n  }\n\n  function stopBackgroundHum() {\n    if (!bgHum) return;\n    try {\n      bgHum.gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);\n      bgHum.osc.stop(audioCtx.currentTime + 0.22);\n    } catch (e) {\n      // ignore\n    }\n    bgHum = null;\n  }\n\n  // Game state\n  let bubbles = [];\n  let target = 10;\n  let currentSum = 0;\n  let score = 0;\n  let attemptsLeft = 3;\n  let selectedIndex = 0;\n  let message = \"Welcome! Select bubbles summing to the battery voltage.\";\n  let level = 1;\n  let sparkX = WIDTH * 0.15;\n  let sparkY = HEIGHT * 0.5;\n  let sparkAnim = 0;\n  let muted = false;\n  let showAudioIndicator = true;\n\n  // Utility random numbers\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Initialize level\n  function setupLevel(lv = 1) {\n    level = lv;\n    target = randInt(TARGET_MIN + lv - 1, Math.min(TARGET_MAX + lv - 1, TARGET_MAX + 4));\n    bubbles = [];\n    const count = Math.min(MAX_BUBBLES, 3 + Math.floor(Math.random() * 4));\n    // create bubbles with values ensuring there is at least one combination equal to target\n    // naive approach: pick some values, then adjust one to ensure solution\n    for (let i = 0; i < count; i++) {\n      bubbles.push({\n        value: randInt(1, Math.max(3, Math.floor(target / 2))),\n        x: WIDTH * 0.5 + Math.cos((i / count) * Math.PI * 2) * 160 + randInt(-30, 30),\n        y: HEIGHT * 0.35 + Math.sin((i / count) * Math.PI * 2) * 80 + randInt(-20, 20),\n        picked: false,\n        wobble: Math.random() * Math.PI * 2\n      });\n    }\n    // Ensure solvable: pick a subset and set their sum to target by adjusting last item's value\n    const subsetSize = Math.min(3, bubbles.length);\n    let sum = 0;\n    for (let i = 0; i < subsetSize - 1; i++) {\n      sum += bubbles[i].value;\n    }\n    const lastNeeded = Math.max(1, target - sum);\n    bubbles[subsetSize - 1].value = lastNeeded;\n    // reset other state\n    currentSum = 0;\n    attemptsLeft = 3;\n    selectedIndex = 0;\n    score = Math.max(0, score);\n    sparkX = WIDTH * 0.15;\n    sparkY = HEIGHT * 0.5;\n    message = `Level ${level}. Help Sparky reach ${target} volts!`;\n    announce(message);\n  }\n\n  // Announce via ARIA friendly status\n  function announce(text) {\n    statusDiv.textContent = text;\n  }\n\n  // Drawing helpers\n  function drawRoundedRect(x, y, w, h, r = 8, fillStyle = \"#fff\", strokeStyle = \"#000\") {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fillStyle = fillStyle;\n    ctx.fill();\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n  }\n\n  // Draw characters using canvas only\n  function drawSparky(x, y, size = 48, awake = true) {\n    // Body (spark)\n    ctx.save();\n    ctx.translate(x, y);\n    // glow\n    const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 1.5);\n    grd.addColorStop(0, \"rgba(255,210,100,0.6)\");\n    grd.addColorStop(1, \"rgba(255,210,100,0)\");\n    ctx.fillStyle = grd;\n    ctx.beginPath();\n    ctx.arc(0, 0, size * 1.2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Zigzag spark lines\n    ctx.beginPath();\n    ctx.moveTo(-size * 0.6, -size * 0.2);\n    ctx.lineTo(-size * 0.2, -size * 0.6);\n    ctx.lineTo(size * 0.1, -size * 0.1);\n    ctx.lineTo(size * 0.5, -size * 0.3);\n    ctx.lineTo(size * 0.1, size * 0.2);\n    ctx.lineTo(size * 0.6, size * 0.6);\n    ctx.strokeStyle = \"#FFD66B\";\n    ctx.lineWidth = 4;\n    ctx.lineJoin = \"round\";\n    ctx.stroke();\n\n    // face\n    ctx.fillStyle = awake ? \"#222\" : \"#666\";\n    ctx.beginPath();\n    ctx.arc(-8, -4, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(12, -6, 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Smile\n    ctx.beginPath();\n    ctx.strokeStyle = \"#332200\";\n    ctx.lineWidth = 2;\n    ctx.arc(2, 6, 8, 0, Math.PI);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  function drawBulb(x, y, lit = false) {\n    ctx.save();\n    ctx.translate(x, y);\n    // bulb glass\n    ctx.beginPath();\n    ctx.ellipse(0, -10, 32, 40, 0, 0, Math.PI * 2);\n    ctx.fillStyle = lit ? \"rgba(255,245,170,0.95)\" : \"rgba(240,255,255,0.9)\";\n    ctx.fill();\n    ctx.strokeStyle = lit ? \"#FFD66B\" : \"#C0E7FF\";\n    ctx.lineWidth = 3;\n    ctx.stroke();\n\n    // filament (wacky)\n    ctx.beginPath();\n    ctx.moveTo(-12, -6);\n    ctx.quadraticCurveTo(0, -24, 12, -6);\n    ctx.strokeStyle = lit ? \"#FFAA33\" : \"#A0C0D0\";\n    ctx.lineWidth = 3;\n    ctx.stroke();\n\n    // base\n    drawRoundedRect(-24, 20, 48, 14, 3, \"#B0B0B0\", \"#888\");\n\n    ctx.restore();\n  }\n\n  function drawWire(x1, y1, x2, y2, on = false) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    const midx = (x1 + x2) / 2;\n    ctx.quadraticCurveTo(midx, y1 - 30, x2, y2);\n    ctx.strokeStyle = on ? \"#FFD66B\" : \"#8BB4D0\";\n    ctx.lineWidth = on ? 6 : 4;\n    ctx.lineCap = \"round\";\n    ctx.stroke();\n    // little sparks along wire if on\n    if (on) {\n      for (let t = 0; t <= 1; t += 0.2) {\n        const sx = x1 + (x2 - x1) * t + Math.sin((Date.now() / 200) + t * 10) * 4;\n        const sy = y1 + (y2 - y1) * t + Math.cos((Date.now() / 200) + t * 10) * 4;\n        ctx.beginPath();\n        ctx.fillStyle = \"#FFF1C4\";\n        ctx.arc(sx, sy, 3, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  }\n\n  // Draw bubble with number\n  function drawBubble(b, index, isSelected) {\n    const { x, y, value, picked } = b;\n    ctx.save();\n    ctx.translate(x, y);\n    const wob = Math.sin(b.wobble + Date.now() / 400) * 2;\n    ctx.translate(0, wob);\n    // outer ring\n    ctx.beginPath();\n    ctx.arc(0, 0, picked ? 34 : 30, 0, Math.PI * 2);\n    ctx.fillStyle = picked ? \"#E8FDF5\" : \"#EAF6FF\";\n    ctx.fill();\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = isSelected ? \"#FFCC55\" : \"#8BB4D0\";\n    ctx.stroke();\n    // inner pattern (circuity)\n    ctx.beginPath();\n    ctx.moveTo(-12, 0);\n    ctx.lineTo(0, -10);\n    ctx.lineTo(12, 0);\n    ctx.moveTo(0, 10);\n    ctx.lineTo(0, -10);\n    ctx.strokeStyle = \"#C0E7FF\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // number\n    ctx.fillStyle = \"#133D4D\";\n    ctx.font = \"20px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(String(value), 0, 0);\n\n    // small label for keyboard index\n    ctx.fillStyle = \"#666\";\n    ctx.font = \"12px sans-serif\";\n    ctx.fillText(String(index + 1), -20, -20);\n\n    ctx.restore();\n  }\n\n  // Main render\n  function render() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // background grid with wacky nodes\n    ctx.fillStyle = \"#EAF8FF\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // subtle circuit lines background\n    ctx.save();\n    ctx.lineWidth = 1;\n    for (let i = 0; i < 6; i++) {\n      ctx.beginPath();\n      ctx.strokeStyle = i % 2 === 0 ? \"rgba(200,230,255,0.6)\" : \"rgba(220,245,255,0.4)\";\n      const y = 80 + i * 60 + Math.sin(Date.now() / 1000 + i) * 6;\n      ctx.moveTo(40, y);\n      ctx.bezierCurveTo(160, y - 20, 320, y + 20, 680, y);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // left: power station\n    drawRoundedRect(30, 60, 180, 140, 12, \"#FFF8E6\", \"#FFDB7B\");\n    ctx.fillStyle = \"#3B6B86\";\n    ctx.font = \"18px sans-serif\";\n    ctx.fillText(\"Battery Lab\", 55, 85);\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = \"#333\";\n    ctx.fillText(`Target: ${target} V`, 60, 110);\n    ctx.fillText(`Sum: ${currentSum} V`, 60, 132);\n    ctx.fillText(`Attempts: ${attemptsLeft}`, 60, 154);\n    ctx.fillText(`Score: ${score}`, 60, 174);\n\n    // big bulb on right\n    const bulbX = WIDTH - 140;\n    const bulbY = HEIGHT * 0.5 - 10;\n    const bulbLit = currentSum === target;\n    drawWire(220, 130, bulbX - 20, bulbY - 20, bulbLit);\n    drawBulb(bulbX, bulbY, bulbLit);\n\n    // Sparky near battery\n    drawSparky(sparkX + Math.sin(sparkAnim) * 4, sparkY, 40, attemptsLeft > 0);\n\n    // draw bubbles\n    bubbles.forEach((b, i) => drawBubble(b, i, i === selectedIndex));\n\n    // draw instruction semi-transparent box at bottom\n    drawRoundedRect(40, HEIGHT - 110, WIDTH - 80, 90, 10, \"rgba(255,255,255,0.9)\", \"#CDE9FF\");\n    ctx.fillStyle = \"#0D3A49\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Instructions: Select number bubbles to add up to the battery voltage.\", 60, HEIGHT - 78);\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(\"Click a bubble or press 1-6. Use \u2190 \u2192 to move, Space/Enter to pick. R to reset, M to mute.\", 60, HEIGHT - 56);\n    ctx.fillStyle = \"#555\";\n    ctx.font = \"12px sans-serif\";\n    ctx.fillText(message, 60, HEIGHT - 34);\n\n    // small audio indicator\n    ctx.save();\n    ctx.translate(WIDTH - 40, 20);\n    ctx.beginPath();\n    ctx.rect(-18, -12, 36, 24);\n    ctx.fillStyle = muted || !audioEnabled ? \"#F2F2F2\" : \"#FFF6D6\";\n    ctx.fill();\n    ctx.strokeStyle = \"#CCC\";\n    ctx.stroke();\n    ctx.fillStyle = muted || !audioEnabled ? \"#888\" : \"#FFB64D\";\n    ctx.font = \"12px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(muted || !audioEnabled ? \"Muted\" : \"Audio\", 0, 2);\n    ctx.restore();\n\n    // visual cue for audio (small speaker waves if enabled)\n    if (!muted && audioEnabled) {\n      ctx.save();\n      ctx.translate(WIDTH - 90, 22);\n      ctx.beginPath();\n      ctx.arc(-6, 0, 6, 0.2 * Math.PI, 1.8 * Math.PI);\n      ctx.strokeStyle = \"#FFBB55\";\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(6, 0, 10, 0.2 * Math.PI, 1.8 * Math.PI);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    // small decorative wacky elements: floating little electrons\n    for (let e = 0; e < 5; e++) {\n      const ex = (e * 130 + (Date.now() / 6)) % WIDTH;\n      const ey = 40 + ((e * 73) % 420) + Math.sin(Date.now() / 300 + e) * 8;\n      ctx.beginPath();\n      ctx.fillStyle = \"rgba(255,255,255,0.7)\";\n      ctx.arc(ex, ey, 4, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = \"rgba(200,230,255,0.8)\";\n      ctx.stroke();\n    }\n  }\n\n  // Game logic: pick bubble\n  function pickBubble(i) {\n    if (i < 0 || i >= bubbles.length) return;\n    const b = bubbles[i];\n    if (b.picked) {\n      message = \"You already used that charge bubble.\";\n      announce(message);\n      return;\n    }\n    // pick it\n    const newSum = currentSum + b.value;\n    b.picked = true;\n    if (!muted && audioEnabled) playTone({ freq: 520, type: \"triangle\", duration: 0.06, gain: 0.05 });\n    // animate spark toward bulb proportional to sum\n    // update sum then check\n    currentSum = newSum;\n    message = `Added ${b.value} V. Sum is now ${currentSum} V.`;\n    announce(message);\n\n    // If exceed target\n    if (currentSum > target) {\n      attemptsLeft -= 1;\n      message = `Oh no! Overheated: ${currentSum} > ${target}. Attempts left: ${attemptsLeft}.`;\n      announce(message);\n      if (!muted && audioEnabled) playWrong();\n      // flash red by temporarily setting message color \u2014 handled by draw text\n      // reset bubbles' picked state and partial reset behavior\n      setTimeout(() => {\n        // reset: unpick all except maybe keep them used? easier: unpick all, reduce score\n        bubbles.forEach((bb) => (bb.picked = false));\n        currentSum = 0;\n        selectedIndex = 0;\n        if (attemptsLeft <= 0) {\n          message = `Sparky needs a break! Press R to try again.`;\n          announce(message);\n          if (!muted && audioEnabled) {\n            playTone({ freq: 220, type: \"sine\", duration: 0.25, gain: 0.04 });\n          }\n        } else {\n          message = `Try a different combination to reach ${target} V.`;\n          announce(message);\n        }\n      }, 800);\n      score = Math.max(0, score - 1);\n      return;\n    }\n\n    // If exact\n    if (currentSum === target) {\n      score += 1;\n      message = `Perfect! The bulb lights up at ${target} V! Press R for next level.`;\n      announce(message);\n      if (!muted && audioEnabled) playCorrect();\n      // animate bulb lit and spark travel\n      // set spark close to bulb\n      sparkX = WIDTH * 0.55;\n      sparkY = HEIGHT * 0.4;\n      // prepare next level after short delay\n      setTimeout(() => {\n        setupLevel(level + 1);\n        if (!muted && audioEnabled) playTone({ freq: 480, type: \"sawtooth\", duration: 0.12, gain: 0.06 });\n      }, 1600);\n      return;\n    }\n\n    // otherwise continue\n    // tiny reward ping\n    if (!muted && audioEnabled) playTone({ freq: 660 - currentSum * 8, type: \"sine\", duration: 0.08, gain: 0.04 });\n    // move spark a bit\n    sparkX += 30;\n    if (sparkX > WIDTH * 0.45) sparkX = WIDTH * 0.45;\n  }\n\n  // mouse handling: click on bubble\n  function onCanvasClick(e) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    // check bubbles\n    for (let i = 0; i < bubbles.length; i++) {\n      const b = bubbles[i];\n      const dx = mx - b.x;\n      const dy = my - b.y;\n      if (dx * dx + dy * dy <= 34 * 34) {\n        selectedIndex = i;\n        pickBubble(i);\n        return;\n      }\n    }\n    // click other areas: audio toggle if clicked on audio indicator\n    if (mx > WIDTH - 120 && mx < WIDTH - 20 && my > 0 && my < 40) {\n      toggleMute();\n      return;\n    }\n  }\n\n  // keyboard handling\n  function onContainerKeyDown(e) {\n    // ensure audio context resumed on user gesture\n    if (audioEnabled && audioCtx && audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch(() => {});\n    }\n    if (e.key === \"ArrowRight\") {\n      selectedIndex = (selectedIndex + 1) % bubbles.length;\n      e.preventDefault();\n      announce(`Selected bubble ${selectedIndex + 1} with ${bubbles[selectedIndex].value} volts.`);\n    } else if (e.key === \"ArrowLeft\") {\n      selectedIndex = (selectedIndex - 1 + bubbles.length) % bubbles.length;\n      e.preventDefault();\n      announce(`Selected bubble ${selectedIndex + 1} with ${bubbles[selectedIndex].value} volts.`);\n    } else if (e.key === \"Enter\" || e.key === \" \" || e.key === \"Spacebar\") {\n      pickBubble(selectedIndex);\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === \"r\") {\n      setupLevel(1);\n      announce(\"Game reset. New level started.\");\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === \"m\") {\n      toggleMute();\n      e.preventDefault();\n    } else {\n      // number keys 1-6\n      const num = parseInt(e.key, 10);\n      if (!isNaN(num) && num >= 1 && num <= bubbles.length) {\n        selectedIndex = num - 1;\n        pickBubble(selectedIndex);\n        e.preventDefault();\n      }\n    }\n  }\n\n  // Mute toggle\n  function toggleMute() {\n    muted = !muted;\n    if (muted) {\n      stopBackgroundHum();\n      message = \"Audio muted. Press M to unmute.\";\n      announce(\"Audio muted.\");\n    } else {\n      if (audioEnabled) startBackgroundHum();\n      message = \"Audio enabled. Sounds on!\";\n      announce(\"Audio enabled.\");\n      // small sound to confirm\n      if (audioEnabled) playTone({ freq: 660, duration: 0.08, gain: 0.05 });\n    }\n  }\n\n  // Game loop\n  let lastTime = 0;\n  function loop(ts) {\n    const dt = (ts - lastTime) / 1000 || 0;\n    lastTime = ts;\n    // animate wobble\n    bubbles.forEach((b) => (b.wobble += dt * 2));\n    sparkAnim += dt * 6;\n    // gentle movement of spark toward bulb when lit\n    if (currentSum === target) {\n      sparkX += (WIDTH - 200 - sparkX) * dt * 2;\n      sparkY += (HEIGHT * 0.42 - sparkY) * dt * 2;\n    } else {\n      // idle breathing\n      sparkX += Math.sin(Date.now() / 400) * 0.01;\n    }\n    render();\n    requestAnimationFrame(loop);\n  }\n\n  // Event listeners\n  canvas.addEventListener(\"click\", onCanvasClick);\n  container.addEventListener(\"keydown\", onContainerKeyDown);\n  // make sure container gets focus so keyboard works\n  container.addEventListener(\"mousedown\", () => container.focus());\n  container.addEventListener(\"touchstart\", () => container.focus());\n\n  // Initialize\n  function startGame() {\n    // Start background hum if possible and not muted\n    if (audioEnabled) {\n      try {\n        startBackgroundHum();\n      } catch (e) {\n        console.warn(\"Failed to start background audio:\", e);\n        audioEnabled = false;\n      }\n    }\n    setupLevel(1);\n    requestAnimationFrame(loop);\n  }\n\n  // Graceful fallback if audio is blocked (autoplay policy)\n  if (audioEnabled && audioCtx && audioCtx.state === \"suspended\") {\n    // wait for first user gesture to resume\n    message = \"Tap or press any key to enable sound and start the game.\";\n    announce(message);\n    const resumeHandler = () => {\n      if (audioCtx && audioCtx.state === \"suspended\") {\n        audioCtx.resume().catch(() => {\n          audioEnabled = false;\n        });\n      }\n      startGame();\n      window.removeEventListener(\"click\", resumeHandler);\n      window.removeEventListener(\"keydown\", resumeHandler);\n      window.removeEventListener(\"touchstart\", resumeHandler);\n    };\n    window.addEventListener(\"click\", resumeHandler);\n    window.addEventListener(\"keydown\", resumeHandler);\n    window.addEventListener(\"touchstart\", resumeHandler);\n  } else {\n    startGame();\n  }\n\n  // Expose a small API on container for testing or external controls (non-essential)\n  container.gameAPI = {\n    reset: () => setupLevel(1),\n    mute: () => {\n      if (!muted) toggleMute();\n    },\n    unmute: () => {\n      if (muted) toggleMute();\n    },\n    getState: () => ({ target, currentSum, score, level, attemptsLeft })\n  };\n\n  // Error handling demo: if any uncaught errors, show message in status\n  window.addEventListener(\"error\", (ev) => {\n    message = \"An error occurred. Try reloading the game.\";\n    announce(message);\n    console.error(\"Game error:\", ev.error);\n  });\n})();\n---\n",
  "improve_response_tokens": 15960,
  "formatted_code": true,
  "formatting_response_tokens": 17621,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}