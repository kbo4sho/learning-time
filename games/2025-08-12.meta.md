# Game of the Day - 2025-08-12

## Metadata
- **Generated Date:** 2025-08-12
- **Generated Time:** 2025-08-12T00:22:33.914075
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-12.js
- **File Size:** 35686 bytes
- **Tokens Used:** 11583

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-12.js` - The playable game
- `2025-08-12.meta.json` - Machine-readable metadata
- `2025-08-12.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22915

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 24262

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Electricity-themed Math Game for ages 7-9
// Renders inside element with ID "game-of-the-day-stage" using a 720x480 canvas.
// All visuals are drawn on canvas. All sounds generated with Web Audio API.
// Accessible via keyboard, includes aria-label instructions on canvas.

// Immediately-invoked function to avoid polluting global scope
(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const CONTAINER_ID = 'game-of-the-day-stage';

  // Utility: safe query and canvas setup
  const container = document.getElementById(CONTAINER_ID);
  if (!container) {
    console.error(`Container element with id "${CONTAINER_ID}" not found.`);
    return;
  }
  // Clear container
  container.innerHTML = '';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make focusable for keyboard controls
  canvas.style.outline = 'none';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label',
    'Sparky the Squirrel needs help powering houses! ' +
    'Use mouse or keyboard to pick battery cards (numbers) and drop them onto bulbs to match target sums. ' +
    'Arrow keys to select, Enter to pick/place, Space to toggle sound. ' +
    'Solve all bulbs to finish the level.'
  );
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Accessibility: live text fallback if available
  try {
    const live = document.createElement('div');
    live.setAttribute('aria-live', 'polite');
    live.style.position = 'absolute';
    live.style.left = '-9999px';
    live.style.width = '1px';
    live.style.height = '1px';
    live.style.overflow = 'hidden';
    container.appendChild(live);
    var liveRegion = live;
  } catch (e) {
    var liveRegion = null;
  }

  // Audio setup with error handling
  let audioEnabled = true;
  let audioCtx = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) {
      audioEnabled = false;
      throw new Error('Web Audio API not supported.');
    }
    audioCtx = new AudioContext();
  } catch (err) {
    console.warn('Audio context could not be created:', err);
    audioEnabled = false;
  }

  // We'll not start background oscillators until user interacts due to autoplay rules
  let audioSuspended = audioEnabled && audioCtx && audioCtx.state === 'suspended';

  // Master gain for controlling overall volume
  let masterGain = null;
  if (audioEnabled && audioCtx) {
    try {
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.18; // gentle volume
      masterGain.connect(audioCtx.destination);
    } catch (e) {
      console.warn('Audio master gain error:', e);
      audioEnabled = false;
      masterGain = null;
    }
  }

  // Background hum oscillator (gentle)
  let humOsc = null;
  let humStarted = false;
  function startBackgroundHum() {
    if (!audioEnabled || !audioCtx || !masterGain || humStarted) return;
    try {
      humOsc = audioCtx.createOscillator();
      const humGain = audioCtx.createGain();
      humOsc.type = 'sine';
      humOsc.frequency.value = 60; // 60 Hz hum - subtle
      humGain.gain.value = 0.02;
      humOsc.connect(humGain);
      // gentle low-pass
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 400;
      humGain.connect(filter);
      filter.connect(masterGain);
      humOsc.start();
      humStarted = true;
    } catch (e) {
      console.warn('background hum failed to start:', e);
    }
  }

  // Sound helpers: play beep, chime, buzz, spark
  function playBeep(freq = 880, duration = 0.18, type = 'sine') {
    if (!audioEnabled || !audioCtx || !masterGain) return Promise.resolve();
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      // envelope
      gain.gain.value = 0.0001;
      osc.connect(gain);
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = Math.max(600, freq * 1.2);
      gain.connect(filter);
      filter.connect(masterGain);
      const now = audioCtx.currentTime;
      gain.gain.cancelScheduledValues(now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.18, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      osc.start(now);
      osc.stop(now + duration + 0.02);
      return new Promise((resolve) => {
        osc.onended = resolve;
      });
    } catch (e) {
      console.warn('beep failed:', e);
    }
    return Promise.resolve();
  }

  function playChime() {
    if (!audioEnabled) return;
    // A little harmony arpeggio
    const freqs = [880, 660, 990];
    let t = 0;
    freqs.forEach((f, i) => {
      setTimeout(() => {
        playBeep(f, 0.18, 'triangle');
      }, i * 140);
    });
  }

  function playBuzz() {
    if (!audioEnabled) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc.type = 'square';
      osc.frequency.value = 120;
      gain.gain.value = 0.0001;
      osc.connect(filter);
      filter.connect(masterGain);
      filter.frequency.value = 800;
      const now = audioCtx.currentTime;
      gain.connect(filter);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      osc.connect(gain);
      osc.start(now);
      osc.stop(now + 0.18);
    } catch (e) {
      console.warn('buzz failed:', e);
    }
  }

  function playSpark() {
    if (!audioEnabled) return;
    try {
      const now = audioCtx.currentTime;
      const length = 0.06;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(1200, now);
      osc.frequency.exponentialRampToValueAtTime(300, now + length);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.18, now + length * 0.4);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + length);
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 800;
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start(now);
      osc.stop(now + length + 0.02);
    } catch (e) {
      console.warn('spark failed:', e);
    }
  }

  // Game objects and logic
  const state = {
    level: 1,
    score: 0,
    bulbs: [], // {x,y,target,connectedBatteries:[],lit:boolean}
    batteries: [], // {x,y,value,placedOn:bulbIndex or null, id}
    selectedBatteryIndex: 0, // keyboard focus index
    holdingBattery: null, // id of battery being held
    draggingBatteryId: null,
    mouse: { x: 0, y: 0, down: false },
    hintVisible: true,
    soundOn: !!audioEnabled,
    message: '',
    messageTimer: 0,
    roundActive: true
  };

  // Layout constants
  const leftArea = { x: 20, y: 90, w: 220, h: 360 };
  const rightArea = { x: 260, y: 60, w: 440, h: 400 };

  // Character definitions for fun
  const characters = {
    sparky: { // squirrel electrician
      x: 130, y: 420, scale: 0.9
    },
    volt: { // friendly lightbulb mascot
      x: 600, y: 420, scale: 1.0
    }
  };

  // Helpers for random generation
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Initialize a new level
  function initLevel(level = 1) {
    state.level = level;
    state.score = 0;
    state.bulbs = [];
    state.batteries = [];
    state.selectedBatteryIndex = 0;
    state.holdingBattery = null;
    state.draggingBatteryId = null;
    state.message = '';
    state.messageTimer = 0;
    state.roundActive = true;
    // number of bulbs increases slowly
    const bulbCount = Math.min(4, 2 + Math.floor((level - 1) / 2));
    // generate target sums for bulbs 5..15 appropriate to ages 7-9
    const targets = [];
    for (let i = 0; i < bulbCount; i++) {
      targets.push(randInt(5, 15));
    }
    // place bulbs in right area
    for (let i = 0; i < bulbCount; i++) {
      const bx = rightArea.x + 80 + (i % 2) * 220;
      const by = rightArea.y + 80 + Math.floor(i / 2) * 140;
      state.bulbs.push({
        x: bx,
        y: by,
        target: targets[i],
        connectedBatteries: [],
        lit: false,
        glow: 0
      });
    }
    // generate batteries: ensure solvability - create numbers that can combine to match targets
    // We'll produce batteries that include the digits needed
    let batteryValues = [];
    // First ensure each bulb can be matched by picking at most 3 batteries of 1-9
    for (let t of targets) {
      // create 1 or 2 or 3 numbers that sum to t
      const parts = randInt(1, 3);
      let remaining = t;
      const partsVals = [];
      for (let p = parts; p >= 1; p--) {
        let val;
        if (p === 1) {
          val = remaining;
        } else {
          // choose 1..min(9, remaining - (p-1)*1)
          const maxVal = Math.min(9, remaining - (p - 1));
          val = randInt(1, Math.max(1, maxVal));
        }
        partsVals.push(val);
        remaining -= val;
      }
      batteryValues = batteryValues.concat(partsVals);
    }
    // Add a few distractor batteries
    const targetBatteryCount = Math.max(6, batteryValues.length + 2);
    while (batteryValues.length < targetBatteryCount) {
      batteryValues.push(randInt(1, 9));
    }
    // shuffle
    for (let i = batteryValues.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [batteryValues[i], batteryValues[j]] = [batteryValues[j], batteryValues[i]];
    }
    // Create battery objects placed in left area grid
    const cols = 2;
    const rows = Math.ceil(batteryValues.length / cols);
    const spacingX = leftArea.w / cols;
    const spacingY = Math.min(80, leftArea.h / rows);
    for (let i = 0; i < batteryValues.length; i++) {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const bx = leftArea.x + spacingX * col + spacingX * 0.5;
      const by = leftArea.y + spacingY * row + spacingY * 0.5;
      state.batteries.push({
        id: 'b' + i,
        x: bx,
        y: by,
        baseX: bx,
        baseY: by,
        value: batteryValues[i],
        placedOn: null,
        pickedOffset: { x: 0, y: 0 },
        wobble: Math.random() * Math.PI * 2
      });
    }

    // announcement
    announce(`Level ${level}. Help Sparky light ${state.bulbs.length} houses!`);
  }

  // Accessibility announcement helper
  function announce(text) {
    if (liveRegion) {
      liveRegion.textContent = text;
      setTimeout(() => {
        liveRegion.textContent = '';
      }, 2000);
    }
    state.message = text;
    state.messageTimer = 160; // frames to display
  }

  // Drawing functions
  function clearScreen() {
    // calming gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#EAF6FF');
    g.addColorStop(1, '#FFFDF6');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  function drawHeader() {
    ctx.save();
    ctx.fillStyle = '#2a2a2a';
    ctx.font = '18px "Segoe UI", Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${state.score}`, 12, 24);
    ctx.fillText(`Level: ${state.level}`, 120, 24);
    ctx.textAlign = 'center';
    ctx.fillText('Electricity Math Lab — Connect batteries to match the bulb sums!', WIDTH / 2, 24);
    ctx.restore();
  }

  function drawSoundIcon() {
    ctx.save();
    const x = WIDTH - 36;
    const y = 20;
    ctx.fillStyle = state.soundOn ? '#ffdd57' : '#ddd';
    ctx.beginPath();
    ctx.arc(x, y, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#444';
    ctx.stroke();
    ctx.fillStyle = '#222';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(state.soundOn ? '♪' : '•', x, y);
    ctx.restore();
  }

  // Draw left area with batteries
  function drawBatteries() {
    for (let i = 0; i < state.batteries.length; i++) {
      const b = state.batteries[i];
      // if placed font slightly smaller; if dragging, follow mouse
      const isPicked = state.holdingBattery === b.id || state.draggingBatteryId === b.id;
      const x = isPicked ? state.mouse.x + b.pickedOffset.x : b.x;
      const y = isPicked ? state.mouse.y + b.pickedOffset.y : b.y;
      b.drawX = x; b.drawY = y;
      // card rectangle with playful edges
      ctx.save();
      // shadow
      ctx.fillStyle = 'rgba(20,20,20,0.08)';
      roundRect(ctx, x - 36, y - 28, 72, 56, 10, true, false);
      // card
      const cardColors = ['#fffef6', '#fff7f0', '#f0fff6', '#f7f5ff'];
      const fill = cardColors[i % cardColors.length];
      ctx.fillStyle = fill;
      roundRect(ctx, x - 36, y - 28, 72, 56, 10, true, true);
      // battery icon
      ctx.fillStyle = '#222';
      // small cap
      ctx.fillRect(x + 24, y - 10, 6, 20);
      // battery body stripes to indicate value visually
      const val = b.value;
      ctx.fillStyle = '#ffb74d';
      ctx.fillRect(x - 24, y - 12, 40 * Math.min(1, val / 9), 24);
      // number
      ctx.font = '20px "Segoe UI", Arial';
      ctx.fillStyle = '#222';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.value, x - 6, y);
      // selection ring if keyboard focus
      if (i === state.selectedBatteryIndex) {
        ctx.strokeStyle = '#2b8cff';
        ctx.lineWidth = 3;
        roundRect(ctx, x - 40, y - 32, 80, 64, 12, false, false);
      }
      // opacity if placed
      if (b.placedOn !== null) {
        ctx.globalAlpha = 0.6;
      }
      ctx.restore();
    }
  }

  // Draw bulbs and houses on right
  function drawBulbs() {
    for (let i = 0; i < state.bulbs.length; i++) {
      const bulb = state.bulbs[i];
      const x = bulb.x, y = bulb.y;
      // house base
      ctx.save();
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#c7d7ff';
      ctx.lineWidth = 2;
      roundRect(ctx, x - 60, y + 30, 120, 70, 10, true, true);
      // roof
      ctx.fillStyle = '#ffd1dc';
      ctx.beginPath();
      ctx.moveTo(x - 70, y + 30);
      ctx.lineTo(x, y - 10);
      ctx.lineTo(x + 70, y + 30);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      // bulb
      // glow effect if lit
      if (bulb.lit) {
        bulb.glow = Math.min(1, bulb.glow + 0.06);
      } else {
        bulb.glow = Math.max(0, bulb.glow - 0.06);
      }
      const glow = bulb.glow;
      if (glow > 0) {
        const g2 = ctx.createRadialGradient(x, y - 10, 4, x, y - 10, 80);
        g2.addColorStop(0, `rgba(255,250,200,${0.45 * glow})`);
        g2.addColorStop(1, 'rgba(255,250,200,0)');
        ctx.fillStyle = g2;
        ctx.beginPath();
        ctx.arc(x, y - 10, 80, 0, Math.PI * 2);
        ctx.fill();
      }
      // bulb body
      ctx.beginPath();
      ctx.fillStyle = bulb.lit ? '#fff9c4' : '#fff';
      ctx.arc(x, y - 10, 34, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#999';
      ctx.stroke();

      // filament/coils
      ctx.beginPath();
      ctx.strokeStyle = bulb.lit ? '#ffb300' : '#c0c0c0';
      ctx.lineWidth = 2;
      ctx.moveTo(x - 10, y - 2);
      ctx.quadraticCurveTo(x, y + 10, x + 10, y - 2);
      ctx.stroke();

      // socket
      ctx.fillStyle = '#cfcfcf';
      ctx.fillRect(x - 18, y + 24, 36, 18);
      ctx.strokeRect(x - 18, y + 24, 36, 18);

      // show target number
      ctx.fillStyle = '#333';
      ctx.font = '20px "Segoe UI", Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`Need ${bulb.target}`, x, y + 70);

      // connected battery icons around the bulb
      const count = bulb.connectedBatteries.length;
      for (let j = 0; j < count; j++) {
        const bid = bulb.connectedBatteries[j];
        const battery = state.batteries.find(bb => bb.id === bid);
        if (!battery) continue;
        const angle = -Math.PI / 2 + (j - (count - 1) / 2) * 0.5;
        const rx = x + Math.cos(angle) * 70;
        const ry = y + Math.sin(angle) * 70;
        ctx.save();
        ctx.fillStyle = '#fffef6';
        roundRect(ctx, rx - 20, ry - 14, 40, 28, 6, true, true);
        ctx.fillStyle = '#222';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(battery.value, rx, ry);
        ctx.restore();
      }

      // ring for accept area
      ctx.beginPath();
      ctx.strokeStyle = '#b0c4ff';
      ctx.lineWidth = 2;
      ctx.arc(x, y - 10, 52, 0, Math.PI * 2);
      ctx.stroke();

      // if lit, draw smiling face on bulb
      if (bulb.lit) {
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(x - 10, y - 14, 3, 0, Math.PI * 2);
        ctx.arc(x + 10, y - 14, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.arc(x, y - 6, 8, 0, Math.PI);
        ctx.stroke();
      }

      ctx.restore();
    }
  }

  // Draw connectors (lines) from battery to bulb if placed, and from held battery to mouse
  function drawConnectors() {
    ctx.save();
    ctx.lineWidth = 6;
    for (let b of state.batteries) {
      if (b.placedOn !== null) {
        const bulb = state.bulbs[b.placedOn];
        if (!bulb) continue;
        const sx = b.drawX || b.x;
        const sy = b.drawY || b.y;
        const tx = bulb.x;
        const ty = bulb.y - 10;
        // gradient line
        const grad = ctx.createLinearGradient(sx, sy, tx, ty);
        grad.addColorStop(0, '#f6b042');
        grad.addColorStop(1, '#ffd966');
        ctx.strokeStyle = grad;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        // nice curve
        ctx.quadraticCurveTo((sx + tx) / 2, sy - 40, tx, ty);
        ctx.stroke();
      }
    }
    // dragging line
    if (state.holdingBattery) {
      const bat = state.batteries.find(bb => bb.id === state.holdingBattery);
      if (bat) {
        const sx = state.mouse.x + bat.pickedOffset.x;
        const sy = state.mouse.y + bat.pickedOffset.y;
        const tx = state.mouse.x;
        const ty = state.mouse.y;
        ctx.strokeStyle = '#bdbdbd';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(tx, ty);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  // Draw characters: Sparky and Volt
  function drawCharacters(frame) {
    // Sparky the Squirrel electrician on left
    ctx.save();
    const s = characters.sparky;
    ctx.translate(s.x, s.y);
    ctx.scale(s.scale, s.scale);
    // body
    ctx.fillStyle = '#db8b3f';
    ctx.beginPath();
    ctx.ellipse(0, -8, 28, 36, 0, 0, Math.PI * 2);
    ctx.fill();
    // tail - wacky
    ctx.fillStyle = '#f0bfa0';
    ctx.beginPath();
    ctx.ellipse(-35, -26, 18, 32, -0.6, 0, Math.PI * 2);
    ctx.fill();
    // helmet
    ctx.fillStyle = '#2b8cff';
    ctx.beginPath();
    ctx.arc(0, -36, 18, Math.PI, 0, false);
    ctx.fill();
    // goggles
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(-6, -30, 6, 4, 0, 0, Math.PI * 2);
    ctx.ellipse(10, -30, 6, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.ellipse(-6, -30, 3, 2, 0, 0, Math.PI * 2);
    ctx.ellipse(10, -30, 3, 2, 0, 0, Math.PI * 2);
    ctx.fill();
    // wrench in hand
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(16, -10);
    ctx.lineTo(36, -18);
    ctx.stroke();
    ctx.restore();

    // Volt the lightbulb mascot on right
    ctx.save();
    const v = characters.volt;
    ctx.translate(v.x, v.y);
    ctx.scale(v.scale, v.scale);
    // body bulb
    ctx.fillStyle = '#fff9c4';
    ctx.beginPath();
    ctx.arc(0, -12, 28, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#f6bb00';
    ctx.lineWidth = 2;
    ctx.stroke();
    // face
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(-9, -18, 3, 0, Math.PI * 2);
    ctx.arc(9, -18, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.arc(0, -10, 8, 0, Math.PI);
    ctx.stroke();
    // little spark icon near Volt when sound is on
    if (state.soundOn) {
      ctx.fillStyle = '#ffb300';
      ctx.beginPath();
      ctx.moveTo(20, -40);
      ctx.lineTo(30, -28);
      ctx.lineTo(22, -30);
      ctx.lineTo(32, -18);
      ctx.lineTo(18, -26);
      ctx.fill();
    }
    ctx.restore();
  }

  // UI hints and messages
  function drawUI() {
    ctx.save();
    // instructions box
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    roundRect(ctx, 260, 8, 440, 56, 10, true, true);
    ctx.fillStyle = '#114b8c';
    ctx.font = '14px "Segoe UI", Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Pick batteries (numbers) and drop them onto bulbs to make the sums match.', 276, 28);
    ctx.fillText('Use arrows to select, Enter to pick/place, Space to toggle sound.', 276, 48);

    // message overlay
    if (state.messageTimer > 0 && state.message) {
      ctx.fillStyle = 'rgba(40,40,40,0.75)';
      roundRect(ctx, WIDTH / 2 - 180, 60, 360, 36, 8, true, true);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = '16px "Segoe UI", Arial';
      ctx.fillText(state.message, WIDTH / 2, 86);
    }

    // level progress
    const litCount = state.bulbs.filter(b => b.lit).length;
    ctx.fillStyle = '#333';
    ctx.textAlign = 'left';
    ctx.font = '14px "Segoe UI", Arial';
    ctx.fillText(`Houses lit: ${litCount} / ${state.bulbs.length}`, 12, 48);

    // sound icon
    drawSoundIcon();

    ctx.restore();
  }

  // Utility: rounded rectangle
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Check if point inside battery card bounds
  function pointInBattery(x, y, bat) {
    const bx = bat.drawX || bat.x;
    const by = bat.drawY || bat.y;
    return x >= bx - 36 && x <= bx + 36 && y >= by - 28 && y <= by + 28;
  }

  // Check if point near bulb center (for dropping)
  function pointInBulb(x, y, bulb) {
    const dx = x - bulb.x;
    const dy = y - (bulb.y - 10);
    return Math.sqrt(dx * dx + dy * dy) <= 52;
  }

  // Place battery on bulb (or remove)
  function placeBatteryOn(batteryId, bulbIndex) {
    const bat = state.batteries.find(b => b.id === batteryId);
    if (!bat) return;
    // If placing on same bulb, remove it (toggle)
    if (bulbIndex === null) {
      if (bat.placedOn !== null) {
        // remove from previous bulb
        const prevBulb = state.bulbs[bat.placedOn];
        prevBulb.connectedBatteries = prevBulb.connectedBatteries.filter(id => id !== bat.id);
      }
      bat.placedOn = null;
      return;
    }
    const bulb = state.bulbs[bulbIndex];
    if (!bulb) return;
    // remove from previous bulb first
    if (bat.placedOn !== null) {
      const prev = state.bulbs[bat.placedOn];
      if (prev) prev.connectedBatteries = prev.connectedBatteries.filter(id => id !== bat.id);
    }
    // attach
    bat.placedOn = bulbIndex;
    bulb.connectedBatteries.push(bat.id);
    // Immediately play spark sound
    if (state.soundOn) {
      playSpark();
    }
    // Check bulb sum
    checkBulb(bulbIndex);
  }

  // Check if bulb's connected battery sum matches target
  function checkBulb(idx) {
    const bulb = state.bulbs[idx];
    const sum = bulb.connectedBatteries.reduce((s, bid) => {
      const b = state.batteries.find(bb => bb.id === bid);
      return s + (b ? b.value : 0);
    }, 0);
    if (sum === bulb.target) {
      if (!bulb.lit) {
        bulb.lit = true;
        playChime();
        state.score += 10;
        announce(`Great! You lit a house!`);
        // visual sparkle: increase glow
        bulb.glow = 1;
      }
    } else {
      // if not equal and previously lit, turn off
      if (bulb.lit) {
        bulb.lit = false;
      }
      // wrong partial sums: small buzz if sum exceeds target
      if (sum > bulb.target) {
        if (state.soundOn) playBuzz();
        // minor penalty
        state.score = Math.max(0, state.score - 2);
      }
    }
    // check if all lit -> next level
    if (state.bulbs.every(b => b.lit)) {
      state.roundActive = false;
      announce('All houses glowing! Next round starting...');
      setTimeout(() => {
        initLevel(state.level + 1);
      }, 1800);
    }
  }

  // Remove battery if placed on bulb and user picks it up
  function pickUpBattery(batteryId) {
    const bat = state.batteries.find(b => b.id === batteryId);
    if (!bat) return;
    if (bat.placedOn !== null) {
      const bulb = state.bulbs[bat.placedOn];
      if (bulb) {
        bulb.connectedBatteries = bulb.connectedBatteries.filter(id => id !== batteryId);
        // if bulb was lit, re-evaluate
        checkBulb(bat.placedOn);
      }
      bat.placedOn = null;
    }
    state.holdingBattery = batteryId;
    // offset so cursor isn't at center
    bat.pickedOffset.x = bat.x - state.mouse.x;
    bat.pickedOffset.y = bat.y - state.mouse.y;
    if (state.soundOn) playBeep(1000, 0.06, 'sine');
  }

  // Drop currently held battery, determining target bulb if any
  function dropHeldBattery() {
    if (!state.holdingBattery) return;
    const bat = state.batteries.find(b => b.id === state.holdingBattery);
    if (!bat) {
      state.holdingBattery = null;
      return;
    }
    // find bulb under cursor
    let targetIndex = null;
    for (let i = 0; i < state.bulbs.length; i++) {
      if (pointInBulb(state.mouse.x, state.mouse.y, state.bulbs[i])) {
        targetIndex = i;
        break;
      }
    }
    if (targetIndex !== null) {
      placeBatteryOn(bat.id, targetIndex);
      // animate battery position to anchored spot near bulb for clarity
      const bulb = state.bulbs[targetIndex];
      const assignmentCount = bulb.connectedBatteries.length - 1;
      const angle = -Math.PI / 2 + (assignmentCount - ((bulb.connectedBatteries.length - 1) / 2)) * 0.5;
      const rx = bulb.x + Math.cos(angle) * 70;
      const ry = bulb.y + Math.sin(angle) * 70;
      bat.x = rx; bat.y = ry;
    } else {
      // return to original spot
      bat.x = bat.baseX;
      bat.y = bat.baseY;
      if (state.soundOn) playBeep(380, 0.08, 'square');
    }
    state.holdingBattery = null;
    if (state.soundOn) playBeep(600, 0.05, 'sine');
  }

  // Input handling
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    state.mouse.x = e.clientX - rect.left;
    state.mouse.y = e.clientY - rect.top;
    state.mouse.down = true;
    // resume audio if required
    resumeAudioOnInteraction();

    // Check for clicking on sound icon
    if (distance(state.mouse.x, state.mouse.y, WIDTH - 36, 20) <= 18) {
      toggleSound();
      return;
    }

    // pick a battery if clicked
    for (let i = 0; i < state.batteries.length; i++) {
      const b = state.batteries[i];
      if (pointInBattery(state.mouse.x, state.mouse.y, b)) {
        pickUpBattery(b.id);
        state.draggingBatteryId = b.id;
        state.selectedBatteryIndex = i;
        return;
      }
    }
    // If clicked on placed battery icons near bulbs, pick up that battery
    for (let i = 0; i < state.bulbs.length; i++) {
      const bulb = state.bulbs[i];
      for (let j = 0; j < bulb.connectedBatteries.length; j++) {
        const bid = bulb.connectedBatteries[j];
        const b = state.batteries.find(bb => bb.id === bid);
        if (!b) continue;
        const angle = -Math.PI / 2 + (j - (bulb.connectedBatteries.length - 1) / 2) * 0.5;
        const rx = bulb.x + Math.cos(angle) * 70;
        const ry = bulb.y + Math.sin(angle) * 70;
        if (distance(state.mouse.x, state.mouse.y, rx, ry) <= 20) {
          pickUpBattery(b.id);
          state.draggingBatteryId = b.id;
          return;
        }
      }
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    state.mouse.x = e.clientX - rect.left;
    state.mouse.y = e.clientY - rect.top;
    if (state.holdingBattery) {
      // update location of held battery visually
      const bat = state.batteries.find(b => b.id === state.holdingBattery);
      if (bat) {
        bat.drawX = state.mouse.x + bat.pickedOffset.x;
        bat.drawY = state.mouse.y + bat.pickedOffset.y;
      }
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    state.mouse.down = false;
    if (state.draggingBatteryId) {
      dropHeldBattery();
      state.draggingBatteryId = null;
    }
  });

  canvas.addEventListener('mouseleave', (e) => {
    state.mouse.down = false;
    // if dragging outside, drop to base
    if (state.holdingBattery) dropHeldBattery();
  });

  // Keyboard handling for accessibility
  canvas.addEventListener('keydown', (e) => {
    // resume audio on keyboard interaction
    resumeAudioOnInteraction();

    if (e.code === 'Space') {
      e.preventDefault();
      toggleSound();
      return;
    }
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      state.selectedBatteryIndex = Math.min(state.batteries.length - 1, state.selectedBatteryIndex + 1);
      return;
    }
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      state.selectedBatteryIndex = Math.max(0, state.selectedBatteryIndex - 1);
      return;
    }
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      state.selectedBatteryIndex = Math.max(0, state.selectedBatteryIndex - 1);
      return;
    }
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      state.selectedBatteryIndex = Math.min(state.batteries.length - 1, state.selectedBatteryIndex + 1);
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      // pick or place battery
      const selected = state.batteries[state.selectedBatteryIndex];
      if (!selected) return;
      if (!state.holdingBattery) {
        // pick up
        pickUpBattery(selected.id);
      } else {
        // find if focused bulb exists under keyboard selection maybe cycle bulbs
        // simple: drop onto nearest bulb by distance
        let nearest = null;
        let dist = Infinity;
        for (let i = 0; i < state.bulbs.length; i++) {
          const b = state.bulbs[i];
          const d = distance(selected.x, selected.y, b.x, b.y - 10);
          if (d < dist) {
            dist = d; nearest = i;
          }
        }
        if (nearest !== null) {
          placeBatteryOn(state.holdingBattery, nearest);
          // move battery to anchored spot
          const bulb = state.bulbs[nearest];
          const assignmentCount = bulb.connectedBatteries.length - 1;
          const angle = -Math.PI / 2 + (assignmentCount - ((bulb.connectedBatteries.length - 1) / 2)) * 0.5;
          const rx = bulb.x + Math.cos(angle) * 70;
          const ry = bulb.y + Math.sin(angle) * 70;
          const bat = state.batteries.find(bb => bb.id === state.holdingBattery);
          if (bat) { bat.x = rx; bat.y = ry; }
          state.holdingBattery = null;
        } else {
          // place back
          const bat = state.batteries.find(b => b.id === state.holdingBattery);
          if (bat) { bat.x = bat.baseX; bat.y = bat.baseY; }
          state.holdingBattery = null;
        }
      }
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      // cancel holding
      if (state.holdingBattery) {
        const bat = state.batteries.find(b => b.id === state.holdingBattery);
        if (bat) { bat.x = bat.baseX; bat.y = bat.baseY; }
        state.holdingBattery = null;
      }
      return;
    }
  });

  // Toggle sound
  function toggleSound() {
    state.soundOn = !state.soundOn;
    if (state.soundOn) {
      if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {
        resumeAudioOnInteraction();
      }
      announce('Sound on');
    } else {
      announce('Sound off');
    }
  }

  // Resume audio context on user gesture if needed
  function resumeAudioOnInteraction() {
    if (!audioEnabled || !audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        startBackgroundHum();
        announce('Audio ready');
      }).catch(e => {
        console.warn('Audio resume failed:', e);
      });
    } else {
      startBackgroundHum();
    }
  }

  // Distance helper
  function distance(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Animation loop
  let frame = 0;
  function tick() {
    frame++;
    // gentle background movement of batteries
    for (let b of state.batteries) {
      b.wobble += 0.02;
      if (!state.holdingBattery || state.holdingBattery !== b.id) {
        // small breathing motion
        b.x = b.baseX + Math.sin(b.wobble) * 2;
        b.y = b.baseY + Math.cos(b.wobble * 0.9) * 1.5;
      }
    }

    // reduce message timer
    if (state.messageTimer > 0) state.messageTimer--;

    // draw everything
    clearScreen();
    drawHeader();
    drawBatteries();
    drawConnectors();
    drawBulbs();
    drawCharacters(frame);
    drawUI();

    // draw helpful hint overlay if needed
    if (state.hintVisible) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      roundRect(ctx, 60, HEIGHT - 64, 600, 46, 10, true, true);
      ctx.fillStyle = '#333';
      ctx.font = '14px "Segoe UI", Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Tip: Try combining two or three batteries if the number is bigger! Click Space to toggle sound.', WIDTH / 2, HEIGHT - 36);
      ctx.restore();
    }

    requestAnimationFrame(tick);
  }

  // Start the game
  initLevel(1);
  tick();

  // If audio is enabled, wait for user gesture to start background hum
  // Also provide a small friendly hint drawn when audio unavailable
  if (audioEnabled) {
    // Show an overlay indicating user should tap/click to enable sound if suspended
    function showAudioHintOnce() {
      if (audioCtx && audioCtx.state === 'suspended') {
        // Drawn in canvas already through message; set message
        announce('Tap the game or press any key to enable sound and start the lab!');
      }
      // Remove this event listener after one use
      window.removeEventListener('pointerdown', showAudioHintOnce);
      window.removeEventListener('keydown', showAudioHintOnce);
    }
    window.addEventListener('pointerdown', showAudioHintOnce);
    window.addEventListener('keydown', showAudioHintOnce);
  } else {
    announce('Audio not available on this device. Visual cues will guide you instead.');
  }

  // Safety: if audio operations throw errors elsewhere, catch them globally on this context
  window.addEventListener('unhandledrejection', (e) => {
    console.warn('Unhandled promise rejection in game:', e.reason);
  });

  // Expose a small control function for debugging (optional)
  try {
    Object.defineProperty(window, '__electricGameDebug', {
      value: {
        restart: () => initLevel(1),
        currentState: () => JSON.parse(JSON.stringify(state))
      },
      writable: false
    });
  } catch (e) {
    // ignore if we can't define global
  }

})();
---

