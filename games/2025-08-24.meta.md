# Game of the Day - 2025-08-24

## Metadata
- **Generated Date:** 2025-08-24
- **Generated Time:** 2025-08-24T00:24:04.627379
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-24.js
- **File Size:** 31184 bytes
- **Tokens Used:** 10248

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-24.js` - The playable game
- `2025-08-24.meta.json` - Machine-readable metadata
- `2025-08-24.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20445

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21785

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Educational Math Game: "Sparky's Power-Up"
  // Ages 7-9. Theme: Electricity. Math focus: addition (combine sparks to match bulb targets).
  // Renders entirely inside element with ID "game-of-the-day-stage".
  // All visuals drawn on a 720x480 canvas, all sounds generated with Web Audio API.
  // Accessible via keyboard, includes aria-live status updates, and error handling.

  // Constants
  const WIDTH = 720;
  const HEIGHT = 480;
  const BG_COLOR = '#e8f6ff';
  const SPARK_COLORS = ['#ffdd57', '#ffd1a9', '#ff9aa2', '#c6f6d5', '#d0f0ff'];
  const BULB_COLOR = '#fff7c0';
  const MAX_SPARKS = 6;
  const LEVELS = [
    { bulbs: [5, 7, 6] },
    { bulbs: [8, 9, 5] },
    { bulbs: [10, 7, 8] }
  ];

  // Game references
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container
  container.innerHTML = '';
  container.style.width = WIDTH + 'px';
  container.style.height = HEIGHT + 'px';
  container.style.position = 'relative';
  container.style.outline = 'none';
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Sparky power-up math game. Use mouse or keyboard to play.');
  container.tabIndex = 0;

  // Create hidden accessible instructions (screen-reader-friendly)
  const srInstructions = document.createElement('div');
  srInstructions.style.position = 'absolute';
  srInstructions.style.left = '-9999px';
  srInstructions.style.width = '1px';
  srInstructions.style.height = '1px';
  srInstructions.style.overflow = 'hidden';
  srInstructions.setAttribute('aria-live', 'polite');
  srInstructions.id = 'sparky-aria';
  srInstructions.textContent =
    'Welcome to Sparky\'s Power-Up! Combine numbered sparks to match bulb energy. ' +
    'Use mouse or touch to drag sparks into bulbs. Keyboard: Tab to focus, arrow keys to move, space to pick up/drop, Q/E to cycle sparks.';
  container.appendChild(srInstructions);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = 'block';
  canvas.style.background = BG_COLOR;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Interactive game area. Visuals are decorative; use the game controls described in the instructions.');
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Setup audio context with error handling
  let audioCtx = null;
  let audioEnabled = false;
  function tryCreateAudioContext() {
    if (audioCtx) return audioCtx;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
      return audioCtx;
    } catch (e) {
      audioCtx = null;
      console.warn('Web Audio API not supported or blocked:', e);
      return null;
    }
  }

  // Sound utilities
  function playTone({ freq = 440, duration = 0.25, type = 'sine', volume = 0.12, onended = null }) {
    const ctx = tryCreateAudioContext();
    if (!ctx) return;
    try {
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(ctx.destination);
      const now = ctx.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(volume, now + 0.02);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.stop(now + duration + 0.05);
      o.onended = onended;
    } catch (e) {
      console.warn('Audio play error:', e);
    }
  }

  function playChord(success = true) {
    if (!audioEnabled) return;
    const ctx = tryCreateAudioContext();
    if (!ctx) return;
    try {
      const now = ctx.currentTime;
      const osc1 = ctx.createOscillator();
      const osc2 = ctx.createOscillator();
      const g = ctx.createGain();
      osc1.type = 'sine';
      osc2.type = 'triangle';
      const base = success ? 660 : 220;
      osc1.frequency.value = base;
      osc2.frequency.value = base * (success ? 1.5 : 0.5);
      g.gain.value = 0.0001;
      osc1.connect(g);
      osc2.connect(g);
      g.connect(ctx.destination);
      g.gain.exponentialRampToValueAtTime(success ? 0.14 : 0.08, now + 0.01);
      osc1.start(now);
      osc2.start(now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + (success ? 0.5 : 0.25));
      osc1.stop(now + (success ? 0.6 : 0.35));
      osc2.stop(now + (success ? 0.6 : 0.35));
    } catch (e) {
      console.warn('Chord error:', e);
    }
  }

  // Gentle background hum (looping subtle noise)
  let humOsc = null;
  function startBackgroundHum() {
    if (!audioEnabled) return;
    const ctx = tryCreateAudioContext();
    if (!ctx || humOsc) return;
    try {
      humOsc = ctx.createOscillator();
      const gain = ctx.createGain();
      humOsc.type = 'sine';
      humOsc.frequency.value = 80;
      gain.gain.value = 0.02;
      humOsc.connect(gain);
      gain.connect(ctx.destination);
      humOsc.start();
    } catch (e) {
      console.warn('Background hum error:', e);
    }
  }
  function stopBackgroundHum() {
    if (humOsc) {
      try {
        humOsc.stop();
        humOsc.disconnect();
      } catch (e) {
        // ignore
      }
      humOsc = null;
    }
  }

  // Game classes
  class Spark {
    constructor(id, x, y, value, color) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.vx = (Math.random() - 0.5) * 0.6;
      this.vy = (Math.random() - 0.5) * 0.6;
      this.radius = 24;
      this.value = value;
      this.color = color;
      this.dragging = false;
      this.picked = false; // picked by player
      this.visible = true;
      this.bounce = Math.random() * Math.PI * 2;
    }

    draw(ctx) {
      if (!this.visible) return;
      // Glow halo
      ctx.save();
      ctx.beginPath();
      const gradient = ctx.createRadialGradient(this.x, this.y, this.radius * 0.2, this.x, this.y, this.radius * 2);
      gradient.addColorStop(0, this.color);
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gradient;
      ctx.globalAlpha = 0.35;
      ctx.fillRect(this.x - this.radius * 2, this.y - this.radius * 2, this.radius * 4, this.radius * 4);
      ctx.globalAlpha = 1.0;
      ctx.restore();

      // Spark shape (lightning bolt)
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(Math.sin(this.bounce) * 0.08);
      ctx.beginPath();
      ctx.moveTo(-8, -16);
      ctx.lineTo(4, -4);
      ctx.lineTo(-2, -4);
      ctx.lineTo10 = ctx.lineTo; // prevent minifiers, harmless
      ctx.lineTo(8, 16);
      ctx.lineTo(-4, 4);
      ctx.lineTo(2, 4);
      ctx.closePath();
      ctx.fillStyle = this.color;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.fill();
      ctx.stroke();

      // Number label
      ctx.fillStyle = '#222';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(this.value.toString(), 0, 0);
      if (this.picked) {
        // outline to indicate selection
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 6, 0, Math.PI * 2);
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      ctx.restore();
    }

    update(dt) {
      if (!this.visible || this.dragging || this.picked) {
        // small bobbing even when idle
        this.bounce += dt * 0.006;
        this.bounce %= Math.PI * 2;
        return;
      }
      this.x += this.vx * dt * 0.06;
      this.y += this.vy * dt * 0.06;
      // boundaries
      if (this.x < this.radius) { this.x = this.radius; this.vx *= -0.8; }
      if (this.x > WIDTH - this.radius) { this.x = WIDTH - this.radius; this.vx *= -0.8; }
      if (this.y < this.radius + 80) { this.y = this.radius + 80; this.vy *= -0.8; }
      if (this.y > HEIGHT - this.radius) { this.y = HEIGHT - this.radius; this.vy *= -0.8; }
      // slow down
      this.vx *= 0.995;
      this.vy *= 0.995;
      this.bounce += 0.01;
    }

    containsPoint(px, py) {
      const dx = px - this.x;
      const dy = py - this.y;
      return dx * dx + dy * dy <= (this.radius * this.radius) * 1.1;
    }
  }

  class Bulb {
    constructor(id, x, y, target) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.radius = 48;
      this.target = target;
      this.current = 0;
      this.lit = false;
      this.pulse = 0;
    }

    draw(ctx) {
      // base bulb
      ctx.save();
      ctx.translate(this.x, this.y);
      // bulb glow if lit
      if (this.lit) {
        const glow = ctx.createRadialGradient(0, -8, 10, 0, -8, 120);
        glow.addColorStop(0, 'rgba(255, 246, 200, 0.9)');
        glow.addColorStop(1, 'rgba(255, 246, 200, 0.0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, 90 + Math.sin(this.pulse) * 6, 0, Math.PI * 2);
        ctx.fill();
      }

      // bulb body
      ctx.beginPath();
      ctx.ellipse(0, -6, this.radius * 0.9, this.radius * 1.1, 0, 0, Math.PI * 2);
      ctx.fillStyle = BULB_COLOR;
      ctx.fill();
      ctx.strokeStyle = '#caa84f';
      ctx.lineWidth = 3;
      ctx.stroke();

      // screw base
      ctx.fillStyle = '#b0b0b0';
      ctx.fillRect(-18, 28, 36, 18);
      ctx.strokeRect(-18, 28, 36, 18);

      // face
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(-12, -6, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(8, -6, 4, 0, Math.PI * 2);
      ctx.fill();
      if (this.lit) {
        ctx.beginPath();
        ctx.arc(-6, 6, 6, 0, Math.PI);
        ctx.fillStyle = '#222';
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.moveTo(-6, 6);
        ctx.lineTo(6, 6);
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // numbers and progress
      ctx.fillStyle = '#333';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`${this.current} / ${this.target}`, 0, 54);

      // target hint when not met
      if (!this.lit) {
        ctx.fillStyle = '#666';
        ctx.font = '12px sans-serif';
        ctx.fillText('Need exact match!', 0, 70);
      } else {
        ctx.fillStyle = '#2b8a3e';
        ctx.font = '12px sans-serif';
        ctx.fillText('Powered!', 0, 70);
      }

      ctx.restore();
    }

    containsPoint(px, py) {
      const dx = px - this.x;
      const dy = py - this.y;
      // elliptical hit region
      return (dx * dx) / ((this.radius * 0.9) ** 2) + (dy * dy) / ((this.radius * 1.1) ** 2) <= 1;
    }

    addSparkValue(val) {
      if (this.lit) return { success: false, reason: 'already lit' };
      this.current += val;
      if (this.current === this.target) {
        this.lit = true;
        this.pulse = 0;
        return { success: true, exact: true };
      } else if (this.current > this.target) {
        return { success: false, reason: 'too much' };
      } else {
        return { success: true, exact: false };
      }
    }

    update(dt) {
      if (this.lit) {
        this.pulse += dt * 0.01;
      }
    }
  }

  // Game state
  let sparks = [];
  let bulbs = [];
  let selectedIndex = 0;
  let heldSpark = null;
  let levelIndex = 0;
  let score = 0;
  let lastTime = performance.now();
  let mouseDown = false;
  let hoverSpark = null;
  let tooltip = '';
  let showStartOverlay = true;
  let particles = [];

  // Initialize level
  function initLevel(index) {
    sparks = [];
    bulbs = [];
    selectedIndex = 0;
    heldSpark = null;
    tooltip = '';
    const level = LEVELS[index % LEVELS.length];
    // place bulbs evenly
    const bulbPositions = [
      { x: 140, y: 170 },
      { x: 360, y: 170 },
      { x: 580, y: 170 }
    ];
    for (let i = 0; i < level.bulbs.length; i++) {
      const b = new Bulb(i, bulbPositions[i].x, bulbPositions[i].y, level.bulbs[i]);
      bulbs.push(b);
    }
    // create sparks with random values that can solve bulbs (ensure solvable)
    // Strategy: generate some sparks that sum to each bulb target, plus extras.
    let created = 0;
    for (let i = 0; i < bulbs.length; i++) {
      const t = bulbs[i].target;
      // split into 2 values for complexity
      const a = Math.max(1, Math.floor((Math.random() * (t - 1)) + 1));
      const b = t - a;
      sparks.push(new Spark(created++, 140 + i * 160, 320 + Math.random() * 80, a, SPARK_COLORS[created % SPARK_COLORS.length]));
      sparks.push(new Spark(created++, 140 + i * 160 + 30, 320 + Math.random() * 80, b, SPARK_COLORS[created % SPARK_COLORS.length]));
    }
    // add some random filler sparks
    while (created < MAX_SPARKS) {
      const val = 1 + Math.floor(Math.random() * 9);
      sparks.push(new Spark(created++, 120 + Math.random() * 480, 320 + Math.random() * 120, val, SPARK_COLORS[created % SPARK_COLORS.length]));
    }
    // ensure indices safe
    selectedIndex = 0;
    score = 0;
    particles = createParticles();
    updateAria('New level loaded. Combine sparks to match bulb energy numbers.');
  }

  // Particles for wacky background
  function createParticles() {
    const arr = [];
    for (let i = 0; i < 20; i++) {
      arr.push({
        x: Math.random() * WIDTH,
        y: Math.random() * HEIGHT,
        r: 6 + Math.random() * 18,
        vx: (Math.random() - 0.5) * 0.1,
        vy: (Math.random() - 0.5) * 0.1,
        hue: 180 + Math.random() * 80
      });
    }
    return arr;
  }

  // Drawing functions
  function drawBackground(ctx) {
    // soft gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#f6fbff');
    g.addColorStop(1, '#e8f6ff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // wavy wires and coils
    ctx.save();
    try {
      for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        const y = 100 + i * 60;
        ctx.moveTo(0, y);
        for (let x = 0; x <= WIDTH; x += 20) {
          ctx.lineTo(x, y + Math.sin((x * 0.02) + i * 0.8 + performance.now() * 0.001) * 12);
        }
        ctx.strokeStyle = `hsla(${200 + i * 10},60%,60%,0.08)`;
        ctx.lineWidth = 14 - i * 1.6;
        ctx.stroke();
      }
    } catch (e) {
      console.warn('Background draw error:', e);
    }
    ctx.restore();

    // floating particles
    ctx.save();
    for (const p of particles) {
      p.x += p.vx;
      p.y += p.vy;
      if (p.x < -50) p.x = WIDTH + 50;
      if (p.x > WIDTH + 50) p.x = -50;
      if (p.y < -50) p.y = HEIGHT + 50;
      if (p.y > HEIGHT + 50) p.y = -50;
      ctx.beginPath();
      ctx.fillStyle = `hsla(${p.hue},70%,60%,0.06)`;
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawTopBar(ctx) {
    ctx.save();
    ctx.fillStyle = '#ffffffaa';
    ctx.fillRect(0, 0, WIDTH, 64);
    ctx.strokeStyle = '#cde6ff';
    ctx.strokeRect(0, 0, WIDTH, 64);

    // Title and characters
    ctx.fillStyle = '#0b2447';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Sparky\'s Power-Up: Addition Adventure', 16, 28);

    // Dr. Current micro-portrait (guide)
    const gx = WIDTH - 160;
    ctx.save();
    ctx.translate(gx, 8);
    // plaque
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 4, 150, 52);
    ctx.strokeStyle = '#c6e6ff';
    ctx.strokeRect(0, 4, 150, 52);
    // face
    ctx.beginPath();
    ctx.arc(26, 30, 16, 0, Math.PI * 2);
    ctx.fillStyle = '#ffdca8';
    ctx.fill();
    ctx.strokeStyle = '#d6b08a';
    ctx.stroke();
    // glasses
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(18, 30, 6, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(34, 30, 6, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(24, 30);
    ctx.lineTo(28, 30);
    ctx.stroke();
    // name
    ctx.fillStyle = '#333';
    ctx.font = '12px sans-serif';
    ctx.fillText('Dr. Current', 54, 26);
    ctx.fillStyle = '#666';
    ctx.font = '11px sans-serif';
    ctx.fillText('Guide & Spark Expert', 54, 42);
    ctx.restore();

    // sound indicator (visual cue)
    ctx.fillStyle = audioEnabled ? '#2b8a3e' : '#b23a3a';
    ctx.beginPath();
    ctx.moveTo(WIDTH - 32, 22);
    ctx.lineTo(WIDTH - 22, 16);
    ctx.lineTo(WIDTH - 22, 28);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(audioEnabled ? 'Sound On' : 'Sound Off', WIDTH - 80, 22);

    ctx.restore();
  }

  function drawInstructions(ctx) {
    ctx.save();
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#234';
    ctx.textAlign = 'left';
    ctx.fillText('Drag numbered sparks into bulbs so the sum equals the bulb\'s number.', 16, 46);
    ctx.fillText('Keyboard: Tab focus -> Arrow keys move, Space pick up/drop, Q/E cycle, Enter drop into bulb.', 16, 60);
    ctx.restore();
  }

  // Render loop
  function render(now) {
    const dt = now - lastTime;
    lastTime = now;
    // update
    for (const s of sparks) s.update(dt);
    for (const b of bulbs) b.update(dt);
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground(ctx);
    drawTopBar(ctx);
    drawInstructions(ctx);

    // draw bulbs
    for (const b of bulbs) b.draw(ctx);

    // wires from bulbs to bottom area (for charm)
    ctx.save();
    ctx.strokeStyle = '#b8d6ff';
    ctx.lineWidth = 4;
    for (const b of bulbs) {
      ctx.beginPath();
      ctx.moveTo(b.x - 12, b.y + 34);
      ctx.bezierCurveTo(b.x - 30, b.y + 90, b.x - 200, HEIGHT - 40, 40, HEIGHT - 20);
      ctx.stroke();
    }
    ctx.restore();

    // draw sparks (z-order: sparks over wires)
    for (let i = 0; i < sparks.length; i++) {
      sparks[i].draw(ctx);
    }

    // HUD - selected spark info
    ctx.save();
    ctx.fillStyle = '#0b2447';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    const sel = sparks[selectedIndex];
    if (sel && sel.visible) {
      ctx.fillText(`Selected spark: ${sel.value} (use Q/E to cycle)`, 16, HEIGHT - 52);
    } else {
      ctx.fillText('No spark selected', 16, HEIGHT - 52);
    }
    ctx.fillText(`Score: ${score}`, WIDTH - 120, HEIGHT - 52);
    ctx.restore();

    // overlay start
    if (showStartOverlay) {
      ctx.save();
      ctx.fillStyle = 'rgba(6,30,55,0.85)';
      ctx.fillRect(60, 100, WIDTH - 120, HEIGHT - 200);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = 'bold 28px sans-serif';
      ctx.fillText('Sparky\'s Power-Up!', WIDTH / 2, 160);
      ctx.font = '16px sans-serif';
      ctx.fillText('Combine sparks to match bulb energy numbers.', WIDTH / 2, 200);
      ctx.fillText('Click here or press Enter to begin and enable sound (optional).', WIDTH / 2, 240);
      ctx.font = '12px sans-serif';
      ctx.fillText('Mouse/touch: drag and drop. Keyboard: Tab -> arrow keys, space, Q/E, Enter', WIDTH / 2, 270);
      ctx.restore();
    }

    // tooltip
    if (tooltip) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.strokeStyle = '#9cc7ff';
      ctx.fillRect(16, HEIGHT - 110, 220, 36);
      ctx.strokeRect(16, HEIGHT - 110, 220, 36);
      ctx.fillStyle = '#022';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(tooltip, 26, HEIGHT - 86);
      ctx.restore();
    }

    requestAnimationFrame(render);
  }

  // Start the render loop
  requestAnimationFrame(render);

  // Interaction handling
  function screenToCanvas(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX !== undefined ? evt.clientX : evt.touches[0].clientX) - rect.left;
    const y = (evt.clientY !== undefined ? evt.clientY : evt.touches[0].clientY) - rect.top;
    return { x, y };
  }

  canvas.addEventListener('mousedown', (evt) => {
    container.focus();
    mouseDown = true;
    const p = screenToCanvas(evt);
    // start audio context on first user gesture if possible
    if (!audioCtx) {
      tryCreateAudioContext();
    }
    // If start overlay visible, clicking starts the game
    if (showStartOverlay) {
      showStartOverlay = false;
      audioEnabled = true;
      // resume context if needed
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
          startBackgroundHum();
        }).catch(() => {});
      } else {
        startBackgroundHum();
      }
      updateAria('Game started. Use mouse or keyboard to play.');
      initLevel(levelIndex);
      return;
    }
    // hit test sparks (topmost first)
    for (let i = sparks.length - 1; i >= 0; i--) {
      if (sparks[i].visible && sparks[i].containsPoint(p.x, p.y)) {
        heldSpark = sparks[i];
        heldSpark.dragging = true;
        heldSpark.picked = true;
        tooltip = 'Drag to a bulb to add energy. Release to drop.';
        updateAria(`Picked spark ${heldSpark.value}. Drag it into a bulb.`);
        break;
      }
    }
  });

  canvas.addEventListener('mousemove', (evt) => {
    const p = screenToCanvas(evt);
    hoverSpark = null;
    for (let i = sparks.length - 1; i >= 0; i--) {
      if (sparks[i].visible && sparks[i].containsPoint(p.x, p.y)) {
        hoverSpark = sparks[i];
        break;
      }
    }
    if (heldSpark && heldSpark.dragging) {
      heldSpark.x = p.x;
      heldSpark.y = p.y;
    }
  });

  canvas.addEventListener('mouseup', (evt) => {
    mouseDown = false;
    if (heldSpark) {
      heldSpark.dragging = false;
      // check if over a bulb
      const p = screenToCanvas(evt);
      let droppedOnBulb = null;
      for (const b of bulbs) {
        if (b.containsPoint(p.x, p.y)) {
          droppedOnBulb = b;
          break;
        }
      }
      if (droppedOnBulb) {
        const result = droppedOnBulb.addSparkValue(heldSpark.value);
        if (result.success && result.exact) {
          // success: remove spark, light bulb, play sound
          heldSpark.visible = false;
          score += 10;
          playChord(true);
          updateAria(`Great! Bulb ${droppedOnBulb.id + 1} is powered. Score ${score}.`);
          checkLevelComplete();
        } else if (result.success && !result.exact) {
          // partial add: hide spark, keep bulb unlit
          heldSpark.visible = false;
          score += 2;
          playTone({ freq: 560, duration: 0.14, type: 'sine', volume: 0.09 });
          updateAria(`Added ${heldSpark.value} to bulb ${droppedOnBulb.id + 1}. Current ${droppedOnBulb.current} of ${droppedOnBulb.target}.`);
        } else {
          // wrong (over)
          // revert spark to visible position, flash bulb
          playChord(false);
          // subtract value (revert) to keep game fair
          droppedOnBulb.current -= heldSpark.value;
          if (droppedOnBulb.current < 0) droppedOnBulb.current = 0;
          updateAria('Oops! Too much energy. Try a smaller spark.');
          // small visual shake
          // push spark away
          heldSpark.x = 360;
          heldSpark.y = 360;
        }
      } else {
        // dropped on ground - reposition slightly
        heldSpark.x += Math.random() * 20 - 10;
        heldSpark.y += Math.random() * 20 - 10;
        updateAria('Spark dropped. Try again.');
      }
      // unpick
      heldSpark.picked = false;
      heldSpark = null;
      tooltip = '';
    } else {
      // if click empty space and overlay hidden, maybe pick a nearest spark
      if (!showStartOverlay) {
        const p = screenToCanvas(evt);
        for (let i = 0; i < sparks.length; i++) {
          if (sparks[i].visible && sparks[i].containsPoint(p.x, p.y)) {
            selectedIndex = i;
            updateAria(`Selected spark ${sparks[selectedIndex].value}.`);
            break;
          }
        }
      }
    }
  });

  // Touch events for mobile
  canvas.addEventListener('touchstart', (evt) => {
    evt.preventDefault();
    const touch = evt.touches[0];
    const fakeEvt = { clientX: touch.clientX, clientY: touch.clientY };
    canvas.dispatchEvent(new MouseEvent('mousedown', fakeEvt));
  }, { passive: false });

  canvas.addEventListener('touchmove', (evt) => {
    evt.preventDefault();
    const touch = evt.touches[0];
    const fakeEvt = { clientX: touch.clientX, clientY: touch.clientY };
    canvas.dispatchEvent(new MouseEvent('mousemove', fakeEvt));
  }, { passive: false });

  canvas.addEventListener('touchend', (evt) => {
    evt.preventDefault();
    canvas.dispatchEvent(new MouseEvent('mouseup', {}));
  }, { passive: false });

  // Keyboard controls
  container.addEventListener('keydown', (evt) => {
    if (showStartOverlay && (evt.key === 'Enter' || evt.key === ' ')) {
      showStartOverlay = false;
      audioEnabled = true;
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => startBackgroundHum()).catch(() => {});
      }
      initLevel(levelIndex);
      return;
    }
    if (showStartOverlay) return;
    const key = evt.key.toLowerCase();
    const sel = sparks[selectedIndex];
    if (key === 'q') {
      // cycle left
      for (let i = 1; i <= sparks.length; i++) {
        const idx = (selectedIndex - i + sparks.length) % sparks.length;
        if (sparks[idx].visible) { selectedIndex = idx; break; }
      }
      updateAria(`Selected spark ${sparks[selectedIndex].value}.`);
      evt.preventDefault();
    } else if (key === 'e') {
      // cycle right
      for (let i = 1; i <= sparks.length; i++) {
        const idx = (selectedIndex + i) % sparks.length;
        if (sparks[idx].visible) { selectedIndex = idx; break; }
      }
      updateAria(`Selected spark ${sparks[selectedIndex].value}.`);
      evt.preventDefault();
    } else if (key === ' ' || key === 'enter') {
      // pick up or drop
      if (heldSpark) {
        // drop into nearest bulb if intersects
        let droppedOnBulb = null;
        for (const b of bulbs) {
          if (b.containsPoint(heldSpark.x, heldSpark.y)) {
            droppedOnBulb = b;
            break;
          }
        }
        if (droppedOnBulb) {
          const result = droppedOnBulb.addSparkValue(heldSpark.value);
          if (result.success && result.exact) {
            heldSpark.visible = false;
            score += 10;
            playChord(true);
            updateAria(`Bulb ${droppedOnBulb.id + 1} powered!`);
            checkLevelComplete();
          } else if (result.success && !result.exact) {
            heldSpark.visible = false;
            score += 2;
            playTone({ freq: 560, duration: 0.14, type: 'sine', volume: 0.09 });
            updateAria('Added spark. Keep going.');
          } else {
            droppedOnBulb.current -= heldSpark.value;
            if (droppedOnBulb.current < 0) droppedOnBulb.current = 0;
            playChord(false);
            updateAria('Too much energy! Try a different spark.');
            heldSpark.x = 360;
            heldSpark.y = 360;
          }
        }
        heldSpark.picked = false;
        heldSpark.dragging = false;
        heldSpark = null;
      } else {
        // pick up selected
        if (sel && sel.visible) {
          heldSpark = sel;
          heldSpark.picked = true;
          updateAria(`Picked spark ${heldSpark.value}. Use arrow keys to move.`);
        } else {
          updateAria('No spark to pick. Select another.');
        }
      }
      evt.preventDefault();
      return;
    } else if (['arrowleft', 'a'].includes(evt.key.toLowerCase())) {
      if (heldSpark) { heldSpark.x = Math.max(12, heldSpark.x - 12); }
      else {
        // cycle selection left
        for (let i = 1; i <= sparks.length; i++) {
          const idx = (selectedIndex - i + sparks.length) % sparks.length;
          if (sparks[idx].visible) { selectedIndex = idx; break; }
        }
      }
      evt.preventDefault();
    } else if (['arrowright', 'd'].includes(evt.key.toLowerCase())) {
      if (heldSpark) { heldSpark.x = Math.min(WIDTH - 12, heldSpark.x + 12); }
      else {
        for (let i = 1; i <= sparks.length; i++) {
          const idx = (selectedIndex + i) % sparks.length;
          if (sparks[idx].visible) { selectedIndex = idx; break; }
        }
      }
      evt.preventDefault();
    } else if (['arrowup', 'w'].includes(evt.key.toLowerCase())) {
      if (heldSpark) { heldSpark.y = Math.max(80, heldSpark.y - 12); }
      evt.preventDefault();
    } else if (['arrowdown', 's'].includes(evt.key.toLowerCase())) {
      if (heldSpark) { heldSpark.y = Math.min(HEIGHT - 12, heldSpark.y + 12); }
      evt.preventDefault();
    } else if (key === 'tab') {
      // allow tabbing through for screen readers: cycle selection
      for (let i = 1; i <= sparks.length; i++) {
        const idx = (selectedIndex + i) % sparks.length;
        if (sparks[idx].visible) { selectedIndex = idx; break; }
      }
      updateAria(`Selected spark ${sparks[selectedIndex].value}.`);
      evt.preventDefault();
    }
  });

  // Update aria live region
  function updateAria(text) {
    try {
      srInstructions.textContent = text;
    } catch (e) {
      console.warn('ARIA update failed', e);
    }
  }

  // Check level completion
  function checkLevelComplete() {
    if (bulbs.every(b => b.lit)) {
      playChord(true);
      updateAria('Level complete! Moving to next level.');
      levelIndex++;
      // small celebration: spawn particles
      setTimeout(() => {
        initLevel(levelIndex);
      }, 1200);
    }
  }

  // Start/Stop audio toggle clickable in canvas
  canvas.addEventListener('dblclick', (evt) => {
    // toggle audio
    if (!audioCtx) tryCreateAudioContext();
    audioEnabled = !audioEnabled;
    if (audioEnabled) {
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => startBackgroundHum()).catch(() => {});
      } else {
        startBackgroundHum();
      }
      updateAria('Sound enabled.');
    } else {
      stopBackgroundHum();
      updateAria('Sound disabled.');
    }
  });

  // Initial state: overlay shown, waiting for user
  showStartOverlay = true;
  // Provide initial placeholder level data so UI doesn't break
  initLevel(0);

  // Accessibility: announce focus and basic help when container is focused
  container.addEventListener('focus', () => {
    updateAria('Game focused. Press Enter to start. After starting, drag sparks into bulbs or use keyboard controls.');
  });

  // Error handling: catch global errors in animation and interactions
  window.addEventListener('error', (e) => {
    console.error('Game error caught:', e.message, e.error);
    updateAria('An unexpected error occurred. Please refresh the page.');
  });

  // Expose a minimal debugging API on container for dev (non-intrusive)
  container.gameDebug = {
    toggleSound: () => {
      audioEnabled = !audioEnabled;
      if (audioEnabled) {
        startBackgroundHum();
      } else {
        stopBackgroundHum();
      }
      return audioEnabled;
    },
    getState: () => ({ sparks, bulbs, levelIndex, score })
  };
})();
---

