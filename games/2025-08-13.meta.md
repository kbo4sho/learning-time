# Game of the Day - 2025-08-13

## Metadata
- **Generated Date:** 2025-08-13
- **Generated Time:** 2025-08-13T00:22:34.489774
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-13.js
- **File Size:** 30855 bytes
- **Tokens Used:** 11008

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-13.js` - The playable game
- `2025-08-13.meta.json` - Machine-readable metadata
- `2025-08-13.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22178

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23757

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Electricity-themed Math Game for ages 7-9
// Renders into element with id "game-of-the-day-stage"
// All graphics drawn on a 720x480 canvas; sounds via Web Audio API
(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const CANVAS_ID = 'game-of-the-day-canvas';
  const CONTAINER_ID = 'game-of-the-day-stage';
  const TILE_W = 80;
  const TILE_H = 56;
  const TILE_GAP = 14;

  // Game state
  let canvas, ctx, container;
  let audioCtx = null;
  let audioAllowed = true;
  let audioReady = false;
  let backgroundGain = null;
  let audioError = null;

  let tiles = []; // Array of number tiles
  let bulbs = []; // Bulb targets
  let heldTile = null; // tile id being dragged or keyboard-held
  let pointer = { x: 0, y: 0, isDown: false };
  let focus = { type: 'tile', index: 0 }; // keyboard focus: type 'tile' or 'bulb'
  let confettiParticles = [];
  let allLit = false;
  let showCelebration = 0;

  // Visual theme characters
  const characters = [
    { name: 'Sparky', color: '#ffcc33', mouth: 1 },
    { name: 'Glim', color: '#66ccff', mouth: 0 },
    { name: 'Boltina', color: '#ff99cc', mouth: 2 },
  ];

  // Initialize
  init();

  // -------------------------
  // Initialization functions
  // -------------------------
  function init() {
    try {
      container = document.getElementById(CONTAINER_ID);
    } catch (e) {
      container = null;
    }
    if (!container) {
      console.error(
        `Container element with id "${CONTAINER_ID}" not found. Creating fallback container appended to body.`
      );
      container = document.createElement('div');
      container.id = CONTAINER_ID;
      document.body.appendChild(container);
    }

    // Clear container and create canvas
    container.innerHTML = '';
    canvas = document.createElement('canvas');
    canvas.id = CANVAS_ID;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    // Make canvas focusable for keyboard controls and accessible
    canvas.setAttribute('tabindex', '0');
    canvas.setAttribute(
      'aria-label',
      'Spark Workshop math game. Use mouse or keyboard to drag number tiles to bulbs to match target energy. Press A to toggle audio. Press R to reset.'
    );
    canvas.style.outline = 'none';
    container.appendChild(canvas);

    ctx = canvas.getContext('2d');

    // Event listeners
    canvas.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onTouchDown, { passive: false });
    canvas.addEventListener('touchmove', onTouchMove, { passive: false });
    window.addEventListener('touchend', onTouchUp, { passive: false });
    canvas.addEventListener('keydown', onKeyDown);
    canvas.addEventListener('focus', () => draw()); // redraw focus visuals

    canvas.addEventListener('click', (e) => {
      // If clicking the speaker icon toggle audio
      const rect = canvas.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      if (isPointInSpeaker(cx, cy)) {
        toggleAudio();
      }
    });

    // Initialize audio
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      audioReady = true;
      setupBackgroundHum();
    } catch (err) {
      audioError = err;
      audioReady = false;
      audioAllowed = false;
      console.warn('Audio not available:', err);
    }

    // Start new puzzle
    resetGame();

    // Kick off animation loop
    requestAnimationFrame(loop);
  }

  // -------------------------
  // Game setup and reset
  // -------------------------
  function resetGame() {
    // Prepare three bulbs (left to right)
    bulbs = [];
    const bulbXs = [140, 360, 580];
    for (let i = 0; i < 3; i++) {
      bulbs.push({
        id: i,
        x: bulbXs[i],
        y: 130,
        r: 64,
        target: 0,
        sum: 0,
        lit: false,
        glow: 0,
      });
    }

    // Generate targets and tiles in a solvable way
    // For each bulb, choose a target between 5 and 12
    let requiredTiles = [];
    for (let i = 0; i < 3; i++) {
      const target = randInt(5, 12);
      bulbs[i].target = target;
      bulbs[i].sum = 0;
      bulbs[i].lit = false;

      // split target into 1-3 parts to create tiles that satisfy it
      const parts = randInt(1, 3);
      let partsArr = [];
      let remaining = target;
      for (let p = parts; p > 1; p--) {
        const part = randInt(1, Math.max(1, remaining - (p - 1)));
        partsArr.push(part);
        remaining -= part;
      }
      partsArr.push(remaining);
      // shuffle parts
      shuffleArray(partsArr);
      partsArr.forEach((v) => {
        requiredTiles.push({ value: v, bulbId: i });
      });
    }

    // Add distractor tiles to make a total of 6 tiles
    tiles = [];
    const totalNeeded = Math.max(6, requiredTiles.length);
    // Put required tiles first
    requiredTiles.forEach((rt, idx) => {
      tiles.push({
        id: idx,
        value: rt.value,
        homeIndex: idx,
        assignedBulb: rt.bulbId, // not shown to player
        x: 120 + (idx % 6) * (TILE_W + TILE_GAP),
        y: 340 + Math.floor(idx / 6) * (TILE_H + 10),
        w: TILE_W,
        h: TILE_H,
        picked: false,
      });
    });

    let idxCounter = requiredTiles.length;
    while (tiles.length < totalNeeded) {
      tiles.push({
        id: idxCounter,
        value: randInt(1, 9),
        homeIndex: idxCounter,
        assignedBulb: null,
        x: 120 + (idxCounter % 6) * (TILE_W + TILE_GAP),
        y: 340 + Math.floor(idxCounter / 6) * (TILE_H + 10),
        w: TILE_W,
        h: TILE_H,
        picked: false,
      });
      idxCounter++;
    }

    // Shuffle tiles' screen positions but keep values
    shuffleArray(tiles);
    // Assign positions nicely across the bottom row
    const startX = (WIDTH - (tiles.length * TILE_W + (tiles.length - 1) * TILE_GAP)) / 2;
    tiles.forEach((t, i) => {
      t.x = startX + i * (TILE_W + TILE_GAP);
      t.y = HEIGHT - TILE_H - 30;
    });

    heldTile = null;
    focus = { type: 'tile', index: Math.max(0, Math.min(tiles.length - 1, focus.index || 0)) };
    confettiParticles = [];
    allLit = false;
    showCelebration = 0;
    draw();
  }

  // -------------------------
  // Main loop and drawing
  // -------------------------
  function loop(timestamp) {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  function update() {
    // Update bulb glow animation
    bulbs.forEach((b) => {
      if (b.lit) {
        b.glow = Math.min(1, b.glow + 0.02);
      } else {
        b.glow = Math.max(0, b.glow - 0.03);
      }
    });

    // Update confetti
    if (showCelebration > 0) {
      showCelebration -= 1;
    }
    confettiParticles.forEach((p) => {
      p.vy += 0.15;
      p.x += p.vx;
      p.y += p.vy;
      p.rot += p.vr;
      p.life -= 1;
    });
    confettiParticles = confettiParticles.filter((p) => p.life > 0);

    // Check if all bulbs lit
    if (!allLit && bulbs.every((b) => b.lit)) {
      allLit = true;
      doCelebration();
    }
  }

  function draw() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background gradient
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, '#0f1724');
    grad.addColorStop(1, '#03263a');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Wacky glowing power plant silhouette
    drawPowerPlant();

    // Draw bulbs and characters
    drawBulbs();

    // Draw tiles
    drawTiles();

    // Draw battery centerpiece with character
    drawBattery();

    // Draw instructions and UI
    drawUI();

    // Draw confetti if any
    drawConfetti();

    // If audio unavailable, draw warning
    if (!audioReady) {
      drawAudioUnavailable();
    }
  }

  // -------------------------
  // Drawing subroutines
  // -------------------------
  function drawPowerPlant() {
    // ground platform
    roundRect(ctx, 40, 220, WIDTH - 80, 200, 10, '#083249');
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(60, 250, WIDTH - 120, 140);

    // Add silly bolts and doodles
    for (let i = 0; i < 6; i++) {
      const x = 80 + i * 110;
      const y = 280 + ((i % 2) * 12);
      drawBolt(x, y, '#88ddff', 1.8);
    }
  }

  function drawBulbs() {
    bulbs.forEach((b, i) => {
      // base shadow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.ellipse(b.x, b.y + b.r + 10, b.r * 0.9, 12, 0, 0, Math.PI * 2);
      ctx.fill();

      // bulb glass
      const g = ctx.createRadialGradient(b.x - b.r * 0.3, b.y - b.r * 0.5, 10, b.x, b.y, b.r * 1.2);
      if (b.lit) {
        g.addColorStop(0, `rgba(255,255,160,${0.9 * b.glow})`);
        g.addColorStop(1, 'rgba(255,210,120,0.06)');
      } else {
        g.addColorStop(0, 'rgba(220,240,255,0.06)');
        g.addColorStop(1, 'rgba(180,200,220,0.02)');
      }
      ctx.beginPath();
      ctx.fillStyle = g;
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();

      // filament (wacky)
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate((i * 0.3) - 0.4);
      ctx.lineWidth = 3;
      ctx.strokeStyle = b.lit ? `rgba(255,220,90,${0.6 + 0.4 * b.glow})` : '#b8c6d0';
      ctx.beginPath();
      ctx.moveTo(-10, 6);
      ctx.quadraticCurveTo(0, -15, 14, 6);
      ctx.stroke();
      ctx.restore();

      // bulb rim
      ctx.beginPath();
      ctx.lineWidth = 6;
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.stroke();

      // base (metal part)
      roundRect(ctx, b.x - 34, b.y + b.r - 10, 68, 28, 6, '#868686');
      roundRect(ctx, b.x - 24, b.y + b.r + 18, 48, 10, 3, '#5a5a5a');

      // target and sum text
      ctx.font = '20px Comic Sans MS, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.95;
      ctx.fillText(`Need: ${b.target}`, b.x, b.y - b.r - 14);

      // drawn meter showing current sum
      const meterW = 120;
      const meterH = 12;
      const mx = b.x - meterW / 2;
      const my = b.y + b.r + 40;
      ctx.globalAlpha = 0.8;
      roundRect(ctx, mx, my, meterW, meterH, 8, '#1b3b4b');
      const ratio = Math.min(1, b.sum / b.target);
      roundRect(ctx, mx + 2, my + 2, (meterW - 4) * ratio, meterH - 4, 6, b.lit ? '#ffeb80' : '#6fb2d4');

      // sum number
      ctx.globalAlpha = 1;
      ctx.font = '18px sans-serif';
      ctx.fillStyle = '#fff';
      ctx.fillText(`Sum: ${b.sum}`, b.x, my + meterH + 18);

      // If focused via keyboard show outline
      if (focus.type === 'bulb' && focus.index === i && canvas === document.activeElement) {
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#ffeaa7';
        ctx.arc(b.x, b.y, b.r + 6, 0, Math.PI * 2);
        ctx.stroke();
      }
    });
    ctx.globalAlpha = 1;
  }

  function drawTiles() {
    tiles.forEach((t, i) => {
      // tile shadow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.roundRect = ctx.roundRect || roundRect;
      roundRect(ctx, t.x + 4, t.y + 6, t.w, t.h, 10, 'rgba(0,0,0,0.15)');

      // tile background
      const isHeld = heldTile === t.id || t.picked;
      const bg = isHeld ? '#ffd57a' : '#fff';
      const border = '#3b3b3b';
      roundRect(ctx, t.x, t.y, t.w, t.h, 12, bg);
      ctx.lineWidth = 3;
      ctx.strokeStyle = border;
      ctx.strokeRect(t.x + 0.5, t.y + 0.5, t.w - 1, t.h - 1);

      // number text
      ctx.fillStyle = '#2b2b2b';
      ctx.font = '28px Comic Sans MS, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(String(t.value), t.x + t.w / 2, t.y + t.h / 2 + 10);

      // Focus ring for keyboard focus
      if (focus.type === 'tile' && focus.index === i && canvas === document.activeElement) {
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#86f3ff';
        roundRect(ctx, t.x - 6, t.y - 6, t.w + 12, t.h + 12, 16, 'transparent');
        ctx.stroke();
      }
    });

    // If dragging with mouse, draw held tile following pointer
    if (pointer.isDown && heldTile !== null) {
      const t = findTileById(heldTile);
      if (t) {
        ctx.save();
        ctx.globalAlpha = 0.95;
        const px = pointer.x - t.w / 2;
        const py = pointer.y - t.h / 2;
        roundRect(ctx, px, py, t.w, t.h, 12, '#ffeaa7');
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#3b3b3b';
        ctx.strokeRect(px + 0.5, py + 0.5, t.w - 1, t.h - 1);
        ctx.fillStyle = '#2b2b2b';
        ctx.font = '28px Comic Sans MS, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(String(t.value), px + t.w / 2, py + t.h / 2 + 10);
        ctx.restore();
      }
    }
  }

  function drawBattery() {
    // center battery with character
    const bx = WIDTH / 2;
    const by = 240;
    // battery body
    roundRect(ctx, bx - 80, by - 30, 160, 80, 14, '#263238');
    roundRect(ctx, bx - 70, by - 24, 140, 68, 10, '#375661');
    // battery top indicator
    roundRect(ctx, bx - 40, by - 48, 80, 18, 8, '#f6d365');
    // little face of character
    const char = characters[0];
    ctx.beginPath();
    ctx.fillStyle = char.color;
    ctx.arc(bx, by + 6, 28, 0, Math.PI * 2);
    ctx.fill();
    // eyes
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(bx - 10, by + 2, 3.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bx + 10, by + 2, 3.8, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.beginPath();
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 2;
    ctx.arc(bx, by + 8, 10, 0, Math.PI, false);
    ctx.stroke();

    // Circuit wires between battery and bulbs
    bulbs.forEach((b, i) => {
      const sx = bx;
      const sy = by - 18;
      const ex = b.x;
      const ey = b.y + b.r + 14;

      // wavy wire
      ctx.beginPath();
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      const grad = ctx.createLinearGradient(sx, sy, ex, ey);
      grad.addColorStop(0, '#ffefc0');
      grad.addColorStop(1, '#9be7ff');
      ctx.strokeStyle = grad;
      const midx = (sx + ex) / 2 + Math.sin(performance.now() / 400 + i) * 6;
      ctx.moveTo(sx, sy);
      ctx.quadraticCurveTo(midx, (sy + ey) / 2 + 10, ex, ey);
      ctx.stroke();

      // tiny spark traveling when lit
      if (b.lit) {
        const t = (performance.now() / 350) % 1;
        const ax = quadraticPoint(sx, sy, midx, (sy + ey) / 2 + 10, ex, ey, t);
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,230,120,0.95)';
        ctx.arc(ax.x, ax.y, 8 + Math.sin(performance.now() / 120) * 2, 0, Math.PI * 2);
        ctx.fill();
        // glow
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,230,120,0.18)';
        ctx.arc(ax.x, ax.y, 20, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    // small label
    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.fillText('Battery: Feed the bulbs with number tiles!', bx, by + 58);
  }

  function drawUI() {
    // Title
    ctx.font = '28px "Comic Sans MS", sans-serif';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'left';
    ctx.fillText('Spark Workshop — Match each bulb to its needed energy', 18, 36);

    // Instructions box
    const instructions = [
      'Drag number tiles to bulbs to make the bulb reach its target number.',
      'You can also use the keyboard:',
      '  - Tab / Left-Right to move focus between tiles/bulbs.',
      '  - Space or Enter to pick up / drop a tile.',
      '  - A to toggle audio, R to reset.',
    ];
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#dbeeff';
    let y = 60;
    instructions.forEach((line) => {
      ctx.fillText(line, 18, y);
      y += 18;
    });

    // Draw audio speaker icon with on/off
    drawSpeakerIcon(WIDTH - 60, 36, audioReady && audioAllowed);

    // If there is a tile held by keyboard, show hint
    if (heldTile !== null && !pointer.isDown) {
      const t = findTileById(heldTile);
      if (t) {
        ctx.font = '13px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.fillText(`Holding tile ${t.value} — move focus to a bulb and press Enter to drop`, 18, HEIGHT - 14);
      }
    }
  }

  function drawConfetti() {
    confettiParticles.forEach((p) => {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
      ctx.restore();
    });

    if (allLit) {
      ctx.font = '36px "Comic Sans MS", sans-serif';
      ctx.fillStyle = '#ffd27f';
      ctx.textAlign = 'center';
      ctx.fillText('All bulbs glowing! Great job!', WIDTH / 2, 220);

      // Draw celebratory waves
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,150,${0.12 + 0.06 * i})`;
        ctx.lineWidth = 8 - i * 2;
        ctx.arc(WIDTH / 2, 230, 90 + i * 26 + Math.sin(performance.now() / 400) * 6, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  }

  function drawAudioUnavailable() {
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#ffcccc';
    ctx.textAlign = 'right';
    const msg = 'Audio unavailable';
    ctx.fillText(msg, WIDTH - 18, HEIGHT - 14);
  }

  // -------------------------
  // Interaction Handlers
  // -------------------------
  function onPointerDown(e) {
    const rect = canvas.getBoundingClientRect();
    pointer.isDown = true;
    pointer.x = e.clientX - rect.left;
    pointer.y = e.clientY - rect.top;

    // Check tiles first
    const t = tileAt(pointer.x, pointer.y);
    if (t) {
      heldTile = t.id;
      t.picked = true;
      playClick();
      return;
    }

    // Check if clicked a bulb to drop (if holding via keyboard)
    const b = bulbAt(pointer.x, pointer.y);
    if (b && heldTile !== null) {
      dropTileOnBulb(heldTile, b.id);
      playDrop();
      return;
    }
  }

  function onPointerMove(e) {
    const rect = canvas.getBoundingClientRect();
    pointer.x = e.clientX - rect.left;
    pointer.y = e.clientY - rect.top;
  }

  function onPointerUp(e) {
    if (!pointer.isDown) return;
    pointer.isDown = false;
    const rect = canvas.getBoundingClientRect();
    pointer.x = e.clientX - rect.left;
    pointer.y = e.clientY - rect.top;

    if (heldTile !== null) {
      const b = bulbAt(pointer.x, pointer.y);
      if (b) {
        dropTileOnBulb(heldTile, b.id);
      } else {
        // Return tile home
        const t = findTileById(heldTile);
        if (t) {
          t.picked = false;
        }
      }
      heldTile = null;
    }
  }

  function onTouchDown(e) {
    e.preventDefault();
    if (e.touches && e.touches.length) {
      const rect = canvas.getBoundingClientRect();
      pointer.isDown = true;
      pointer.x = e.touches[0].clientX - rect.left;
      pointer.y = e.touches[0].clientY - rect.top;

      const t = tileAt(pointer.x, pointer.y);
      if (t) {
        heldTile = t.id;
        t.picked = true;
        playClick();
      }
    }
  }

  function onTouchMove(e) {
    e.preventDefault();
    if (e.touches && e.touches.length) {
      const rect = canvas.getBoundingClientRect();
      pointer.x = e.touches[0].clientX - rect.left;
      pointer.y = e.touches[0].clientY - rect.top;
    }
  }

  function onTouchUp(e) {
    e.preventDefault();
    if (!pointer.isDown) return;
    pointer.isDown = false;
    if (heldTile !== null) {
      const b = bulbAt(pointer.x, pointer.y);
      if (b) {
        dropTileOnBulb(heldTile, b.id);
      } else {
        const t = findTileById(heldTile);
        if (t) t.picked = false;
      }
      heldTile = null;
    }
  }

  function onKeyDown(e) {
    // Ensure canvas focus for keyboard control
    if (e.key === 'Tab') {
      e.preventDefault();
      // cycle focus: tile -> bulb -> tile...
      if (focus.type === 'tile') {
        focus.type = 'bulb';
        focus.index = 0;
      } else {
        focus.type = 'tile';
        focus.index = 0;
      }
      draw();
      return;
    }

    if (e.key === 'ArrowLeft' || e.key === 'Left') {
      e.preventDefault();
      if (focus.type === 'tile') {
        focus.index = (focus.index - 1 + tiles.length) % tiles.length;
      } else {
        focus.index = (focus.index - 1 + bulbs.length) % bulbs.length;
      }
      draw();
      return;
    }
    if (e.key === 'ArrowRight' || e.key === 'Right') {
      e.preventDefault();
      if (focus.type === 'tile') {
        focus.index = (focus.index + 1) % tiles.length;
      } else {
        focus.index = (focus.index + 1) % bulbs.length;
      }
      draw();
      return;
    }

    if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
      e.preventDefault();
      // Pick up or drop
      if (heldTile === null && focus.type === 'tile') {
        // pick tile
        const t = tiles[focus.index];
        heldTile = t.id;
        t.picked = true;
        playClick();
      } else if (heldTile !== null && focus.type === 'bulb') {
        const b = bulbs[focus.index];
        dropTileOnBulb(heldTile, b.id);
        heldTile = null;
      } else if (heldTile !== null && focus.type === 'tile') {
        // If pressing Enter while holding and focus on tile, drop it back home
        const t = findTileById(heldTile);
        if (t) {
          t.picked = false;
        }
        heldTile = null;
      }
      draw();
      return;
    }

    if (e.key.toLowerCase() === 'a') {
      e.preventDefault();
      toggleAudio();
      return;
    }

    if (e.key.toLowerCase() === 'r') {
      e.preventDefault();
      resetGame();
      return;
    }
  }

  // -------------------------
  // Game logic
  // -------------------------
  function dropTileOnBulb(tileId, bulbId) {
    const tile = findTileById(tileId);
    const bulb = bulbs.find((b) => b.id === bulbId);
    if (!tile || !bulb) return;

    // attempt to add tile.value to bulb sum
    const newSum = bulb.sum + tile.value;
    if (newSum > bulb.target) {
      // wrong: overcharged
      playWrong();
      // visual shake or bounce - indicate by briefly moving tile
      tile.picked = false;
      // quick flash effect on bulb
      bulb.glow = Math.min(1, bulb.glow + 0.6);
      return;
    } else {
      // Success: attach tile, increase bulb sum
      bulb.sum = newSum;
      tile.picked = false;
      // remove tile from list (so it can't be used again)
      const idx = tiles.findIndex((t) => t.id === tile.id);
      if (idx >= 0) {
        // animate tile removed - for simplicity remove instantly
        tiles.splice(idx, 1);
        // adjust focus index
        if (focus.type === 'tile') {
          focus.index = Math.max(0, Math.min(tiles.length - 1, focus.index));
        }
      }
      playCorrect();
      // if exactly meets target, light bulb
      if (bulb.sum === bulb.target) {
        bulb.lit = true;
        spawnFriendlySpark(bulb.x, bulb.y);
      }
    }
  }

  function spawnFriendlySpark(x, y) {
    // small sparkle particles
    for (let i = 0; i < 12; i++) {
      confettiParticles.push({
        x: x + randInt(-8, 8),
        y: y + randInt(-8, 8),
        vx: randFloat(-2, 2),
        vy: randFloat(-3, -1),
        size: randInt(4, 9),
        rot: 0,
        vr: randFloat(-0.2, 0.2),
        life: randInt(30, 70),
        color: randChoice(['#ffdf7a', '#ffd7a8', '#ffd1ff', '#b3f0ff']),
      });
    }
  }

  function doCelebration() {
    // Big confetti
    for (let i = 0; i < 80; i++) {
      confettiParticles.push({
        x: randFloat(80, WIDTH - 80),
        y: randFloat(-20, 40),
        vx: randFloat(-2.5, 2.5),
        vy: randFloat(0.5, 3.0),
        size: randInt(6, 12),
        rot: randFloat(0, Math.PI),
        vr: randFloat(-0.1, 0.1),
        life: randInt(100, 240),
        color: randChoice(['#ffdf7a', '#ffd7a8', '#ffd1ff', '#b3f0ff', '#a8f4b3', '#ffd0d0']),
      });
    }
    showCelebration = 200;
    playVictory();
  }

  // -------------------------
  // Audio functions (Web Audio API)
  // -------------------------
  function setupBackgroundHum() {
    if (!audioReady) return;
    try {
      // Create a gentle background hum (low-frequency oscillator)
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = 60; // low hum
      backgroundGain = audioCtx.createGain();
      backgroundGain.gain.value = 0.0019; // very gentle
      const biquad = audioCtx.createBiquadFilter();
      biquad.type = 'lowpass';
      biquad.frequency.value = 300;

      osc.connect(biquad);
      biquad.connect(backgroundGain);
      backgroundGain.connect(audioCtx.destination);
      osc.start();
    } catch (err) {
      console.warn('Error setting up background hum:', err);
      audioReady = false;
      audioError = err;
    }
  }

  function toggleAudio() {
    if (!audioReady) {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioReady = true;
        setupBackgroundHum();
      } catch (err) {
        audioError = err;
        audioReady = false;
        alert('Audio cannot be enabled on this device or browser.');
        return;
      }
    }
    audioAllowed = !audioAllowed;
    if (backgroundGain) {
      backgroundGain.gain.value = audioAllowed ? 0.0019 : 0;
    }
    if (audioAllowed) {
      playClick();
    }
  }

  function playTone(freq, type = 'sine', dur = 0.18, volume = 0.08) {
    if (!audioReady || !audioAllowed) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = Math.max(500, freq * 4);

      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start(now);
      osc.stop(now + dur + 0.02);
    } catch (err) {
      console.warn('playTone error', err);
    }
  }

  function playClick() {
    playTone(880, 'square', 0.08, 0.06);
  }
  function playCorrect() {
    playTone(1100, 'sine', 0.15, 0.08);
    setTimeout(() => playTone(1400, 'sine', 0.12, 0.06), 120);
  }
  function playWrong() {
    playTone(220, 'sawtooth', 0.18, 0.08);
  }
  function playDrop() {
    playTone(520, 'sine', 0.12, 0.05);
  }
  function playVictory() {
    playTone(880, 'sine', 0.15, 0.09);
    setTimeout(() => playTone(1040, 'sine', 0.14, 0.09), 160);
    setTimeout(() => playTone(1240, 'sine', 0.14, 0.09), 320);
  }

  // -------------------------
  // Utility helpers
  // -------------------------
  function tileAt(x, y) {
    for (let i = tiles.length - 1; i >= 0; i--) {
      const t = tiles[i];
      if (x >= t.x && x <= t.x + t.w && y >= t.y && y <= t.y + t.h) {
        return t;
      }
    }
    return null;
  }

  function bulbAt(x, y) {
    for (let i = 0; i < bulbs.length; i++) {
      const b = bulbs[i];
      const dx = x - b.x;
      const dy = y - b.y;
      if (dx * dx + dy * dy <= b.r * b.r) return b;
    }
    return null;
  }

  function findTileById(id) {
    return tiles.find((t) => t.id === id) || null;
  }

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function randFloat(min, max) {
    return Math.random() * (max - min) + min;
  }
  function randChoice(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }
  function shuffleArray(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
  }

  // Rounded rectangle helper
  function roundRect(ctx, x, y, w, h, r, fillStyle) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillStyle && fillStyle !== 'transparent') {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
  }

  // Quadratic bezier point helper for spark motion
  function quadraticPoint(x0, y0, cx, cy, x1, y1, t) {
    // two-phase quadratic: treat control as cx,cy then compute
    const xa = x0 + (cx - x0) * t;
    const ya = y0 + (cy - y0) * t;
    const xb = cx + (x1 - cx) * t;
    const yb = cy + (y1 - cy) * t;
    return { x: xa + (xb - xa) * t, y: ya + (yb - ya) * t };
  }

  // Draw bolt doodle
  function drawBolt(x, y, color, scale = 1) {
    ctx.beginPath();
    ctx.moveTo(x - 6 * scale, y - 12 * scale);
    ctx.lineTo(x + 2 * scale, y - 2 * scale);
    ctx.lineTo(x - 2 * scale, y - 2 * scale);
    ctx.lineTo(x + 6 * scale, y + 12 * scale);
    ctx.lineTo(x - 2 * scale, y + 2 * scale);
    ctx.lineTo(x + 2 * scale, y + 2 * scale);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0,0,0,0.12)';
    ctx.stroke();
  }

  // Speaker icon region detection and drawing
  function drawSpeakerIcon(cx, cy, on) {
    // Draw simple speaker icon
    const size = 20;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();
    ctx.fillStyle = on ? '#9fffbf' : '#ff9f9f';
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    roundRect(ctx, -size, -12, 18, 24, 4, '#24343a');
    // speaker triangle
    ctx.beginPath();
    ctx.moveTo(-size + 6, -6);
    ctx.lineTo(-size + 18, -16);
    ctx.lineTo(-size + 18, 16);
    ctx.closePath();
    ctx.fillStyle = on ? '#fff' : '#fff';
    ctx.fill();
    // sound waves
    if (on) {
      ctx.beginPath();
      ctx.strokeStyle = '#cff7d8';
      ctx.lineWidth = 2;
      ctx.arc(size * 0.2, 0, 8, -0.6, 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.strokeStyle = '#9fffbf';
      ctx.lineWidth = 2;
      ctx.arc(size * 0.2, 0, 12, -0.6, 0.6);
      ctx.stroke();
    } else {
      // draw muted X
      ctx.beginPath();
      ctx.strokeStyle = '#ffb2b2';
      ctx.lineWidth = 3;
      ctx.moveTo(6, -8);
      ctx.lineTo(14, 8);
      ctx.moveTo(14, -8);
      ctx.lineTo(6, 8);
      ctx.stroke();
    }
    ctx.restore();
  }

  function isPointInSpeaker(x, y) {
    // approximate area near top-right where speaker is drawn
    const sx = WIDTH - 60;
    const sy = 36;
    return x >= sx - 28 && x <= sx + 28 && y >= sy - 20 && y <= sy + 20;
  }

  // Canvas polyfill for roundRect stroke if missing
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      roundRect(this, x, y, w, h, r, 'transparent');
    };
  }
})();
---

