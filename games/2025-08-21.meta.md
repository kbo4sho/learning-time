# Game of the Day - 2025-08-21

## Metadata
- **Generated Date:** 2025-08-21
- **Generated Time:** 2025-08-21T00:21:28.654005
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-21.js
- **File Size:** 28539 bytes
- **Tokens Used:** 9992

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-21.js` - The playable game
- `2025-08-21.meta.json` - Machine-readable metadata
- `2025-08-21.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20685

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23189

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Electricity Math Game - "Spark's Circuit Quest"
  // Ages 7-9, addition/subtraction practice with an electrical theme.
  // Renders into existing HTML element with id "game-of-the-day-stage".
  // All graphics drawn on canvas. All audio generated with Web Audio API.
  // Accessible: keyboard controls, aria-label updates, visual audio cues, error handling.

  // ------------------ Setup and Utilities ------------------
  const CONTAINER_ID = "game-of-the-day-stage";
  const WIDTH = 720;
  const HEIGHT = 480;

  // Find container
  const container = document.getElementById(CONTAINER_ID);
  if (!container) {
    console.error(`Container element with id "${CONTAINER_ID}" not found.`);
    return;
  }
  // Clear container
  container.innerHTML = "";

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.setAttribute("role", "img");
  canvas.setAttribute(
    "aria-label",
    "Spark's Circuit Quest. Use arrow keys or WASD to move Spark the electron. Collect numbered orbs to match the target power for each bulb. Press M to toggle sound. Press Enter to start."
  );
  canvas.setAttribute("tabindex", "0"); // make focusable
  canvas.title = "Spark's Circuit Quest - Canvas Game";
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d", { alpha: false });

  // Keyboard state
  const keys = {};
  // Mouse state
  let mouse = { x: 0, y: 0, down: false };

  // Focus canvas for keyboard
  canvas.focus();

  // Helper: clamp
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // ----------- Audio Setup (Web Audio API) -------------
  let audioContext = null;
  let audioAvailable = true;
  let audioMuted = false;
  let bgGain = null;
  let bgOsc = null;
  let bgFilter = null;

  // Try to create AudioContext with error handling
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) {
      throw new Error("Web Audio API not supported in this browser.");
    }
    audioContext = new AudioCtx();
  } catch (e) {
    console.warn("AudioContext creation failed:", e);
    audioAvailable = false;
    audioContext = null;
  }

  // Ensure audio resumes on first user gesture (browsers require that)
  function tryResumeAudio() {
    if (!audioAvailable || !audioContext) return;
    if (audioContext.state === "suspended") {
      audioContext
        .resume()
        .then(() => {
          // Start background hum if not already
          startBackgroundHum();
        })
        .catch((err) => {
          console.warn("Failed to resume audio context:", err);
        });
    } else {
      startBackgroundHum();
    }
  }

  function startBackgroundHum() {
    if (!audioAvailable || !audioContext) return;
    if (bgOsc) return; // already started
    try {
      bgOsc = audioContext.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 110; // low hum
      bgFilter = audioContext.createBiquadFilter();
      bgFilter.type = "lowpass";
      bgFilter.frequency.value = 800;
      bgGain = audioContext.createGain();
      bgGain.gain.value = audioMuted ? 0 : 0.02;
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(audioContext.destination);
      bgOsc.start();
    } catch (err) {
      console.warn("Background hum start failed:", err);
    }
  }

  function stopBackgroundHum() {
    if (!audioAvailable || !audioContext || !bgOsc) return;
    try {
      bgOsc.stop();
    } catch (e) {
      /* ignore */
    }
    bgOsc.disconnect();
    bgFilter && bgFilter.disconnect();
    bgGain && bgGain.disconnect();
    bgOsc = null;
    bgFilter = null;
    bgGain = null;
  }

  // Simple beep generator for correct/incorrect/pickup
  function playTone({ freq = 440, duration = 0.15, type = "sine", volume = 0.08 }) {
    if (!audioAvailable || !audioContext || audioMuted) return;
    try {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, audioContext.currentTime);
      gain.gain.setValueAtTime(volume, audioContext.currentTime);
      // small decay
      gain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);
      osc.connect(gain);
      gain.connect(audioContext.destination);
      osc.start();
      osc.stop(audioContext.currentTime + duration + 0.02);
    } catch (err) {
      console.warn("playTone error:", err);
    }
  }

  function playCorrectChime() {
    // little arpeggio
    playTone({ freq: 880, duration: 0.12, type: "sine", volume: 0.06 });
    setTimeout(() => playTone({ freq: 660, duration: 0.12, type: "sine", volume: 0.06 }), 110);
    setTimeout(() => playTone({ freq: 990, duration: 0.16, type: "sine", volume: 0.08 }), 230);
  }

  function playBuzz() {
    // buzz with low frequency noise-ish
    if (!audioAvailable || !audioContext || audioMuted) return;
    try {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      osc.type = "square";
      osc.frequency.value = 120;
      filter.type = "lowpass";
      filter.frequency.value = 600;
      gain.gain.value = 0.08;
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);
      osc.start();
      gain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.4);
      osc.stop(audioContext.currentTime + 0.45);
    } catch (err) {
      console.warn("playBuzz error:", err);
    }
  }

  // ------------- Game Variables ----------------
  let lastTime = 0;
  let running = false;

  // Characters and theme
  const characters = {
    spark: {
      name: "Spark",
      color: "#FFD66B",
      x: WIDTH / 2,
      y: HEIGHT - 80,
      radius: 18,
      speed: 180, // pixels per second
    },
    professor: {
      name: "Professor Ohm",
      color: "#9FD8FF",
    },
    bulby: {
      name: "Bulby",
      color: "#FFF1C6",
    },
  };

  // Game state
  let level = 1;
  let bulbsToPower = 3;
  let currentBulbIndex = 0;
  let targetValue = 10;
  let orbs = []; // number orbs on screen
  let collectedSum = 0;
  let lives = 3;
  let score = 0;
  let phase = "start"; // start, playing, success, gameover
  let flashTimer = 0;
  let gentleParticles = [];

  // Accessibility state: update canvas aria-label with dynamic info
  function updateAria() {
    const ariaText =
      `Spark's Circuit Quest. Level ${level}, Bulb ${currentBulbIndex + 1} of ${bulbsToPower}. ` +
      `Target power ${targetValue}. Current collected ${collectedSum}. Lives ${lives}. ` +
      `Use arrow keys or WASD to move. Press M to toggle sound. Press Enter to start or continue.`;
    canvas.setAttribute("aria-label", ariaText);
  }

  // ------------- Procedural content ----------------
  function generateOrbs(count = 6) {
    orbs = [];
    for (let i = 0; i < count; i++) {
      const val = Math.floor(Math.random() * 9) + 1; // 1..9
      const r = 18 + Math.random() * 12;
      const x = 60 + Math.random() * (WIDTH - 120);
      const y = 80 + Math.random() * (HEIGHT - 200);
      const vx = (Math.random() * 2 - 1) * 40;
      const vy = (Math.random() * 2 - 1) * 30;
      const phase = Math.random() * Math.PI * 2;
      orbs.push({
        value: val,
        x,
        y,
        r,
        vx,
        vy,
        wobble: 20 + Math.random() * 30,
        baseY: y,
        phase,
        floatSpeed: 0.8 + Math.random() * 1.2,
        id: Math.random().toString(36).slice(2, 9),
      });
    }
  }

  function nextBulb() {
    currentBulbIndex++;
    collectedSum = 0;
    if (currentBulbIndex >= bulbsToPower) {
      // level completed
      level++;
      bulbsToPower = Math.min(4 + level, 6);
      currentBulbIndex = 0;
      score += 50; // bonus
      phase = "success";
      setTimeout(() => {
        startLevel();
        phase = "playing";
      }, 1600);
    } else {
      // new bulb target
      setUpCurrentBulb();
    }
    updateAria();
  }

  function setUpCurrentBulb() {
    // target increases with level and bulb index
    const base = 6 + level * 2 + currentBulbIndex * 1;
    targetValue = base + Math.floor(Math.random() * 8); // e.g., 6..13 base plus 0..7 -> in range ~6..20
    // ensure target is not less than 4
    targetValue = Math.max(4, targetValue);
    generateOrbs(6 + Math.min(level, 3));
    collectedSum = 0;
    flashTimer = 0;
    updateAria();
  }

  function startLevel() {
    phase = "playing";
    setUpCurrentBulb();
    lives = Math.max(1, 3 - Math.floor(level / 3));
    score = 0;
    characters.spark.x = WIDTH / 2;
    characters.spark.y = HEIGHT - 80;
  }

  function resetGame() {
    level = 1;
    bulbsToPower = 3;
    currentBulbIndex = 0;
    score = 0;
    lives = 3;
    startLevel();
  }

  // ------------- Input Handlers ----------------
  window.addEventListener("keydown", (e) => {
    keys[e.key.toLowerCase()] = true;
    // allow resume audio on any key press
    tryResumeAudio();

    if (e.key === "m" || e.key === "M") {
      audioMuted = !audioMuted;
      if (bgGain) bgGain.gain.value = audioMuted ? 0 : 0.02;
      updateAria();
      e.preventDefault();
    }

    if (e.key === "Enter") {
      if (phase === "start" || phase === "gameover" || phase === "success") {
        resetGame();
        phase = "playing";
      }
      e.preventDefault();
    }
  });
  window.addEventListener("keyup", (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  canvas.addEventListener("mousedown", (e) => {
    mouse.down = true;
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    // click is considered a user gesture; resume audio
    tryResumeAudio();
    // On click during start screen start the game
    if (phase === "start" || phase === "gameover" || phase === "success") {
      resetGame();
      phase = "playing";
    }
  });

  canvas.addEventListener("mouseup", () => {
    mouse.down = false;
  });

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });

  // Touch support: translate to mouse
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const t = e.touches[0];
    mouse.down = true;
    mouse.x = t.clientX - rect.left;
    mouse.y = t.clientY - rect.top;
    tryResumeAudio();
    if (phase === "start" || phase === "gameover" || phase === "success") {
      resetGame();
      phase = "playing";
    }
  }, { passive: false });

  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const t = e.touches[0];
    mouse.x = t.clientX - rect.left;
    mouse.y = t.clientY - rect.top;
  }, { passive: false });

  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    mouse.down = false;
  }, { passive: false });

  // ------------- Collision Helpers --------------
  function dist2(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
  }

  // ------------- Particle gentle background -------------
  function spawnParticles() {
    gentleParticles = [];
    for (let i = 0; i < 40; i++) {
      gentleParticles.push({
        x: Math.random() * WIDTH,
        y: Math.random() * HEIGHT,
        r: 1 + Math.random() * 2.5,
        alpha: 0.08 + Math.random() * 0.18,
        vy: 2 + Math.random() * 5,
        vx: -1 + Math.random() * 2,
      });
    }
  }

  // ------------- Gameplay Logic ----------------
  function update(dt) {
    if (phase === "start") {
      // slow gentle bob of characters
      for (const p of gentleParticles) {
        p.x += p.vx * dt;
        p.y += p.vy * dt * 0.2;
        if (p.x < -10) p.x = WIDTH + 10;
        if (p.x > WIDTH + 10) p.x = -10;
      }
      return;
    }

    if (phase === "gameover" || phase === "success") {
      // animate spark gently
      characters.spark.y += Math.sin(Date.now() / 300) * 0.02;
      return;
    }

    // Movement: keyboard or mouse control
    const sp = characters.spark;
    let moveX = 0;
    let moveY = 0;
    if (keys["arrowleft"] || keys["a"]) moveX -= 1;
    if (keys["arrowright"] || keys["d"]) moveX += 1;
    if (keys["arrowup"] || keys["w"]) moveY -= 1;
    if (keys["arrowdown"] || keys["s"]) moveY += 1;

    const usingMouse = mouse.down;
    if (usingMouse) {
      // Move toward mouse slowly
      const dx = mouse.x - sp.x;
      const dy = mouse.y - sp.y;
      const dist = Math.hypot(dx, dy);
      if (dist > 4) {
        moveX = dx / dist;
        moveY = dy / dist;
      } else {
        moveX = 0;
        moveY = 0;
      }
    }

    if (moveX !== 0 || moveY !== 0) {
      // Normalize
      const mag = Math.hypot(moveX, moveY);
      moveX /= mag || 1;
      moveY /= mag || 1;
      sp.x += moveX * sp.speed * dt;
      sp.y += moveY * sp.speed * dt;
      // Keep inside bounds
      sp.x = clamp(sp.x, 24, WIDTH - 24);
      sp.y = clamp(sp.y, 24, HEIGHT - 24);
    }

    // Orbs float and bounce
    for (const o of orbs) {
      o.phase += dt * o.floatSpeed;
      o.y = o.baseY + Math.sin(o.phase) * o.wobble;
      o.x += o.vx * dt;
      if (o.x < 24) {
        o.x = 24;
        o.vx *= -1;
      }
      if (o.x > WIDTH - 24) {
        o.x = WIDTH - 24;
        o.vx *= -1;
      }
      // gentle vy nudge
      o.baseY += Math.sin(Date.now() / 1000 + o.phase) * 0.02;
    }

    // Check collisions with orbs
    for (let i = orbs.length - 1; i >= 0; i--) {
      const o = orbs[i];
      const rr = (sp.radius + o.r) * (sp.radius + o.r);
      if (dist2(sp.x, sp.y, o.x, o.y) < rr) {
        collectedSum += o.value;
        // small animation: push spark out a bit
        const ang = Math.atan2(sp.y - o.y, sp.x - o.x);
        sp.x += Math.cos(ang) * 8;
        sp.y += Math.sin(ang) * 8;
        // play pickup tone
        playTone({ freq: 660 + o.value * 22, duration: 0.08, type: "sine", volume: 0.06 });
        // remove orb
        orbs.splice(i, 1);
        // spawn replacement with some chance
        if (Math.random() < 0.6) {
          setTimeout(() => {
            const val = Math.floor(Math.random() * 9) + 1;
            const r = 18 + Math.random() * 12;
            const x = 60 + Math.random() * (WIDTH - 120);
            const y = 80 + Math.random() * (HEIGHT - 200);
            orbs.push({
              value: val,
              x,
              y,
              r,
              vx: (Math.random() * 2 - 1) * 40,
              vy: (Math.random() * 2 - 1) * 30,
              wobble: 20 + Math.random() * 30,
              baseY: y,
              phase: Math.random() * Math.PI * 2,
              floatSpeed: 0.8 + Math.random() * 1.2,
              id: Math.random().toString(36).slice(2, 9),
            });
          }, 600 + Math.random() * 600);
        }
      }
    }

    // Check sums
    if (collectedSum === targetValue) {
      // Success for this bulb
      score += 10;
      playCorrectChime();
      nextBulb();
    } else if (collectedSum > targetValue) {
      // Overloaded! Buzz and penalty
      playBuzz();
      flashTimer = 0.8;
      collectedSum = 0;
      lives--;
      if (lives <= 0) {
        phase = "gameover";
        updateAria();
      }
    }

    // update flash timer
    if (flashTimer > 0) {
      flashTimer -= dt;
      if (flashTimer < 0) flashTimer = 0;
    }

    // Gentle particles drift
    for (const p of gentleParticles) {
      p.x += p.vx * dt * 10;
      p.y += p.vy * dt * 0.5;
      if (p.y > HEIGHT + 10) p.y = -10;
      if (p.x > WIDTH + 10) p.x = -10;
      if (p.x < -10) p.x = WIDTH + 10;
    }

    // If orbs are empty, generate fresh
    if (orbs.length < 3) {
      generateOrbs(6);
    }

    updateAria();
  }

  // ------------- Drawing Helpers ----------------
  function clear() {
    // calm teal background
    ctx.fillStyle = "#102827"; // deep greenish for electrical vibe
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  function drawBackground() {
    // soft glowing panels (canvas only)
    // draw a large rounded rect fuse-like panel
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "#B8F0E0";
    roundRect(ctx, 40, 40, WIDTH - 80, HEIGHT - 90, 18, true, false);
    ctx.restore();

    // Wacky wires and sparkles
    ctx.save();
    ctx.globalAlpha = 0.6;
    for (let i = 0; i < 4; i++) {
      drawWavyWire(60 + i * 140, 60 + i * 30, WIDTH - 120 - i * 80, 60 + i * 30 + 120, i * 0.4);
    }
    ctx.restore();

    // gentle floating particles
    for (const p of gentleParticles) {
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,220,${p.alpha})`;
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawWavyWire(x1, y1, x2, y2, wobble) {
    const segments = 12;
    ctx.beginPath();
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const x = x1 + (x2 - x1) * t;
      const y = y1 + (y2 - y1) * t + Math.sin(t * Math.PI * 2 + wobble * 2) * 6;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = "#FFD66B";
    ctx.lineWidth = 2 + Math.sin(Date.now() / 700 + wobble) * 0.8;
    ctx.stroke();

    // little nodes along the wire
    for (let i = 0; i <= segments; i += 3) {
      const t = i / segments;
      const x = x1 + (x2 - x1) * t;
      const y = y1 + (y2 - y1) * t + Math.sin(t * Math.PI * 2 + wobble * 2) * 6;
      ctx.beginPath();
      ctx.fillStyle = "#9FD8FF";
      ctx.arc(x, y, 3 + Math.abs(Math.sin(Date.now() / 300 + i)) * 1.4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === "undefined") r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawCharacters() {
    // Professor Ohm (left): resistor-snail
    const profX = 100;
    const profY = HEIGHT - 110;
    ctx.save();
    ctx.fillStyle = "#7FD1A0";
    roundRect(ctx, profX - 36, profY - 18, 72, 36, 18, true, false);
    // make eyes
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.arc(profX - 12, profY - 3, 6, 0, Math.PI * 2);
    ctx.arc(profX + 12, profY - 3, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#2B2D42";
    ctx.beginPath();
    ctx.arc(profX - 12, profY - 2, 3, 0, Math.PI * 2);
    ctx.arc(profX + 12, profY - 2, 3, 0, Math.PI * 2);
    ctx.fill();
    // little antenna
    ctx.strokeStyle = "#9FD8FF";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(profX - 36, profY - 10);
    ctx.quadraticCurveTo(profX - 60, profY - 32, profX - 40, profY - 46);
    ctx.stroke();
    ctx.restore();

    // Bulb (right): shows current bulb status
    const bulbX = WIDTH - 120;
    const bulbY = 120;
    ctx.save();
    // filament and glow depend on collected sum vs target
    const percent = clamp(collectedSum / targetValue, 0, 1);
    const glow = 0.08 + percent * 0.6;
    // glow
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,230,130,${glow})`;
    ctx.arc(bulbX, bulbY, 50 + percent * 10, 0, Math.PI * 2);
    ctx.fill();
    // bulb glass
    ctx.beginPath();
    ctx.fillStyle = "#FFF8D8";
    ctx.arc(bulbX, bulbY, 36, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#F5E6A2";
    ctx.lineWidth = 2;
    ctx.stroke();
    // filament
    ctx.strokeStyle = `rgba(255,120,50,${0.5 + percent * 0.5})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(bulbX - 10, bulbY);
    ctx.quadraticCurveTo(bulbX, bulbY - 12 - percent * 8, bulbX + 10, bulbY);
    ctx.stroke();
    // base
    ctx.fillStyle = "#C7C7C7";
    ctx.fillRect(bulbX - 18, bulbY + 28, 36, 14);
    ctx.restore();
  }

  function drawOrbs() {
    for (const o of orbs) {
      // ring glow
      ctx.beginPath();
      const glowAlpha = 0.14 + Math.abs(Math.sin(Date.now() / 400 + o.phase)) * 0.08;
      ctx.fillStyle = `rgba(255, 220, 120, ${glowAlpha})`;
      ctx.arc(o.x, o.y, o.r + 8, 0, Math.PI * 2);
      ctx.fill();
      // orb body
      ctx.beginPath();
      ctx.fillStyle = "#FFD66B";
      ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
      ctx.fill();
      // number
      ctx.fillStyle = "#2B2D42";
      ctx.font = `${Math.max(12, o.r)}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(o.value), o.x, o.y + 1);
      // tiny spark lines
      ctx.beginPath();
      ctx.strokeStyle = "rgba(255,255,255,0.7)";
      ctx.moveTo(o.x - o.r / 1.4, o.y - o.r / 1.4);
      ctx.lineTo(o.x - o.r / 3, o.y - o.r / 3);
      ctx.stroke();
    }
  }

  function drawSpark() {
    const sp = characters.spark;
    // glow
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,214,107,0.28)`;
    ctx.arc(sp.x, sp.y, sp.radius + 12, 0, Math.PI * 2);
    ctx.fill();
    // body
    ctx.beginPath();
    ctx.fillStyle = sp.color;
    ctx.arc(sp.x, sp.y, sp.radius, 0, Math.PI * 2);
    ctx.fill();
    // eyes
    ctx.fillStyle = "#2B2D42";
    ctx.beginPath();
    ctx.arc(sp.x - 6, sp.y - 4, 3, 0, Math.PI * 2);
    ctx.arc(sp.x + 6, sp.y - 4, 3, 0, Math.PI * 2);
    ctx.fill();
    // tiny tail spark
    ctx.beginPath();
    ctx.fillStyle = "#FFD66B";
    ctx.ellipse(sp.x - sp.radius - 6, sp.y + 6, 6, 3, Math.PI / 6, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawHUD() {
    // Top panel with target, sum, lives, score, controls
    ctx.save();
    ctx.fillStyle = "rgba(16,40,39,0.6)";
    roundRect(ctx, 10, 8, WIDTH - 20, 56, 10, true, false);
    // Target
    ctx.fillStyle = "#FFFFFF";
    ctx.font = "20px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Target: ${targetValue}`, 30, 36);
    // Current sum
    ctx.fillStyle = "#FFF7C6";
    ctx.fillText(`Collected: ${collectedSum}`, 170, 36);
    // Lives
    ctx.fillStyle = "#FFCDD2";
    ctx.fillText(`Lives: ${lives}`, 340, 36);
    // Score
    ctx.fillStyle = "#BEE7A5";
    ctx.fillText(`Score: ${score}`, 440, 36);
    // Level
    ctx.fillStyle = "#CDE7FF";
    ctx.fillText(`Level: ${level}`, 550, 36);

    // Controls hint
    ctx.font = "13px sans-serif";
    ctx.fillStyle = "#DDEFF3";
    ctx.fillText(`Move: Arrow keys / WASD or touch-drag. M toggles sound. Enter to start.`, 30, 52);

    // Audio icon
    drawAudioIcon(WIDTH - 54, 34, audioAvailable && !audioMuted);
    ctx.restore();

    // If flash (error), draw overlay
    if (flashTimer > 0) {
      ctx.save();
      const alpha = Math.min(0.6, flashTimer / 0.8);
      ctx.fillStyle = `rgba(255, 80, 80, ${alpha})`;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.restore();
    }
  }

  function drawAudioIcon(x, y, on) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = on ? "#BFFCC6" : "#666";
    ctx.beginPath();
    ctx.rect(-10, -8, 6, 16);
    ctx.fill();
    // speaker cone
    ctx.beginPath();
    ctx.moveTo(-4, -8);
    ctx.lineTo(6, -14);
    ctx.lineTo(6, 14);
    ctx.lineTo(-4, 8);
    ctx.closePath();
    ctx.fill();
    if (on) {
      ctx.beginPath();
      ctx.strokeStyle = "#BFFCC6";
      ctx.lineWidth = 2;
      ctx.arc(10, 0, 8, -0.6, 0.6);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.strokeStyle = "#FF9AA2";
      ctx.lineWidth = 3;
      ctx.moveTo(10, -8);
      ctx.lineTo(-14, 14);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawStartScreen() {
    clear();
    drawBackground();
    // Big title and instructions
    ctx.save();
    ctx.fillStyle = "#FFF8D8";
    ctx.font = "36px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Spark's Circuit Quest", WIDTH / 2, 140);

    ctx.font = "18px sans-serif";
    ctx.fillStyle = "#DDEFF3";
    ctx.fillText("Help Spark the electron power wacky bulbs!", WIDTH / 2, 180);

    // Draw Professor and Bulb as intro characters
    drawCharacters();

    // Short instructions list
    ctx.font = "16px sans-serif";
    ctx.textAlign = "left";
    const lines = [
      "How to play:",
      " - Move Spark with arrow keys or WASD, or touch-drag on the screen.",
      " - Collect numbered orbs. Their numbers add up.",
      " - Match the bulb's target power exactly to light it!",
      " - If you go over, the circuit overloads and you lose a life.",
      " - Press M to toggle sound. Press Enter or click to start.",
    ];
    let y = 260;
    for (const line of lines) {
      ctx.fillStyle = "#EAF7F3";
      ctx.fillText(line, 80, y);
      y += 22;
    }

    // friendly spark illustration
    const spX = WIDTH / 2;
    const spY = HEIGHT - 120;
    ctx.beginPath();
    ctx.fillStyle = "#FFD66B";
    ctx.arc(spX, spY, 34, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#2B2D42";
    ctx.font = "18px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Spark", spX, spY + 6);
    ctx.restore();
  }

  function drawGameOver() {
    clear();
    drawBackground();
    drawOrbs();
    drawSpark();
    drawCharacters();
    drawHUD();

    ctx.save();
    ctx.fillStyle = "rgba(8, 10, 12, 0.6)";
    roundRect(ctx, WIDTH / 2 - 220, HEIGHT / 2 - 80, 440, 160, 12, true, false);
    ctx.fillStyle = "#FFF8D8";
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Circuit Overloaded!", WIDTH / 2, HEIGHT / 2 - 18);
    ctx.font = "18px sans-serif";
    ctx.fillStyle = "#EAF7F3";
    ctx.fillText(`Your score: ${score}`, WIDTH / 2, HEIGHT / 2 + 8);
    ctx.fillText("Press Enter or click to play again.", WIDTH / 2, HEIGHT / 2 + 42);
    ctx.restore();
  }

  // ------------- Main Render Loop ----------------
  function render(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = Math.min(0.06, (timestamp - lastTime) / 1000);
    lastTime = timestamp;

    // Update
    update(dt);

    // Draw
    if (phase === "start") {
      drawStartScreen();
    } else if (phase === "gameover") {
      drawGameOver();
    } else {
      clear();
      drawBackground();
      drawOrbs();
      drawSpark();
      drawCharacters();
      drawHUD();

      // Draw instructions small text or status
      if (audioAvailable === false) {
        ctx.save();
        ctx.fillStyle = "#FFCCB3";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "right";
        ctx.fillText("Audio unavailable on this device.", WIDTH - 16, HEIGHT - 14);
        ctx.restore();
      }

      if (phase === "success") {
        ctx.save();
        ctx.fillStyle = "rgba(200,255,200,0.14)";
        roundRect(ctx, WIDTH / 2 - 180, HEIGHT / 2 - 60, 360, 120, 12, true, false);
        ctx.fillStyle = "#F3FFE9";
        ctx.font = "24px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Level complete! Charging next circuit...", WIDTH / 2, HEIGHT / 2);
        ctx.restore();
      }
    }

    // Next frame
    if (running) requestAnimationFrame(render);
  }

  // ------------- Start and Initialization ----------------
  function init() {
    spawnParticles();
    generateOrbs(6);
    updateAria();

    // try resume audio on first user click
    canvas.addEventListener("click", tryResumeAudio, { once: true });
    canvas.addEventListener("keydown", tryResumeAudio, { once: true });

    // Start drawing loop
    running = true;
    lastTime = performance.now();
    requestAnimationFrame(render);
  }

  // Start on initialization
  init();

  // Start screen set
  phase = "start";

  // expose pause/resume for accessibility or debugging via console
  window.sparkCircuit = {
    pause() {
      running = false;
    },
    resume() {
      if (!running) {
        running = true;
        lastTime = performance.now();
        requestAnimationFrame(render);
      }
    },
    toggleAudio() {
      audioMuted = !audioMuted;
      if (bgGain) bgGain.gain.value = audioMuted ? 0 : 0.02;
    },
  };

  // Provide small friendly messages into aria-label periodically
  setInterval(() => {
    updateAria();
  }, 2500);

  // -------------------- End --------------------
})();
---

