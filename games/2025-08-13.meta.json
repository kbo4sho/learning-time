{
  "generated_date": "2025-08-13",
  "generated_timestamp": "2025-08-13T00:22:34.489774",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 11008,
  "game_filename": "2025-08-13.js",
  "game_size_bytes": 30855,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Electricity-themed Math Game for ages 7-9\n// Renders into element with id \"game-of-the-day-stage\"\n// All graphics drawn on a 720x480 canvas; sounds via Web Audio API\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const CANVAS_ID = 'game-of-the-day-canvas';\n  const CONTAINER_ID = 'game-of-the-day-stage';\n  const TILE_W = 80;\n  const TILE_H = 56;\n  const TILE_GAP = 14;\n\n  // Game state\n  let canvas, ctx, container;\n  let audioCtx = null;\n  let audioAllowed = true;\n  let audioReady = false;\n  let backgroundGain = null;\n  let audioError = null;\n\n  let tiles = []; // Array of number tiles\n  let bulbs = []; // Bulb targets\n  let heldTile = null; // tile id being dragged or keyboard-held\n  let pointer = { x: 0, y: 0, isDown: false };\n  let focus = { type: 'tile', index: 0 }; // keyboard focus: type 'tile' or 'bulb'\n  let confettiParticles = [];\n  let allLit = false;\n  let showCelebration = 0;\n\n  // Visual theme characters\n  const characters = [\n    { name: 'Sparky', color: '#ffcc33', mouth: 1 },\n    { name: 'Glim', color: '#66ccff', mouth: 0 },\n    { name: 'Boltina', color: '#ff99cc', mouth: 2 },\n  ];\n\n  // Initialize\n  init();\n\n  // -------------------------\n  // Initialization functions\n  // -------------------------\n  function init() {\n    try {\n      container = document.getElementById(CONTAINER_ID);\n    } catch (e) {\n      container = null;\n    }\n    if (!container) {\n      console.error(\n        `Container element with id \"${CONTAINER_ID}\" not found. Creating fallback container appended to body.`\n      );\n      container = document.createElement('div');\n      container.id = CONTAINER_ID;\n      document.body.appendChild(container);\n    }\n\n    // Clear container and create canvas\n    container.innerHTML = '';\n    canvas = document.createElement('canvas');\n    canvas.id = CANVAS_ID;\n    canvas.width = WIDTH;\n    canvas.height = HEIGHT;\n    // Make canvas focusable for keyboard controls and accessible\n    canvas.setAttribute('tabindex', '0');\n    canvas.setAttribute(\n      'aria-label',\n      'Spark Workshop math game. Use mouse or keyboard to drag number tiles to bulbs to match target energy. Press A to toggle audio. Press R to reset.'\n    );\n    canvas.style.outline = 'none';\n    container.appendChild(canvas);\n\n    ctx = canvas.getContext('2d');\n\n    // Event listeners\n    canvas.addEventListener('mousedown', onPointerDown);\n    window.addEventListener('mousemove', onPointerMove);\n    window.addEventListener('mouseup', onPointerUp);\n    canvas.addEventListener('touchstart', onTouchDown, { passive: false });\n    canvas.addEventListener('touchmove', onTouchMove, { passive: false });\n    window.addEventListener('touchend', onTouchUp, { passive: false });\n    canvas.addEventListener('keydown', onKeyDown);\n    canvas.addEventListener('focus', () => draw()); // redraw focus visuals\n\n    canvas.addEventListener('click', (e) => {\n      // If clicking the speaker icon toggle audio\n      const rect = canvas.getBoundingClientRect();\n      const cx = e.clientX - rect.left;\n      const cy = e.clientY - rect.top;\n      if (isPointInSpeaker(cx, cy)) {\n        toggleAudio();\n      }\n    });\n\n    // Initialize audio\n    try {\n      audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      audioReady = true;\n      setupBackgroundHum();\n    } catch (err) {\n      audioError = err;\n      audioReady = false;\n      audioAllowed = false;\n      console.warn('Audio not available:', err);\n    }\n\n    // Start new puzzle\n    resetGame();\n\n    // Kick off animation loop\n    requestAnimationFrame(loop);\n  }\n\n  // -------------------------\n  // Game setup and reset\n  // -------------------------\n  function resetGame() {\n    // Prepare three bulbs (left to right)\n    bulbs = [];\n    const bulbXs = [140, 360, 580];\n    for (let i = 0; i < 3; i++) {\n      bulbs.push({\n        id: i,\n        x: bulbXs[i],\n        y: 130,\n        r: 64,\n        target: 0,\n        sum: 0,\n        lit: false,\n        glow: 0,\n      });\n    }\n\n    // Generate targets and tiles in a solvable way\n    // For each bulb, choose a target between 5 and 12\n    let requiredTiles = [];\n    for (let i = 0; i < 3; i++) {\n      const target = randInt(5, 12);\n      bulbs[i].target = target;\n      bulbs[i].sum = 0;\n      bulbs[i].lit = false;\n\n      // split target into 1-3 parts to create tiles that satisfy it\n      const parts = randInt(1, 3);\n      let partsArr = [];\n      let remaining = target;\n      for (let p = parts; p > 1; p--) {\n        const part = randInt(1, Math.max(1, remaining - (p - 1)));\n        partsArr.push(part);\n        remaining -= part;\n      }\n      partsArr.push(remaining);\n      // shuffle parts\n      shuffleArray(partsArr);\n      partsArr.forEach((v) => {\n        requiredTiles.push({ value: v, bulbId: i });\n      });\n    }\n\n    // Add distractor tiles to make a total of 6 tiles\n    tiles = [];\n    const totalNeeded = Math.max(6, requiredTiles.length);\n    // Put required tiles first\n    requiredTiles.forEach((rt, idx) => {\n      tiles.push({\n        id: idx,\n        value: rt.value,\n        homeIndex: idx,\n        assignedBulb: rt.bulbId, // not shown to player\n        x: 120 + (idx % 6) * (TILE_W + TILE_GAP),\n        y: 340 + Math.floor(idx / 6) * (TILE_H + 10),\n        w: TILE_W,\n        h: TILE_H,\n        picked: false,\n      });\n    });\n\n    let idxCounter = requiredTiles.length;\n    while (tiles.length < totalNeeded) {\n      tiles.push({\n        id: idxCounter,\n        value: randInt(1, 9),\n        homeIndex: idxCounter,\n        assignedBulb: null,\n        x: 120 + (idxCounter % 6) * (TILE_W + TILE_GAP),\n        y: 340 + Math.floor(idxCounter / 6) * (TILE_H + 10),\n        w: TILE_W,\n        h: TILE_H,\n        picked: false,\n      });\n      idxCounter++;\n    }\n\n    // Shuffle tiles' screen positions but keep values\n    shuffleArray(tiles);\n    // Assign positions nicely across the bottom row\n    const startX = (WIDTH - (tiles.length * TILE_W + (tiles.length - 1) * TILE_GAP)) / 2;\n    tiles.forEach((t, i) => {\n      t.x = startX + i * (TILE_W + TILE_GAP);\n      t.y = HEIGHT - TILE_H - 30;\n    });\n\n    heldTile = null;\n    focus = { type: 'tile', index: Math.max(0, Math.min(tiles.length - 1, focus.index || 0)) };\n    confettiParticles = [];\n    allLit = false;\n    showCelebration = 0;\n    draw();\n  }\n\n  // -------------------------\n  // Main loop and drawing\n  // -------------------------\n  function loop(timestamp) {\n    update();\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  function update() {\n    // Update bulb glow animation\n    bulbs.forEach((b) => {\n      if (b.lit) {\n        b.glow = Math.min(1, b.glow + 0.02);\n      } else {\n        b.glow = Math.max(0, b.glow - 0.03);\n      }\n    });\n\n    // Update confetti\n    if (showCelebration > 0) {\n      showCelebration -= 1;\n    }\n    confettiParticles.forEach((p) => {\n      p.vy += 0.15;\n      p.x += p.vx;\n      p.y += p.vy;\n      p.rot += p.vr;\n      p.life -= 1;\n    });\n    confettiParticles = confettiParticles.filter((p) => p.life > 0);\n\n    // Check if all bulbs lit\n    if (!allLit && bulbs.every((b) => b.lit)) {\n      allLit = true;\n      doCelebration();\n    }\n  }\n\n  function draw() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Background gradient\n    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    grad.addColorStop(0, '#0f1724');\n    grad.addColorStop(1, '#03263a');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Wacky glowing power plant silhouette\n    drawPowerPlant();\n\n    // Draw bulbs and characters\n    drawBulbs();\n\n    // Draw tiles\n    drawTiles();\n\n    // Draw battery centerpiece with character\n    drawBattery();\n\n    // Draw instructions and UI\n    drawUI();\n\n    // Draw confetti if any\n    drawConfetti();\n\n    // If audio unavailable, draw warning\n    if (!audioReady) {\n      drawAudioUnavailable();\n    }\n  }\n\n  // -------------------------\n  // Drawing subroutines\n  // -------------------------\n  function drawPowerPlant() {\n    // ground platform\n    roundRect(ctx, 40, 220, WIDTH - 80, 200, 10, '#083249');\n    ctx.fillStyle = 'rgba(255,255,255,0.03)';\n    ctx.fillRect(60, 250, WIDTH - 120, 140);\n\n    // Add silly bolts and doodles\n    for (let i = 0; i < 6; i++) {\n      const x = 80 + i * 110;\n      const y = 280 + ((i % 2) * 12);\n      drawBolt(x, y, '#88ddff', 1.8);\n    }\n  }\n\n  function drawBulbs() {\n    bulbs.forEach((b, i) => {\n      // base shadow\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(0,0,0,0.25)';\n      ctx.ellipse(b.x, b.y + b.r + 10, b.r * 0.9, 12, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // bulb glass\n      const g = ctx.createRadialGradient(b.x - b.r * 0.3, b.y - b.r * 0.5, 10, b.x, b.y, b.r * 1.2);\n      if (b.lit) {\n        g.addColorStop(0, `rgba(255,255,160,${0.9 * b.glow})`);\n        g.addColorStop(1, 'rgba(255,210,120,0.06)');\n      } else {\n        g.addColorStop(0, 'rgba(220,240,255,0.06)');\n        g.addColorStop(1, 'rgba(180,200,220,0.02)');\n      }\n      ctx.beginPath();\n      ctx.fillStyle = g;\n      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);\n      ctx.fill();\n\n      // filament (wacky)\n      ctx.save();\n      ctx.translate(b.x, b.y);\n      ctx.rotate((i * 0.3) - 0.4);\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = b.lit ? `rgba(255,220,90,${0.6 + 0.4 * b.glow})` : '#b8c6d0';\n      ctx.beginPath();\n      ctx.moveTo(-10, 6);\n      ctx.quadraticCurveTo(0, -15, 14, 6);\n      ctx.stroke();\n      ctx.restore();\n\n      // bulb rim\n      ctx.beginPath();\n      ctx.lineWidth = 6;\n      ctx.strokeStyle = 'rgba(255,255,255,0.08)';\n      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);\n      ctx.stroke();\n\n      // base (metal part)\n      roundRect(ctx, b.x - 34, b.y + b.r - 10, 68, 28, 6, '#868686');\n      roundRect(ctx, b.x - 24, b.y + b.r + 18, 48, 10, 3, '#5a5a5a');\n\n      // target and sum text\n      ctx.font = '20px Comic Sans MS, sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillStyle = '#fff';\n      ctx.globalAlpha = 0.95;\n      ctx.fillText(`Need: ${b.target}`, b.x, b.y - b.r - 14);\n\n      // drawn meter showing current sum\n      const meterW = 120;\n      const meterH = 12;\n      const mx = b.x - meterW / 2;\n      const my = b.y + b.r + 40;\n      ctx.globalAlpha = 0.8;\n      roundRect(ctx, mx, my, meterW, meterH, 8, '#1b3b4b');\n      const ratio = Math.min(1, b.sum / b.target);\n      roundRect(ctx, mx + 2, my + 2, (meterW - 4) * ratio, meterH - 4, 6, b.lit ? '#ffeb80' : '#6fb2d4');\n\n      // sum number\n      ctx.globalAlpha = 1;\n      ctx.font = '18px sans-serif';\n      ctx.fillStyle = '#fff';\n      ctx.fillText(`Sum: ${b.sum}`, b.x, my + meterH + 18);\n\n      // If focused via keyboard show outline\n      if (focus.type === 'bulb' && focus.index === i && canvas === document.activeElement) {\n        ctx.beginPath();\n        ctx.lineWidth = 3;\n        ctx.strokeStyle = '#ffeaa7';\n        ctx.arc(b.x, b.y, b.r + 6, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    });\n    ctx.globalAlpha = 1;\n  }\n\n  function drawTiles() {\n    tiles.forEach((t, i) => {\n      // tile shadow\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(0,0,0,0.2)';\n      ctx.roundRect = ctx.roundRect || roundRect;\n      roundRect(ctx, t.x + 4, t.y + 6, t.w, t.h, 10, 'rgba(0,0,0,0.15)');\n\n      // tile background\n      const isHeld = heldTile === t.id || t.picked;\n      const bg = isHeld ? '#ffd57a' : '#fff';\n      const border = '#3b3b3b';\n      roundRect(ctx, t.x, t.y, t.w, t.h, 12, bg);\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = border;\n      ctx.strokeRect(t.x + 0.5, t.y + 0.5, t.w - 1, t.h - 1);\n\n      // number text\n      ctx.fillStyle = '#2b2b2b';\n      ctx.font = '28px Comic Sans MS, sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(String(t.value), t.x + t.w / 2, t.y + t.h / 2 + 10);\n\n      // Focus ring for keyboard focus\n      if (focus.type === 'tile' && focus.index === i && canvas === document.activeElement) {\n        ctx.beginPath();\n        ctx.lineWidth = 3;\n        ctx.strokeStyle = '#86f3ff';\n        roundRect(ctx, t.x - 6, t.y - 6, t.w + 12, t.h + 12, 16, 'transparent');\n        ctx.stroke();\n      }\n    });\n\n    // If dragging with mouse, draw held tile following pointer\n    if (pointer.isDown && heldTile !== null) {\n      const t = findTileById(heldTile);\n      if (t) {\n        ctx.save();\n        ctx.globalAlpha = 0.95;\n        const px = pointer.x - t.w / 2;\n        const py = pointer.y - t.h / 2;\n        roundRect(ctx, px, py, t.w, t.h, 12, '#ffeaa7');\n        ctx.lineWidth = 3;\n        ctx.strokeStyle = '#3b3b3b';\n        ctx.strokeRect(px + 0.5, py + 0.5, t.w - 1, t.h - 1);\n        ctx.fillStyle = '#2b2b2b';\n        ctx.font = '28px Comic Sans MS, sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText(String(t.value), px + t.w / 2, py + t.h / 2 + 10);\n        ctx.restore();\n      }\n    }\n  }\n\n  function drawBattery() {\n    // center battery with character\n    const bx = WIDTH / 2;\n    const by = 240;\n    // battery body\n    roundRect(ctx, bx - 80, by - 30, 160, 80, 14, '#263238');\n    roundRect(ctx, bx - 70, by - 24, 140, 68, 10, '#375661');\n    // battery top indicator\n    roundRect(ctx, bx - 40, by - 48, 80, 18, 8, '#f6d365');\n    // little face of character\n    const char = characters[0];\n    ctx.beginPath();\n    ctx.fillStyle = char.color;\n    ctx.arc(bx, by + 6, 28, 0, Math.PI * 2);\n    ctx.fill();\n    // eyes\n    ctx.fillStyle = '#111';\n    ctx.beginPath();\n    ctx.arc(bx - 10, by + 2, 3.8, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(bx + 10, by + 2, 3.8, 0, Math.PI * 2);\n    ctx.fill();\n    // smile\n    ctx.beginPath();\n    ctx.strokeStyle = '#111';\n    ctx.lineWidth = 2;\n    ctx.arc(bx, by + 8, 10, 0, Math.PI, false);\n    ctx.stroke();\n\n    // Circuit wires between battery and bulbs\n    bulbs.forEach((b, i) => {\n      const sx = bx;\n      const sy = by - 18;\n      const ex = b.x;\n      const ey = b.y + b.r + 14;\n\n      // wavy wire\n      ctx.beginPath();\n      ctx.lineWidth = 6;\n      ctx.lineCap = 'round';\n      const grad = ctx.createLinearGradient(sx, sy, ex, ey);\n      grad.addColorStop(0, '#ffefc0');\n      grad.addColorStop(1, '#9be7ff');\n      ctx.strokeStyle = grad;\n      const midx = (sx + ex) / 2 + Math.sin(performance.now() / 400 + i) * 6;\n      ctx.moveTo(sx, sy);\n      ctx.quadraticCurveTo(midx, (sy + ey) / 2 + 10, ex, ey);\n      ctx.stroke();\n\n      // tiny spark traveling when lit\n      if (b.lit) {\n        const t = (performance.now() / 350) % 1;\n        const ax = quadraticPoint(sx, sy, midx, (sy + ey) / 2 + 10, ex, ey, t);\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(255,230,120,0.95)';\n        ctx.arc(ax.x, ax.y, 8 + Math.sin(performance.now() / 120) * 2, 0, Math.PI * 2);\n        ctx.fill();\n        // glow\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(255,230,120,0.18)';\n        ctx.arc(ax.x, ax.y, 20, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    });\n\n    // small label\n    ctx.font = '16px sans-serif';\n    ctx.fillStyle = '#fff';\n    ctx.textAlign = 'center';\n    ctx.fillText('Battery: Feed the bulbs with number tiles!', bx, by + 58);\n  }\n\n  function drawUI() {\n    // Title\n    ctx.font = '28px \"Comic Sans MS\", sans-serif';\n    ctx.fillStyle = '#fff';\n    ctx.textAlign = 'left';\n    ctx.fillText('Spark Workshop \u2014 Match each bulb to its needed energy', 18, 36);\n\n    // Instructions box\n    const instructions = [\n      'Drag number tiles to bulbs to make the bulb reach its target number.',\n      'You can also use the keyboard:',\n      '  - Tab / Left-Right to move focus between tiles/bulbs.',\n      '  - Space or Enter to pick up / drop a tile.',\n      '  - A to toggle audio, R to reset.',\n    ];\n    ctx.font = '14px sans-serif';\n    ctx.fillStyle = '#dbeeff';\n    let y = 60;\n    instructions.forEach((line) => {\n      ctx.fillText(line, 18, y);\n      y += 18;\n    });\n\n    // Draw audio speaker icon with on/off\n    drawSpeakerIcon(WIDTH - 60, 36, audioReady && audioAllowed);\n\n    // If there is a tile held by keyboard, show hint\n    if (heldTile !== null && !pointer.isDown) {\n      const t = findTileById(heldTile);\n      if (t) {\n        ctx.font = '13px sans-serif';\n        ctx.fillStyle = '#fff';\n        ctx.fillText(`Holding tile ${t.value} \u2014 move focus to a bulb and press Enter to drop`, 18, HEIGHT - 14);\n      }\n    }\n  }\n\n  function drawConfetti() {\n    confettiParticles.forEach((p) => {\n      ctx.save();\n      ctx.translate(p.x, p.y);\n      ctx.rotate(p.rot);\n      ctx.fillStyle = p.color;\n      ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);\n      ctx.restore();\n    });\n\n    if (allLit) {\n      ctx.font = '36px \"Comic Sans MS\", sans-serif';\n      ctx.fillStyle = '#ffd27f';\n      ctx.textAlign = 'center';\n      ctx.fillText('All bulbs glowing! Great job!', WIDTH / 2, 220);\n\n      // Draw celebratory waves\n      for (let i = 0; i < 3; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = `rgba(255,255,150,${0.12 + 0.06 * i})`;\n        ctx.lineWidth = 8 - i * 2;\n        ctx.arc(WIDTH / 2, 230, 90 + i * 26 + Math.sin(performance.now() / 400) * 6, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    }\n  }\n\n  function drawAudioUnavailable() {\n    ctx.font = '14px sans-serif';\n    ctx.fillStyle = '#ffcccc';\n    ctx.textAlign = 'right';\n    const msg = 'Audio unavailable';\n    ctx.fillText(msg, WIDTH - 18, HEIGHT - 14);\n  }\n\n  // -------------------------\n  // Interaction Handlers\n  // -------------------------\n  function onPointerDown(e) {\n    const rect = canvas.getBoundingClientRect();\n    pointer.isDown = true;\n    pointer.x = e.clientX - rect.left;\n    pointer.y = e.clientY - rect.top;\n\n    // Check tiles first\n    const t = tileAt(pointer.x, pointer.y);\n    if (t) {\n      heldTile = t.id;\n      t.picked = true;\n      playClick();\n      return;\n    }\n\n    // Check if clicked a bulb to drop (if holding via keyboard)\n    const b = bulbAt(pointer.x, pointer.y);\n    if (b && heldTile !== null) {\n      dropTileOnBulb(heldTile, b.id);\n      playDrop();\n      return;\n    }\n  }\n\n  function onPointerMove(e) {\n    const rect = canvas.getBoundingClientRect();\n    pointer.x = e.clientX - rect.left;\n    pointer.y = e.clientY - rect.top;\n  }\n\n  function onPointerUp(e) {\n    if (!pointer.isDown) return;\n    pointer.isDown = false;\n    const rect = canvas.getBoundingClientRect();\n    pointer.x = e.clientX - rect.left;\n    pointer.y = e.clientY - rect.top;\n\n    if (heldTile !== null) {\n      const b = bulbAt(pointer.x, pointer.y);\n      if (b) {\n        dropTileOnBulb(heldTile, b.id);\n      } else {\n        // Return tile home\n        const t = findTileById(heldTile);\n        if (t) {\n          t.picked = false;\n        }\n      }\n      heldTile = null;\n    }\n  }\n\n  function onTouchDown(e) {\n    e.preventDefault();\n    if (e.touches && e.touches.length) {\n      const rect = canvas.getBoundingClientRect();\n      pointer.isDown = true;\n      pointer.x = e.touches[0].clientX - rect.left;\n      pointer.y = e.touches[0].clientY - rect.top;\n\n      const t = tileAt(pointer.x, pointer.y);\n      if (t) {\n        heldTile = t.id;\n        t.picked = true;\n        playClick();\n      }\n    }\n  }\n\n  function onTouchMove(e) {\n    e.preventDefault();\n    if (e.touches && e.touches.length) {\n      const rect = canvas.getBoundingClientRect();\n      pointer.x = e.touches[0].clientX - rect.left;\n      pointer.y = e.touches[0].clientY - rect.top;\n    }\n  }\n\n  function onTouchUp(e) {\n    e.preventDefault();\n    if (!pointer.isDown) return;\n    pointer.isDown = false;\n    if (heldTile !== null) {\n      const b = bulbAt(pointer.x, pointer.y);\n      if (b) {\n        dropTileOnBulb(heldTile, b.id);\n      } else {\n        const t = findTileById(heldTile);\n        if (t) t.picked = false;\n      }\n      heldTile = null;\n    }\n  }\n\n  function onKeyDown(e) {\n    // Ensure canvas focus for keyboard control\n    if (e.key === 'Tab') {\n      e.preventDefault();\n      // cycle focus: tile -> bulb -> tile...\n      if (focus.type === 'tile') {\n        focus.type = 'bulb';\n        focus.index = 0;\n      } else {\n        focus.type = 'tile';\n        focus.index = 0;\n      }\n      draw();\n      return;\n    }\n\n    if (e.key === 'ArrowLeft' || e.key === 'Left') {\n      e.preventDefault();\n      if (focus.type === 'tile') {\n        focus.index = (focus.index - 1 + tiles.length) % tiles.length;\n      } else {\n        focus.index = (focus.index - 1 + bulbs.length) % bulbs.length;\n      }\n      draw();\n      return;\n    }\n    if (e.key === 'ArrowRight' || e.key === 'Right') {\n      e.preventDefault();\n      if (focus.type === 'tile') {\n        focus.index = (focus.index + 1) % tiles.length;\n      } else {\n        focus.index = (focus.index + 1) % bulbs.length;\n      }\n      draw();\n      return;\n    }\n\n    if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {\n      e.preventDefault();\n      // Pick up or drop\n      if (heldTile === null && focus.type === 'tile') {\n        // pick tile\n        const t = tiles[focus.index];\n        heldTile = t.id;\n        t.picked = true;\n        playClick();\n      } else if (heldTile !== null && focus.type === 'bulb') {\n        const b = bulbs[focus.index];\n        dropTileOnBulb(heldTile, b.id);\n        heldTile = null;\n      } else if (heldTile !== null && focus.type === 'tile') {\n        // If pressing Enter while holding and focus on tile, drop it back home\n        const t = findTileById(heldTile);\n        if (t) {\n          t.picked = false;\n        }\n        heldTile = null;\n      }\n      draw();\n      return;\n    }\n\n    if (e.key.toLowerCase() === 'a') {\n      e.preventDefault();\n      toggleAudio();\n      return;\n    }\n\n    if (e.key.toLowerCase() === 'r') {\n      e.preventDefault();\n      resetGame();\n      return;\n    }\n  }\n\n  // -------------------------\n  // Game logic\n  // -------------------------\n  function dropTileOnBulb(tileId, bulbId) {\n    const tile = findTileById(tileId);\n    const bulb = bulbs.find((b) => b.id === bulbId);\n    if (!tile || !bulb) return;\n\n    // attempt to add tile.value to bulb sum\n    const newSum = bulb.sum + tile.value;\n    if (newSum > bulb.target) {\n      // wrong: overcharged\n      playWrong();\n      // visual shake or bounce - indicate by briefly moving tile\n      tile.picked = false;\n      // quick flash effect on bulb\n      bulb.glow = Math.min(1, bulb.glow + 0.6);\n      return;\n    } else {\n      // Success: attach tile, increase bulb sum\n      bulb.sum = newSum;\n      tile.picked = false;\n      // remove tile from list (so it can't be used again)\n      const idx = tiles.findIndex((t) => t.id === tile.id);\n      if (idx >= 0) {\n        // animate tile removed - for simplicity remove instantly\n        tiles.splice(idx, 1);\n        // adjust focus index\n        if (focus.type === 'tile') {\n          focus.index = Math.max(0, Math.min(tiles.length - 1, focus.index));\n        }\n      }\n      playCorrect();\n      // if exactly meets target, light bulb\n      if (bulb.sum === bulb.target) {\n        bulb.lit = true;\n        spawnFriendlySpark(bulb.x, bulb.y);\n      }\n    }\n  }\n\n  function spawnFriendlySpark(x, y) {\n    // small sparkle particles\n    for (let i = 0; i < 12; i++) {\n      confettiParticles.push({\n        x: x + randInt(-8, 8),\n        y: y + randInt(-8, 8),\n        vx: randFloat(-2, 2),\n        vy: randFloat(-3, -1),\n        size: randInt(4, 9),\n        rot: 0,\n        vr: randFloat(-0.2, 0.2),\n        life: randInt(30, 70),\n        color: randChoice(['#ffdf7a', '#ffd7a8', '#ffd1ff', '#b3f0ff']),\n      });\n    }\n  }\n\n  function doCelebration() {\n    // Big confetti\n    for (let i = 0; i < 80; i++) {\n      confettiParticles.push({\n        x: randFloat(80, WIDTH - 80),\n        y: randFloat(-20, 40),\n        vx: randFloat(-2.5, 2.5),\n        vy: randFloat(0.5, 3.0),\n        size: randInt(6, 12),\n        rot: randFloat(0, Math.PI),\n        vr: randFloat(-0.1, 0.1),\n        life: randInt(100, 240),\n        color: randChoice(['#ffdf7a', '#ffd7a8', '#ffd1ff', '#b3f0ff', '#a8f4b3', '#ffd0d0']),\n      });\n    }\n    showCelebration = 200;\n    playVictory();\n  }\n\n  // -------------------------\n  // Audio functions (Web Audio API)\n  // -------------------------\n  function setupBackgroundHum() {\n    if (!audioReady) return;\n    try {\n      // Create a gentle background hum (low-frequency oscillator)\n      const osc = audioCtx.createOscillator();\n      osc.type = 'sine';\n      osc.frequency.value = 60; // low hum\n      backgroundGain = audioCtx.createGain();\n      backgroundGain.gain.value = 0.0019; // very gentle\n      const biquad = audioCtx.createBiquadFilter();\n      biquad.type = 'lowpass';\n      biquad.frequency.value = 300;\n\n      osc.connect(biquad);\n      biquad.connect(backgroundGain);\n      backgroundGain.connect(audioCtx.destination);\n      osc.start();\n    } catch (err) {\n      console.warn('Error setting up background hum:', err);\n      audioReady = false;\n      audioError = err;\n    }\n  }\n\n  function toggleAudio() {\n    if (!audioReady) {\n      try {\n        audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n        audioReady = true;\n        setupBackgroundHum();\n      } catch (err) {\n        audioError = err;\n        audioReady = false;\n        alert('Audio cannot be enabled on this device or browser.');\n        return;\n      }\n    }\n    audioAllowed = !audioAllowed;\n    if (backgroundGain) {\n      backgroundGain.gain.value = audioAllowed ? 0.0019 : 0;\n    }\n    if (audioAllowed) {\n      playClick();\n    }\n  }\n\n  function playTone(freq, type = 'sine', dur = 0.18, volume = 0.08) {\n    if (!audioReady || !audioAllowed) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = Math.max(500, freq * 4);\n\n      osc.type = type;\n      osc.frequency.value = freq;\n      gain.gain.setValueAtTime(volume, now);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioCtx.destination);\n\n      osc.start(now);\n      osc.stop(now + dur + 0.02);\n    } catch (err) {\n      console.warn('playTone error', err);\n    }\n  }\n\n  function playClick() {\n    playTone(880, 'square', 0.08, 0.06);\n  }\n  function playCorrect() {\n    playTone(1100, 'sine', 0.15, 0.08);\n    setTimeout(() => playTone(1400, 'sine', 0.12, 0.06), 120);\n  }\n  function playWrong() {\n    playTone(220, 'sawtooth', 0.18, 0.08);\n  }\n  function playDrop() {\n    playTone(520, 'sine', 0.12, 0.05);\n  }\n  function playVictory() {\n    playTone(880, 'sine', 0.15, 0.09);\n    setTimeout(() => playTone(1040, 'sine', 0.14, 0.09), 160);\n    setTimeout(() => playTone(1240, 'sine', 0.14, 0.09), 320);\n  }\n\n  // -------------------------\n  // Utility helpers\n  // -------------------------\n  function tileAt(x, y) {\n    for (let i = tiles.length - 1; i >= 0; i--) {\n      const t = tiles[i];\n      if (x >= t.x && x <= t.x + t.w && y >= t.y && y <= t.y + t.h) {\n        return t;\n      }\n    }\n    return null;\n  }\n\n  function bulbAt(x, y) {\n    for (let i = 0; i < bulbs.length; i++) {\n      const b = bulbs[i];\n      const dx = x - b.x;\n      const dy = y - b.y;\n      if (dx * dx + dy * dy <= b.r * b.r) return b;\n    }\n    return null;\n  }\n\n  function findTileById(id) {\n    return tiles.find((t) => t.id === id) || null;\n  }\n\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function randFloat(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n  function randChoice(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n  }\n  function shuffleArray(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [a[i], a[j]] = [a[j], a[i]];\n    }\n  }\n\n  // Rounded rectangle helper\n  function roundRect(ctx, x, y, w, h, r, fillStyle) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillStyle && fillStyle !== 'transparent') {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n  }\n\n  // Quadratic bezier point helper for spark motion\n  function quadraticPoint(x0, y0, cx, cy, x1, y1, t) {\n    // two-phase quadratic: treat control as cx,cy then compute\n    const xa = x0 + (cx - x0) * t;\n    const ya = y0 + (cy - y0) * t;\n    const xb = cx + (x1 - cx) * t;\n    const yb = cy + (y1 - cy) * t;\n    return { x: xa + (xb - xa) * t, y: ya + (yb - ya) * t };\n  }\n\n  // Draw bolt doodle\n  function drawBolt(x, y, color, scale = 1) {\n    ctx.beginPath();\n    ctx.moveTo(x - 6 * scale, y - 12 * scale);\n    ctx.lineTo(x + 2 * scale, y - 2 * scale);\n    ctx.lineTo(x - 2 * scale, y - 2 * scale);\n    ctx.lineTo(x + 6 * scale, y + 12 * scale);\n    ctx.lineTo(x - 2 * scale, y + 2 * scale);\n    ctx.lineTo(x + 2 * scale, y + 2 * scale);\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n    ctx.stroke();\n  }\n\n  // Speaker icon region detection and drawing\n  function drawSpeakerIcon(cx, cy, on) {\n    // Draw simple speaker icon\n    const size = 20;\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.beginPath();\n    ctx.fillStyle = on ? '#9fffbf' : '#ff9f9f';\n    ctx.strokeStyle = 'rgba(0,0,0,0.15)';\n    roundRect(ctx, -size, -12, 18, 24, 4, '#24343a');\n    // speaker triangle\n    ctx.beginPath();\n    ctx.moveTo(-size + 6, -6);\n    ctx.lineTo(-size + 18, -16);\n    ctx.lineTo(-size + 18, 16);\n    ctx.closePath();\n    ctx.fillStyle = on ? '#fff' : '#fff';\n    ctx.fill();\n    // sound waves\n    if (on) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#cff7d8';\n      ctx.lineWidth = 2;\n      ctx.arc(size * 0.2, 0, 8, -0.6, 0.6);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = '#9fffbf';\n      ctx.lineWidth = 2;\n      ctx.arc(size * 0.2, 0, 12, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      // draw muted X\n      ctx.beginPath();\n      ctx.strokeStyle = '#ffb2b2';\n      ctx.lineWidth = 3;\n      ctx.moveTo(6, -8);\n      ctx.lineTo(14, 8);\n      ctx.moveTo(14, -8);\n      ctx.lineTo(6, 8);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function isPointInSpeaker(x, y) {\n    // approximate area near top-right where speaker is drawn\n    const sx = WIDTH - 60;\n    const sy = 36;\n    return x >= sx - 28 && x <= sx + 28 && y >= sy - 20 && y <= sy + 20;\n  }\n\n  // Canvas polyfill for roundRect stroke if missing\n  if (!CanvasRenderingContext2D.prototype.roundRect) {\n    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {\n      roundRect(this, x, y, w, h, r, 'transparent');\n    };\n  }\n})();\n---\n",
  "improve_response_tokens": 22178,
  "formatted_code": true,
  "formatting_response_tokens": 23757,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}