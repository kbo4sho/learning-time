# Game of the Day - 2025-08-07

## Metadata
- **Generated Date:** 2025-08-07
- **Generated Time:** 2025-08-07T22:27:24.355045
- **Model:** gpt-5
- **Theme:** open world exploration
- **Game File:** 2025-08-07.js
- **File Size:** 39676 bytes
- **Tokens Used:** 15732

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: open world exploration

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5 model with the theme: "open world exploration".

## Files Generated
- `2025-08-07.js` - The playable game
- `2025-08-07.meta.json` - Machine-readable metadata
- `2025-08-07.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 31996

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 34329

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  "use strict";

  // Constants
  const WIDTH = 720;
  const HEIGHT = 480;
  const WORLD_W = 1440;
  const WORLD_H = 960;
  const TARGET_STARS = 5;
  const PLAYER_SPEED = 2.5;
  const PLAYER_RADIUS = 14;
  const INTERACT_DIST = 34;
  const BG_COLOR = "#0b2540";
  const ISLAND_COLOR = "#133c55";
  const TEXT_COLOR = "#ffffff";

  // DOM setup
  const stage = document.getElementById("game-of-the-day-stage");
  if (!stage) {
    console.error("game-of-the-day-stage element not found.");
    return;
  }

  // Clear stage and set ARIA attributes
  stage.innerHTML = "";
  stage.setAttribute("role", "application");
  stage.setAttribute("aria-label", "Open world math exploration game for ages 7 to 9. Use arrow keys to move. Press Enter near a character to solve a friendly math riddle.");

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = "block";
  canvas.style.outline = "none";
  canvas.tabIndex = 0;
  stage.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // ARIA live region for announcements (hidden)
  const live = document.createElement("div");
  live.setAttribute("aria-live", "polite");
  live.style.position = "absolute";
  live.style.left = "-9999px";
  live.style.top = "-9999px";
  stage.appendChild(live);

  // Utility
  const rand = (min, max) => Math.random() * (max - min) + min;
  const randInt = (min, max) => Math.floor(rand(min, max + 1));
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const dist2 = (x1, y1, x2, y2) => {
    const dx = x2 - x1, dy = y2 - y1;
    return dx * dx + dy * dy;
  };

  // Audio system
  const Audio = {
    ctx: null,
    master: null,
    ambient: { noise: null, noiseGain: null, drone: null, droneGain: null, lfo: null, lfoGain: null },
    enabled: true,
    supported: true,
    started: false,
  };

  function initAudio() {
    if (Audio.ctx || !Audio.enabled) return;
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) {
        Audio.supported = false;
        return;
      }
      Audio.ctx = new Ctx();
      Audio.master = Audio.ctx.createGain();
      Audio.master.gain.value = 0.6;
      Audio.master.connect(Audio.ctx.destination);
      Audio.started = true;
      startAmbient();
    } catch (e) {
      console.warn("Audio init failed:", e);
      Audio.supported = false;
      Audio.enabled = false;
    }
  }

  function ensureAudioUnlocked() {
    if (!Audio.enabled || !Audio.supported) return;
    if (!Audio.ctx) {
      initAudio();
    }
    if (Audio.ctx && Audio.ctx.state === "suspended") {
      Audio.ctx.resume().catch(() => {});
    }
  }

  function startAmbient() {
    if (!Audio.ctx) return;
    // Gentle ocean-like noise
    const bufferSize = 2 * Audio.ctx.sampleRate;
    const noiseBuffer = Audio.ctx.createBuffer(1, bufferSize, Audio.ctx.sampleRate);
    const output = noiseBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      output[i] = (Math.random() * 2 - 1) * 0.3;
    }
    const noise = Audio.ctx.createBufferSource();
    noise.buffer = noiseBuffer;
    noise.loop = true;

    const filter = Audio.ctx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 800;

    const noiseGain = Audio.ctx.createGain();
    noiseGain.gain.value = 0.05;

    noise.connect(filter);
    filter.connect(noiseGain);
    noiseGain.connect(Audio.master);

    // Slow soothing drone with LFO tremolo
    const drone = Audio.ctx.createOscillator();
    drone.type = "sine";
    drone.frequency.value = 180;

    const droneGain = Audio.ctx.createGain();
    droneGain.gain.value = 0.02;

    const lfo = Audio.ctx.createOscillator();
    lfo.type = "sine";
    lfo.frequency.value = 0.1;

    const lfoGain = Audio.ctx.createGain();
    lfoGain.gain.value = 0.015;

    lfo.connect(lfoGain);
    lfoGain.connect(droneGain.gain);

    drone.connect(droneGain);
    droneGain.connect(Audio.master);

    noise.start();
    drone.start();
    lfo.start();

    Audio.ambient.noise = noise;
    Audio.ambient.noiseGain = noiseGain;
    Audio.ambient.drone = drone;
    Audio.ambient.droneGain = droneGain;
    Audio.ambient.lfo = lfo;
    Audio.ambient.lfoGain = lfoGain;
  }

  function stopAmbient() {
    const a = Audio.ambient;
    try {
      if (a.noise) a.noise.stop();
      if (a.drone) a.drone.stop();
    } catch (e) {}
    Audio.ambient = { noise: null, noiseGain: null, drone: null, droneGain: null, lfo: null, lfoGain: null };
  }

  function setMuted(muted) {
    Audio.enabled = !muted;
    if (!Audio.supported) return;
    if (Audio.enabled) {
      initAudio();
      if (Audio.master) Audio.master.gain.value = 0.6;
    } else {
      if (Audio.master) Audio.master.gain.value = 0.0;
    }
  }

  function playTone(freq, duration = 0.2, type = "sine", volume = 0.15) {
    if (!Audio.enabled || !Audio.ctx) return;
    try {
      const t = Audio.ctx.currentTime;
      const osc = Audio.ctx.createOscillator();
      const gain = Audio.ctx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(volume, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + duration);
      osc.connect(gain);
      gain.connect(Audio.master);
      osc.start(t);
      osc.stop(t + duration + 0.05);
    } catch (e) {}
  }

  function playCorrect() {
    if (!Audio.enabled || !Audio.ctx) return;
    // pleasant ascending chime
    const base = 523.25; // C5
    [base, base * 1.25, base * 1.5].forEach((f, i) => {
      setTimeout(() => playTone(f, 0.15, "sine", 0.2), i * 120);
    });
    visualFeedback.queue.push({ type: "correct", t: performance.now() });
    announce("Correct! Gate opens and a Star Seed appears.");
  }

  function playWrong() {
    if (!Audio.enabled || !Audio.ctx) return;
    const base = 392.0; // G4
    [base * 1.25, base, base * 0.75].forEach((f, i) => {
      setTimeout(() => playTone(f, 0.12, "triangle", 0.17), i * 90);
    });
    // soft noise thud
    try {
      const o = Audio.ctx.createOscillator();
      const g = Audio.ctx.createGain();
      o.type = "sawtooth";
      o.frequency.value = 80;
      const t = Audio.ctx.currentTime;
      g.gain.setValueAtTime(0.2, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);
      o.connect(g);
      g.connect(Audio.master);
      o.start(t);
      o.stop(t + 0.2);
    } catch (e) {}
    visualFeedback.queue.push({ type: "wrong", t: performance.now() });
    announce("Try again. That's not quite right.");
  }

  function playPickup() {
    if (!Audio.enabled || !Audio.ctx) return;
    const base = 659.25; // E5
    [0, 80, 160, 240].forEach((delay, i) => {
      setTimeout(() => playTone(base * (1 + i * 0.12), 0.12, "sine", 0.22), delay);
    });
    visualFeedback.queue.push({ type: "pickup", t: performance.now() });
    announce("Star Seed collected!");
  }

  // Visual feedback badges queue
  const visualFeedback = {
    queue: [],
    draw(ctx) {
      const now = performance.now();
      for (let i = this.queue.length - 1; i >= 0; i--) {
        const fx = this.queue[i];
        const age = (now - fx.t) / 1000;
        if (age > 1.0) {
          this.queue.splice(i, 1);
          continue;
        }
        const alpha = 1 - age;
        ctx.save();
        ctx.globalAlpha = alpha;
        let text = "";
        let color = "";
        if (fx.type === "correct") {
          text = "✓";
          color = "#42e66c";
        } else if (fx.type === "wrong") {
          text = "✗";
          color = "#ff6b6b";
        } else if (fx.type === "pickup") {
          text = "★";
          color = "#ffd166";
        }
        ctx.fillStyle = color;
        ctx.font = "48px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, WIDTH - 40, 40 + age * -20);
        ctx.restore();
      }
    }
  };

  // Game state
  const keys = {};
  let mouse = { x: 0, y: 0, down: false };
  let gameState = "title"; // title, playing, puzzle, win
  let lastTime = 0;

  const camera = { x: 0, y: 0 };

  const player = {
    x: WORLD_W / 2,
    y: WORLD_H / 2,
    r: PLAYER_RADIUS,
    speed: PLAYER_SPEED,
    color: "#ffd166",
    hatAngle: 0
  };

  let obstacles = []; // array of {x,y,w,h, color, openableId?}
  let interactables = []; // array of NPC/Gate/Sprout
  let stars = []; // array of star collectibles
  let starsCollected = 0;

  // Puzzles
  let activePuzzle = null; // { ownerId, character, prompt, choices, correctIndex, tip, solved }
  let activeChoiceIndex = 0;

  function announce(text) {
    live.textContent = text;
  }

  // World creation
  function createWorld() {
    obstacles = [];
    interactables = [];
    stars = [];
    starsCollected = 0;

    // Large island boundaries walls (keep within world edges)
    // Perimeter walls
    obstacles.push({ x: 0, y: 0, w: WORLD_W, h: 40, color: "#0e2a45" });
    obstacles.push({ x: 0, y: WORLD_H - 40, w: WORLD_W, h: 40, color: "#0e2a45" });
    obstacles.push({ x: 0, y: 0, w: 40, h: WORLD_H, color: "#0e2a45" });
    obstacles.push({ x: WORLD_W - 40, y: 0, w: 40, h: WORLD_H, color: "#0e2a45" });

    // Some fun winding walls (forest patches)
    const forestColor = "#0f4c5c";
    const rockColor = "#1b3b5a";
    // central lake
    obstacles.push({ x: WORLD_W / 2 - 220, y: WORLD_H / 2 - 150, w: 440, h: 40, color: forestColor });
    obstacles.push({ x: WORLD_W / 2 - 220, y: WORLD_H / 2 + 110, w: 440, h: 40, color: forestColor });
    obstacles.push({ x: WORLD_W / 2 - 220, y: WORLD_H / 2 - 150, w: 40, h: 300, color: forestColor });
    obstacles.push({ x: WORLD_W / 2 + 180, y: WORLD_H / 2 - 150, w: 40, h: 300, color: forestColor });

    // West maze
    obstacles.push({ x: 160, y: 160, w: 300, h: 30, color: rockColor });
    obstacles.push({ x: 160, y: 160, w: 30, h: 280, color: rockColor });
    obstacles.push({ x: 160, y: 410, w: 240, h: 30, color: rockColor });
    obstacles.push({ x: 400, y: 190, w: 30, h: 250, color: rockColor });

    // East cliffs
    obstacles.push({ x: WORLD_W - 490, y: 160, w: 300, h: 30, color: rockColor });
    obstacles.push({ x: WORLD_W - 220, y: 160, w: 30, h: 280, color: rockColor });
    obstacles.push({ x: WORLD_W - 460, y: 410, w: 270, h: 30, color: rockColor });

    // South grove
    obstacles.push({ x: WORLD_W / 2 - 330, y: WORLD_H - 260, w: 660, h: 30, color: forestColor });
    obstacles.push({ x: WORLD_W / 2 - 330, y: WORLD_H - 260, w: 30, h: 180, color: forestColor });
    obstacles.push({ x: WORLD_W / 2 + 300, y: WORLD_H - 260, w: 30, h: 180, color: forestColor });
    obstacles.push({ x: WORLD_W / 2 - 300, y: WORLD_H - 110, w: 330, h: 30, color: forestColor });

    // Gates (openable obstacles)
    // Gate North - Moss the Turtle (missing addend)
    const gateNorth = { x: WORLD_W / 2 - 30, y: 40, w: 60, h: 30, color: "#2b2d42", openableId: "gateNorth", open: false };
    obstacles.push(gateNorth);
    interactables.push({
      id: "moss",
      type: "gate",
      name: "Moss the Turtle",
      description: "Bridge to the Lagoon",
      character: "moss",
      x: WORLD_W / 2, y: 100,
      gateId: "gateNorth",
      puzzle: createPuzzle("missing"),
      solved: false
    });

    // Gate West - Rumble the Rock (addition)
    const gateWest = { x: 190, y: 290, w: 30, h: 60, color: "#2b2d42", openableId: "gateWest", open: false };
    obstacles.push(gateWest);
    interactables.push({
      id: "rumble",
      type: "gate",
      name: "Rumble the Rock",
      description: "Craggy Pass",
      character: "rumble",
      x: 240, y: 320,
      gateId: "gateWest",
      puzzle: createPuzzle("sum"),
      solved: false
    });

    // Gate East - Comet the Fox (subtraction)
    const gateEast = { x: WORLD_W - 220, y: 290, w: 30, h: 60, color: "#2b2d42", openableId: "gateEast", open: false };
    obstacles.push(gateEast);
    interactables.push({
      id: "comet",
      type: "gate",
      name: "Comet the Fox",
      description: "Sunbeam Path",
      character: "comet",
      x: WORLD_W - 260, y: 320,
      gateId: "gateEast",
      puzzle: createPuzzle("diff"),
      solved: false
    });

    // Gate South - Luma the Jelly (sum)
    const gateSouth = { x: WORLD_W / 2 - 30, y: WORLD_H - 110, w: 60, h: 30, color: "#2b2d42", openableId: "gateSouth", open: false };
    obstacles.push(gateSouth);
    interactables.push({
      id: "luma",
      type: "gate",
      name: "Luma the Jelly",
      description: "Glow Grove",
      character: "luma",
      x: WORLD_W / 2, y: WORLD_H - 160,
      gateId: "gateSouth",
      puzzle: createPuzzle("sum"),
      solved: false
    });

    // Blip the Jelly Sprout - free roaming quiz that spawns star
    interactables.push({
      id: "blip",
      type: "npc",
      name: "Blip the Jelly",
      description: "Jelly Sprout Riddle",
      character: "blip",
      x: WORLD_W / 2 + 40, y: WORLD_H / 2 - 200,
      puzzle: createPuzzle("missing"),
      solved: false
    });

    // Place star rewards behind gates and at random spots
    // We'll spawn stars when puzzles solved. Predefine spawn points:
    starSpawns = {
      gateNorth: { x: WORLD_W / 2, y: 70 },
      gateWest: { x: 170, y: 320 },
      gateEast: { x: WORLD_W - 170, y: 320 },
      gateSouth: { x: WORLD_W / 2, y: WORLD_H - 85 },
      blip: { x: WORLD_W / 2 + 110, y: WORLD_H / 2 - 230 }
    };
  }

  let starSpawns = {};

  function createPuzzle(type) {
    // Returns a fresh puzzle object with prompt, choices, tip
    // Types: "sum", "diff", "missing"
    if (type === "sum") {
      // a + b = ?
      const a = randInt(4, 12);
      const b = randInt(3, 9);
      const answer = a + b;
      const choices = generateChoices(answer, 3, 0, 30);
      return {
        type,
        prompt: `Add to help: ${a} + ${b} = ?`,
        tip: "Tip: Try making a ten. For example: (a + b) = (a + toTen) + (rest).",
        choices: choices.map(x => String(x)),
        correctIndex: choices.indexOf(answer)
      };
    } else if (type === "diff") {
      // a - b = ?
      const a = randInt(10, 20);
      const b = randInt(1, Math.min(9, a - 1));
      const answer = a - b;
      const choices = generateChoices(answer, 3, 0, 20);
      return {
        type,
        prompt: `Subtract to help: ${a} − ${b} = ?`,
        tip: "Tip: Count back by ones or jump to the nearest ten.",
        choices: choices.map(x => String(x)),
        correctIndex: choices.indexOf(answer)
      };
    } else {
      // missing addend: a + ? = s
      const a = randInt(4, 12);
      const s = randInt(a + 4, Math.min(20, a + 10));
      const answer = s - a;
      const choices = generateChoices(answer, 3, 0, 15);
      return {
        type,
        prompt: `Find the missing number: ${a} + ? = ${s}`,
        tip: "Tip: How much do we add to reach the total?",
        choices: choices.map(x => String(x)),
        correctIndex: choices.indexOf(answer)
      };
    }
  }

  function generateChoices(correct, count, min, max) {
    const set = new Set();
    set.add(correct);
    while (set.size < count) {
      let delta = randInt(-3, 3);
      if (delta === 0) delta = randInt(1, 3);
      let candidate = correct + delta;
      candidate = clamp(candidate, min, max);
      set.add(candidate);
    }
    // shuffle
    const arr = Array.from(set);
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Drawing helpers
  function drawWorld() {
    // Background water gradient
    drawWater();

    // Island wavy edges as subtle dots
    drawIsland();

    // Decorative floating jelly blobs
    drawJellies();

    // Obstacles
    for (const o of obstacles) {
      ctx.fillStyle = o.color || "#173953";
      ctx.fillRect(o.x, o.y, o.w, o.h);
      if (o.openableId && !o.open) {
        // draw gate arch and sign
        drawGateDecoration(o);
      }
    }

    // Stars
    for (const s of stars) {
      drawStar(s.x, s.y, s.r, s.phase);
    }

    // Interactables characters
    for (const it of interactables) {
      drawCharacter(it);
    }

    // Player
    drawPlayer();
  }

  function drawWater() {
    const g = ctx.createLinearGradient(0, 0, 0, WORLD_H);
    g.addColorStop(0, "#082032");
    g.addColorStop(1, "#0b2540");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WORLD_W, WORLD_H);
    // gentle sparkles
    const t = performance.now() * 0.001;
    ctx.globalAlpha = 0.08;
    for (let i = 0; i < 40; i++) {
      const x = (i * 123.45 + t * 33) % WORLD_W;
      const y = (i * 67.89 + t * 21) % WORLD_H;
      ctx.fillStyle = i % 2 ? "#0f3a5a" : "#0d3250";
      ctx.fillRect(x, y, 80, 2);
    }
    ctx.globalAlpha = 1;
  }

  function drawIsland() {
    // Main land area approximated by a big rounded rectangle inside the world margins
    ctx.fillStyle = ISLAND_COLOR;
    ctx.beginPath();
    const pad = 60;
    ctx.moveTo(pad, pad + 20);
    ctx.lineTo(WORLD_W - pad, pad);
    ctx.lineTo(WORLD_W - pad, WORLD_H - pad);
    ctx.lineTo(pad, WORLD_H - pad);
    ctx.closePath();
    ctx.globalAlpha = 0.9;
    ctx.fill();
    ctx.globalAlpha = 1;

    // Patterns on island
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = "#a7c957";
    for (let i = 0; i < 80; i++) {
      const x = (i * 137) % (WORLD_W - 2 * pad) + pad;
      const y = ((i * 53) % (WORLD_H - 2 * pad)) + pad;
      ctx.beginPath();
      ctx.arc(x, y, 6 + (i % 3), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawJellies() {
    const t = performance.now() * 0.001;
    for (let i = 0; i < 12; i++) {
      const x = 100 + (i * 110) % (WORLD_W - 200);
      const y = 120 + ((i * 70) % (WORLD_H - 240));
      const bob = Math.sin(t * (0.8 + i * 0.07) + i) * 6;
      const r = 10 + (i % 3) * 4;
      ctx.save();
      ctx.translate(x, y + bob);
      ctx.fillStyle = i % 2 ? "#98c1d9" : "#9d4edd";
      ctx.globalAlpha = 0.2;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }

  function drawGateDecoration(o) {
    // Stone arch above gate
    ctx.save();
    ctx.fillStyle = "#3b3d5b";
    ctx.strokeStyle = "#202235";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(o.x - 5, o.y - 10, o.w + 10, 10);
    ctx.fill();
    ctx.stroke();
    // little shinies
    ctx.fillStyle = "#8d99ae";
    for (let i = 0; i < 3; i++) {
      ctx.fillRect(o.x + 10 + i * 15, o.y - 8, 6, 4);
    }
    ctx.restore();
  }

  function drawStar(x, y, r, phase) {
    const t = performance.now() * 0.001 + (phase || 0);
    const scale = 1 + Math.sin(t * 3) * 0.1;
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.beginPath();
    const spikes = 5;
    const outer = r;
    const inner = r * 0.5;
    let rot = Math.PI / 2 * 3;
    let cx = 0, cy = 0;
    ctx.moveTo(0, -outer);
    for (let i = 0; i < spikes; i++) {
      cx = Math.cos(rot) * outer;
      cy = Math.sin(rot) * outer;
      ctx.lineTo(cx, cy);
      rot += Math.PI / spikes;
      cx = Math.cos(rot) * inner;
      cy = Math.sin(rot) * inner;
      ctx.lineTo(cx, cy);
      rot += Math.PI / spikes;
    }
    ctx.lineTo(0, -outer);
    ctx.closePath();
    const g = ctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
    g.addColorStop(0, "#ffe66d");
    g.addColorStop(1, "#f4a261");
    ctx.fillStyle = g;
    ctx.fill();
    ctx.restore();
  }

  function drawCharacter(it) {
    const t = performance.now() * 0.001;
    const bob = Math.sin(t * 2 + it.x * 0.01) * 3;

    ctx.save();
    ctx.translate(it.x, it.y + bob);

    // Interaction ring highlight
    if (nearInteractable(it)) {
      ctx.strokeStyle = "#ffe66d";
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(0, 0, 28, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Draw character based on type
    if (it.character === "moss") {
      // Turtle
      ctx.fillStyle = "#2a9d8f";
      ctx.beginPath();
      ctx.arc(0, 0, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#264653";
      ctx.fillRect(-16, -8, 32, 16);
      ctx.fillStyle = "#e9c46a";
      ctx.fillRect(-4, -14, 8, 8);
    } else if (it.character === "comet") {
      // Fox
      ctx.fillStyle = "#e76f51";
      ctx.beginPath();
      ctx.arc(0, 0, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#2a9d8f";
      ctx.beginPath();
      ctx.moveTo(-16, 0);
      ctx.lineTo(-30, -8);
      ctx.lineTo(-16, -2);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.fillRect(-6, -6, 12, 6);
    } else if (it.character === "rumble") {
      // Rock spirit
      ctx.fillStyle = "#6c757d";
      ctx.beginPath();
      ctx.arc(0, 0, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#343a40";
      ctx.fillRect(-10, -6, 20, 3);
    } else if (it.character === "luma") {
      // Jelly
      ctx.fillStyle = "#9d4edd";
      ctx.beginPath();
      ctx.arc(0, 0, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#ffd6ff";
      ctx.fillRect(-10, 6, 20, 4);
    } else if (it.character === "blip") {
      ctx.fillStyle = "#00b4d8";
      ctx.beginPath();
      ctx.arc(0, 0, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#caf0f8";
      ctx.fillRect(-8, 4, 16, 4);
    } else {
      // default sign
      ctx.fillStyle = "#ced4da";
      ctx.fillRect(-10, -20, 20, 40);
    }

    // Name tag
    ctx.font = "12px sans-serif";
    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "center";
    ctx.fillText(it.name, 0, -28);

    ctx.restore();
  }

  function drawPlayer() {
    const t = performance.now() * 0.001;
    const bob = Math.sin(t * 6) * 1.5;

    ctx.save();
    ctx.translate(player.x, player.y + bob);

    // body
    ctx.beginPath();
    ctx.fillStyle = player.color;
    ctx.arc(0, 0, player.r, 0, Math.PI * 2);
    ctx.fill();

    // hat
    ctx.save();
    player.hatAngle += 0.02;
    ctx.rotate(Math.sin(player.hatAngle) * 0.1);
    ctx.fillStyle = "#2b2d42";
    ctx.fillRect(-player.r * 0.7, -player.r - 6, player.r * 1.4, 6);
    ctx.fillStyle = "#8d99ae";
    ctx.fillRect(-player.r * 0.3, -player.r - 14, player.r * 0.6, 8);
    ctx.restore();

    // eyes
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(-4, -3, 2, 0, Math.PI * 2);
    ctx.arc(4, -3, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // Camera
  function updateCamera() {
    camera.x = clamp(player.x - WIDTH / 2, 0, WORLD_W - WIDTH);
    camera.y = clamp(player.y - HEIGHT / 2, 0, WORLD_H - HEIGHT);
    ctx.setTransform(1, 0, 0, 1, -camera.x, -camera.y);
  }

  // Collision
  function resolveCollisions(px, py, r) {
    let x = px, y = py;
    for (const o of obstacles) {
      if (o.openableId && o.open) continue;
      const closestX = clamp(x, o.x, o.x + o.w);
      const closestY = clamp(y, o.y, o.y + o.h);
      const dx = x - closestX;
      const dy = y - closestY;
      const d2 = dx * dx + dy * dy;
      if (d2 < r * r) {
        const d = Math.sqrt(d2) || 0.0001;
        const nx = dx / d;
        const ny = dy / d;
        const overlap = r - d;
        x += nx * overlap;
        y += ny * overlap;
      }
    }
    return { x, y };
  }

  function nearInteractable(it) {
    return dist2(player.x, player.y, it.x, it.y) <= (INTERACT_DIST * INTERACT_DIST);
  }

  // Puzzle UI
  function openPuzzleFor(interactable) {
    activePuzzle = {
      ownerId: interactable.id,
      gateId: interactable.gateId || null,
      character: interactable.name,
      prompt: interactable.puzzle.prompt,
      tip: interactable.puzzle.tip,
      choices: interactable.puzzle.choices.slice(),
      correctIndex: interactable.puzzle.correctIndex,
      solved: false
    };
    activeChoiceIndex = 0;
    gameState = "puzzle";
  }

  function answerPuzzle(choiceIndex) {
    const correct = choiceIndex === activePuzzle.correctIndex;
    if (correct) {
      activePuzzle.solved = true;
      // Mark interactable solved, open gates, spawn star
      const it = interactables.find(i => i.id === activePuzzle.ownerId);
      if (it) it.solved = true;
      if (activePuzzle.gateId) {
        const gate = obstacles.find(o => o.openableId === activePuzzle.gateId);
        if (gate) {
          gate.open = true;
        }
      }
      // Spawn star at designated spot if exists
      const spawnKey = activePuzzle.gateId || activePuzzle.ownerId;
      const spawn = starSpawns[spawnKey];
      if (spawn) {
        stars.push({ x: spawn.x, y: spawn.y, r: 12, phase: Math.random() * 10, taken: false });
      }
      playCorrect();
    } else {
      playWrong();
    }
    // Refresh puzzle for repeat if wrong
    if (!correct) {
      // Provide a slight variation on choices
      const it = interactables.find(i => i.id === activePuzzle.ownerId);
      if (it) {
        it.puzzle = createPuzzle(it.puzzle.type);
        activePuzzle.prompt = it.puzzle.prompt;
        activePuzzle.tip = it.puzzle.tip;
        activePuzzle.choices = it.puzzle.choices.slice();
        activePuzzle.correctIndex = it.puzzle.correctIndex;
      }
    } else {
      // Close puzzle on success
      setTimeout(() => {
        activePuzzle = null;
        gameState = "playing";
      }, 600);
    }
  }

  // UI overlays
  function drawTitle() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Title art
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#14213d");
    g.addColorStop(1, "#1b4965");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    ctx.fillStyle = "#ffe66d";
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Jelly Isles: Open Math Explorer", WIDTH / 2, 80);

    ctx.fillStyle = "#e0fbfc";
    ctx.font = "16px sans-serif";
    ctx.fillText("A playful open-world about addition and subtraction (ages 7-9)", WIDTH / 2, 112);

    // Characters preview
    const cx = WIDTH / 2;
    const cy = 200;

    // Draw circle with mini characters
    ctx.save();
    ctx.translate(cx, cy);
    const names = [
      { char: "moss", name: "Moss" },
      { char: "comet", name: "Comet" },
      { char: "rumble", name: "Rumble" },
      { char: "luma", name: "Luma" },
      { char: "blip", name: "Blip" },
    ];
    names.forEach((n, i) => {
      const angle = (i / names.length) * Math.PI * 2;
      const x = Math.cos(angle) * 120;
      const y = Math.sin(angle) * 60;
      drawCharacter({ x: cx + x, y: cy + y, name: n.name, character: n.char });
    });
    ctx.restore();

    // Instructions
    ctx.fillStyle = "#e0fbfc";
    ctx.textAlign = "left";
    const lines = [
      "How to play:",
      "• Explore the island with Arrow Keys or WASD.",
      "• Walk up to friendly creatures. Press Enter to talk.",
      "• Solve their math riddle to open gates and spawn Star Seeds.",
      "• Collect 5 Star Seeds to win!",
      "Controls: Enter = Interact/Confirm, 1-3 = Answer, M = Mute, H = Help",
      "Accessibility: All puzzles are keyboard accessible. Visual cues show feedback.",
      "Press Enter to begin."
    ];
    ctx.font = "14px sans-serif";
    let y = 280;
    for (const line of lines) {
      ctx.fillText(line, 60, y);
      y += 20;
    }

    // Speaker indicator
    drawSpeakerIcon(WIDTH - 40, 40, Audio.enabled);
  }

  function drawHelpOverlay() {
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.globalAlpha = 1;

    ctx.fillStyle = "#ffffff";
    ctx.font = "20px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Help & Tips", WIDTH / 2, 60);
    ctx.font = "14px sans-serif";
    const text = [
      "• Move with Arrow Keys or WASD",
      "• Press Enter to talk and confirm answers",
      "• Use 1, 2, or 3 to choose an answer",
      "• Press M to mute/unmute sounds",
      "• Press H to close this help",
      "Math Tips:",
      "• Making 10 helps addition: 8 + 6 = 8 + 2 + 4 = 10 + 4",
      "• For subtraction, hop back on a number line: 14 − 5 = 14 → 10 (−4) → 9 (−1) = 9"
    ];
    let y = 100;
    for (const l of text) {
      ctx.fillText(l, WIDTH / 2, y);
      y += 22;
    }
    ctx.restore();
  }

  function drawPuzzleOverlay() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "#1d3557";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.globalAlpha = 1;

    // Character badge
    ctx.fillStyle = "#e63946";
    ctx.fillRect(40, 40, 80, 80);
    ctx.fillStyle = "#fff";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(activePuzzle.character, 80, 98);

    // Title and prompt
    ctx.fillStyle = "#a8dadc";
    ctx.font = "18px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Riddle:", 140, 60);
    ctx.fillStyle = "#f1faee";
    ctx.font = "22px sans-serif";
    wrapText(ctx, activePuzzle.prompt, 140, 90, WIDTH - 180, 26);

    // Choices
    const baseY = 200;
    const boxes = [];
    for (let i = 0; i < activePuzzle.choices.length; i++) {
      const x = 140;
      const y = baseY + i * 64;
      const w = WIDTH - 280;
      const h = 48;
      boxes.push({ x, y, w, h });
      // background box
      ctx.fillStyle = i === activeChoiceIndex ? "#2a9d8f" : "#457b9d";
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = "#1d3557";
      ctx.lineWidth = 3;
      ctx.strokeRect(x, y, w, h);

      // label
      ctx.fillStyle = "#f1faee";
      ctx.font = "20px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText(`${i + 1}. ${activePuzzle.choices[i]}`, x + 12, y + 30);
    }

    // Tip
    ctx.fillStyle = "#a8dadc";
    ctx.font = "14px sans-serif";
    wrapText(ctx, activePuzzle.tip, 140, baseY + activePuzzle.choices.length * 64 + 30, WIDTH - 180, 20);

    // Instruction
    ctx.fillStyle = "#f1faee";
    ctx.textAlign = "center";
    ctx.fillText("Press 1, 2, or 3 to answer. Enter confirms. Esc to cancel.", WIDTH / 2, HEIGHT - 24);

    // Speaker
    drawSpeakerIcon(WIDTH - 40, 40, Audio.enabled);

    // store clickable regions for mouse
    puzzleBoxes = boxes;
    ctx.restore();
  }

  let puzzleBoxes = [];

  function drawHUD() {
    ctx.setTransform(1,0,0,1,0,0);
    // HUD bar
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(0, 0, WIDTH, 40);
    ctx.globalAlpha = 1;

    // Stars collected
    for (let i = 0; i < TARGET_STARS; i++) {
      const x = 12 + i * 22;
      const y = 20;
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(0.6, 0.6);
      ctx.globalAlpha = i < starsCollected ? 1 : 0.4;
      drawStar(0, 0, 12, i * 0.3);
      ctx.restore();
    }
    ctx.fillStyle = "#ffffff";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Stars: ${starsCollected}/${TARGET_STARS}`, 12 + TARGET_STARS * 22 + 8, 26);

    // Instructions snippet
    ctx.textAlign = "center";
    ctx.fillText("Move: Arrows/WASD • Enter: Talk • H: Help • M: Mute", WIDTH / 2, 26);

    drawSpeakerIcon(WIDTH - 24, 20, Audio.enabled);
  }

  function drawSpeakerIcon(x, y, on) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = on ? "#80ed99" : "#adb5bd";
    ctx.beginPath();
    ctx.moveTo(-12, -6);
    ctx.lineTo(-6, -6);
    ctx.lineTo(0, -12);
    ctx.lineTo(0, 12);
    ctx.lineTo(-6, 6);
    ctx.lineTo(-12, 6);
    ctx.closePath();
    ctx.fill();
    if (on) {
      ctx.strokeStyle = "#80ed99";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(2, 0, 6, -0.8, 0.8);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(4, 0, 10, -0.8, 0.8);
      ctx.stroke();
    } else {
      ctx.strokeStyle = "#ff6b6b";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-14, -12);
      ctx.lineTo(14, 12);
      ctx.stroke();
    }
    ctx.restore();
  }

  function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const words = text.split(" ");
    let line = "";
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + " ";
      const metrics = context.measureText(testLine);
      if (metrics.width > maxWidth && n > 0) {
        context.fillText(line, x, y);
        line = words[n] + " ";
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, x, y);
  }

  // Update
  function update(dt) {
    if (gameState !== "playing") return;

    let dx = 0, dy = 0;
    if (keys["ArrowLeft"] || keys["a"]) dx -= 1;
    if (keys["ArrowRight"] || keys["d"]) dx += 1;
    if (keys["ArrowUp"] || keys["w"]) dy -= 1;
    if (keys["ArrowDown"] || keys["s"]) dy += 1;

    const length = Math.hypot(dx, dy) || 1;
    dx = (dx / length) * player.speed;
    dy = (dy / length) * player.speed;

    let nx = player.x + dx;
    let ny = player.y + dy;

    // Collide with world obstacles
    const pos = resolveCollisions(nx, ny, player.r);
    player.x = pos.x;
    player.y = pos.y;

    // Collect stars
    for (const s of stars) {
      if (s.taken) continue;
      const d2s = dist2(player.x, player.y, s.x, s.y);
      if (d2s <= (player.r + s.r) * (player.r + s.r)) {
        s.taken = true;
        starsCollected += 1;
        playPickup();
        if (starsCollected >= TARGET_STARS) {
          setTimeout(() => {
            gameState = "win";
            announce("You collected all Star Seeds! Well done, Explorer!");
          }, 400);
        }
      }
    }
  }

  // Main loop
  function loop(ts) {
    const dt = (ts - lastTime) / 1000 || 0;
    lastTime = ts;

    if (gameState === "title") {
      drawTitle();
    } else if (gameState === "playing") {
      update(dt);
      updateCamera();
      drawWorld();
      // Reset transform to screen space for HUD
      drawHUD();
      visualFeedback.draw(ctx);
    } else if (gameState === "puzzle") {
      drawPuzzleOverlay();
      visualFeedback.draw(ctx);
    } else if (gameState === "win") {
      drawWin();
    }

    requestAnimationFrame(loop);
  }

  function drawWin() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = "#14213d";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    // Confetti
    for (let i = 0; i < 60; i++) {
      ctx.fillStyle = ["#ffd166", "#06d6a0", "#ef476f", "#118ab2"][i % 4];
      const x = (i * 91) % WIDTH;
      const y = (i * 53 + performance.now() * 0.1) % HEIGHT;
      ctx.fillRect(x, y, 6, 12);
    }
    ctx.fillStyle = "#ffe66d";
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("You did it, Star Explorer!", WIDTH / 2, 140);
    ctx.fillStyle = "#e0fbfc";
    ctx.font = "18px sans-serif";
    ctx.fillText("All 5 Star Seeds collected.", WIDTH / 2, 180);
    ctx.font = "14px sans-serif";
    ctx.fillText("Press R to play again. Press H for tips. Press M to mute/unmute.", WIDTH / 2, 220);
    drawSpeakerIcon(WIDTH - 40, 40, Audio.enabled);
  }

  // Event handlers
  canvas.addEventListener("keydown", (e) => {
    keys[e.key] = true;

    if (e.key === "Enter") {
      ensureAudioUnlocked();
    }

    if (gameState === "title" && e.key === "Enter") {
      gameState = "playing";
      announce("Game started. Explore the island and find friendly characters.");
      return;
    }

    if (e.key === "m" || e.key === "M") {
      setMuted(Audio.enabled); // toggle
      setMuted(!Audio.enabled);
    }
    if (e.key === "h" || e.key === "H") {
      if (gameState === "playing") {
        gameState = "help";
      } else if (gameState === "help") {
        gameState = "playing";
      } else if (gameState === "win") {
        gameState = "help";
      } else if (gameState === "puzzle") {
        // ignore
      } else if (gameState === "title") {
        // ignore
      }
    }

    if (gameState === "playing" && e.key === "Enter") {
      const it = interactables.find(i => nearInteractable(i));
      if (it) {
        openPuzzleFor(it);
      }
    }

    if (gameState === "playing") {
      if (keys["Escape"]) {
        // ignore or future pause
      }
    } else if (gameState === "puzzle") {
      if (e.key === "Escape") {
        activePuzzle = null;
        gameState = "playing";
      }
      if (e.key === "ArrowUp" || e.key === "w") {
        activeChoiceIndex = (activeChoiceIndex - 1 + 3) % 3;
      }
      if (e.key === "ArrowDown" || e.key === "s") {
        activeChoiceIndex = (activeChoiceIndex + 1) % 3;
      }
      if (e.key === "1" || e.key === "2" || e.key === "3") {
        const idx = parseInt(e.key, 10) - 1;
        answerPuzzle(idx);
      }
      if (e.key === "Enter") {
        answerPuzzle(activeChoiceIndex);
      }
    } else if (gameState === "win") {
      if (e.key === "r" || e.key === "R") {
        restart();
      }
    }

    e.preventDefault();
  });

  canvas.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });

  canvas.addEventListener("mousedown", (e) => {
    mouse.down = true;
    ensureAudioUnlocked();

    if (gameState === "title") {
      gameState = "playing";
      announce("Game started. Explore the island and find friendly characters.");
    } else if (gameState === "puzzle") {
      // Check clicks on choices
      const mx = mouse.x;
      const my = mouse.y;
      for (let i = 0; i < puzzleBoxes.length; i++) {
        const b = puzzleBoxes[i];
        if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
          activeChoiceIndex = i;
          answerPuzzle(i);
        }
      }
    } else if (gameState === "win") {
      restart();
    }
  });

  canvas.addEventListener("mouseup", (e) => {
    mouse.down = false;
  });

  // Focus canvas to receive keyboard input
  canvas.addEventListener("click", () => {
    canvas.focus();
  });

  // Restart
  function restart() {
    player.x = WORLD_W / 2;
    player.y = WORLD_H / 2;
    createWorld();
    gameState = "playing";
    announce("New game started.");
  }

  // Initialize
  function init() {
    createWorld();
    lastTime = performance.now();
    requestAnimationFrame(loop);
    announce("Welcome to Jelly Isles. Press Enter to begin.");
  }

  // Start
  init();

  // Render world relative to camera before each draw
  const originalFillRect = ctx.fillRect.bind(ctx);
  // Nothing to override; we manage transforms explicitly.

  // Game render integration: wrap drawWorld calls with camera transform
  // We already set transform in updateCamera.

  // Extra: Interaction prompt on screen when near an interactable (draw within world)
  const _drawWorld = drawWorld;
  drawWorld = function () {
    _drawWorld();
    // Show interaction tooltip if near
    const it = interactables.find(i => nearInteractable(i));
    if (it) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(player.x - 90, player.y - 60, 180, 22);
      ctx.fillStyle = "#ffffff";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(`Press Enter to talk to ${it.name}`, player.x, player.y - 45);
      ctx.restore();
    }
  };

  // Attach onbeforeunload to stop audio gracefully
  window.addEventListener("beforeunload", () => {
    stopAmbient();
    try {
      if (Audio.ctx) Audio.ctx.close();
    } catch (e) {}
  });

})();
---

