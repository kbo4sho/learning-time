# Game of the Day - 2025-08-07

## Metadata
- **Generated Date:** 2025-08-07
- **Generated Time:** 2025-08-07T00:23:38.289747
- **Model:** gpt-4.1-mini
- **Theme:** open world exploration
- **Game File:** 2025-08-07.js
- **File Size:** 21249 bytes
- **Tokens Used:** 6132

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: open world exploration

The game must:
â€¢ Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
â€¢ Reinforce the math concept through a real-world narratives tied to theme.
â€¢ Include fun, unique memorable characters tied to the theme.
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-4.1-mini model with the theme: "open world exploration".

## Files Generated
- `2025-08-07.js` - The playable game
- `2025-08-07.meta.json` - Machine-readable metadata
- `2025-08-07.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 14181

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 16422

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(() => {
  // SETUP AND CONSTANTS
  const WIDTH = 720;
  const HEIGHT = 480;

  // Math Concept: Number Bonds and Addition up to 20
  // Theme: Open World Exploration in a colorful forest where the player helps quirky creatures by collecting correct "number fruits".

  // Accessible keyboard controls:
  // Arrow keys to move explorer
  // Space / Enter to select fruit to deliver math bond answers
  // Instructions on screen, visual cues for sound on/off

  // GLOBAL VARIABLES
  let canvas, ctx;
  let audioCtx, gainNode;
  let gameState = {
    explorer: { x: WIDTH / 2, y: HEIGHT / 2, size: 40, speed: 4 },
    fruits: [],
    creatures: [],
    currentBond: null,
    score: 0,
    message: "Use arrow keys to move; Space to select fruit",
    selectedFruitIndex: 0,
    soundOn: true,
    keysPressed: {},
    frame: 0,
  };

  // COLORS WIBGYOR + extras for calming but wacky vibe
  const COLORS = {
    background: "#c7f0db",
    explorer: "#055a8c",
    fruits: ["#ff6f61", "#f7d154", "#6bc5a9", "#9d7fed", "#ef8a92", "#ffcc5c"],
    creatures: ["#684b6c", "#a1c3d1", "#f9f4e7"],
    outline: "#2e2e2e",
    text: "#2e2e2e",
    selectedFruitOutline: "#ffd700",
    hudBg: "rgba(255, 255, 255, 0.8)",
  };

  // SOUND UTILS
  function createAudioContext() {
    try {
      const context = new (window.AudioContext || window.webkitAudioContext)();
      return context;
    } catch (e) {
      return null;
    }
  }

  function playTone(freq, duration, type = "sine", volume = 0.3) {
    if (!audioCtx || !gameState.soundOn) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = type;
      osc.frequency.value = freq;

      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    } catch {
      // fail silently
    }
  }

  function playCorrectSound() {
    playTone(880, 0.15, "triangle", 0.25);
    setTimeout(() => playTone(1100, 0.12, "triangle", 0.25), 150);
  }

  function playWrongSound() {
    playTone(220, 0.3, "sawtooth", 0.3);
  }

  function playBackgroundHum() {
    if (!audioCtx || !gameState.soundOn) return;
    try {
      if (gameState._bgOsc) return; // already playing

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = "sine";
      osc.frequency.setValueAtTime(220, audioCtx.currentTime);

      gain.gain.setValueAtTime(0.03, audioCtx.currentTime);

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start();

      gameState._bgOsc = osc;
      gameState._bgGain = gain;
    } catch {
      // fail silently
    }
  }

  function stopBackgroundHum() {
    if (gameState._bgOsc) {
      try {
        gameState._bgGain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.7);
        setTimeout(() => {
          if (gameState._bgOsc) {
            gameState._bgOsc.stop();
            gameState._bgOsc.disconnect();
            gameState._bgGain.disconnect();
            gameState._bgOsc = null;
            gameState._bgGain = null;
          }
        }, 800);
      } catch {
        // fail silently
      }
    }
  }

  // GAME DATA GENERATION
  // Generate number bonds whose parts add up to between 5 and 20.
  function generateNumberBond() {
    // Pick total between 7 and 20
    const total = 7 + Math.floor(Math.random() * 14); // 7..20
    // Pick a part (1..total-1)
    const part1 = 1 + Math.floor(Math.random() * (total - 1));
    const part2 = total - part1;
    return { total, part1, part2 };
  }

  // Generate fruit with number and a color from the palette - fruits represent numbers to pick.
  function createFruit(num, x, y, color) {
    return {
      num,
      x,
      y,
      size: 30,
      color,
      isSelected: false,
      collected: false,
    };
  }

  // Creature represents the wacky forest character needing a number bond answer delivered.
  function createCreature(x, y) {
    return {
      x,
      y,
      size: 60,
      happy: false,
      // Says the total that needs to be matched by sum of fruits delivered
      currentBond: generateNumberBond(),
      deliveredNums: [],
    };
  }

  // Initialize fruits & creatures placed around the map/world
  function initializeGameObjects() {
    gameState.fruits = [];
    const fruitNumbers = [];
    // Creating abundant fruits numbered 1 to 15 so child can choose
    for (let n = 1; n <= 15; n++) {
      // Position fruits randomly but within borders
      const fx = 60 + Math.random() * (WIDTH - 120);
      const fy = 60 + Math.random() * (HEIGHT - 140);
      const c = COLORS.fruits[n % COLORS.fruits.length];
      const fruit = createFruit(n, fx, fy, c);
      gameState.fruits.push(fruit);
    }

    // Creatures at fixed interesting wacky spots
    gameState.creatures = [
      createCreature(120, 120),
      createCreature(WIDTH - 140, 140),
      createCreature(140, HEIGHT - 120),
      createCreature(WIDTH - 160, HEIGHT - 150),
    ];
  }

  // DRAWING UTILITIES

  function drawRoundedRect(ctx, x, y, w, h, r, fillColor, strokeColor) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    if (fillColor) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }
    if (strokeColor) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  // DRAW CREATURE: large body with quirky eyes and smile
  function drawCreature(ctx, creature) {
    const { x, y, size, happy } = creature;
    ctx.save();

    // Body: Blob shape with wobble
    ctx.fillStyle = COLORS.creatures[0];
    const wobble = 4 * Math.sin(gameState.frame / 15);
    ctx.beginPath();
    ctx.ellipse(x, y, size + wobble, size * 0.75 + wobble / 2, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.strokeStyle = COLORS.outline;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Face features
    // Eyes: Big, spaced, wacky pupils
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(x - size / 3, y - size / 6, 14, 18, 0, 0, 2 * Math.PI);
    ctx.ellipse(x + size / 3, y - size / 6, 14, 18, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();

    // Pupils move slightly with frame for life
    const pupilOffset = 3 * Math.sin(gameState.frame / 10);
    ctx.fillStyle = happy ? "#4CAF50" : "#000";
    ctx.beginPath();
    ctx.ellipse(x - size / 3 + pupilOffset / 2, y - size / 6, 6, 10, 0, 0, 2 * Math.PI);
    ctx.ellipse(x + size / 3 + pupilOffset / 2, y - size / 6 + Math.cos(gameState.frame / 12), 6, 10, 0, 0, 2 * Math.PI);
    ctx.fill();

    // Mouth: smile or straight line
    ctx.beginPath();
    if (happy) {
      ctx.strokeStyle = "#4CAF50";
      ctx.lineWidth = 3;
      ctx.arc(x, y + size / 6, size / 3, 0, Math.PI, false);
    } else {
      ctx.strokeStyle = COLORS.outline;
      ctx.lineWidth = 3;
      ctx.moveTo(x - size / 3, y + size / 6);
      ctx.lineTo(x + size / 3, y + size / 6);
    }
    ctx.stroke();

    // Display the bond question above the creature
    ctx.fillStyle = COLORS.text;
    ctx.font = "bold 18px Comic Sans MS, cursive, sans-serif";
    const bond = creature.currentBond;
    if (bond) {
      const text = `Help me: ? + ? = ${bond.total}`;
      ctx.textAlign = "center";
      ctx.fillText(text, x, y - size - 20);
    }

    ctx.restore();
  }

  // DRAW FRUIT: circle with number inside and little leaves for wackiness
  function drawFruit(ctx, fruit, isSelected = false) {
    const { x, y, size, color, num, collected } = fruit;
    if (collected) return; // Don't draw collected fruits

    ctx.save();
    // Fruit body
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.shadowColor = "rgba(0,0,0,0.15)";
    ctx.shadowBlur = 6;
    ctx.arc(x, y, size, 0, 2 * Math.PI);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = COLORS.outline;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Leaves - two arcs on top
    ctx.beginPath();
    ctx.strokeStyle = "#4b7f1a";
    ctx.lineWidth = 3;
    ctx.moveTo(x - size / 2, y - size / 2);
    ctx.quadraticCurveTo(x - size / 3, y - size, x - size / 6, y - size / 2);
    ctx.moveTo(x + size / 2, y - size / 2);
    ctx.quadraticCurveTo(x + size / 3, y - size, x + size / 6, y - size / 2);
    ctx.stroke();

    // Number on fruit
    ctx.fillStyle = "#fff";
    ctx.font = `${size}px Comic Sans MS, cursive, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(num, x, y);

    // Selection highlight
    if (isSelected) {
      ctx.strokeStyle = COLORS.selectedFruitOutline;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(x, y, size + 6, 0, 2 * Math.PI);
      ctx.stroke();
    }

    ctx.restore();
  }

  // DRAW EXPLORER: a little explorer with backpack and hat, who moves around controlling the game
  function drawExplorer(ctx, explorer) {
    const { x, y, size } = explorer;
    ctx.save();

    // Body: rectangle torso
    ctx.fillStyle = COLORS.explorer;
    drawRoundedRect(ctx, x - size / 2, y - size / 2 + 10, size, size * 0.6, 10, COLORS.explorer, COLORS.outline);

    // Head: circle
    ctx.beginPath();
    ctx.fillStyle = "#f1c27d";
    ctx.arc(x, y - size / 3, size / 2.5, 0, 2 * Math.PI);
    ctx.fill();
    ctx.strokeStyle = COLORS.outline;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Eyes
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(x - size / 8, y - size / 3, size / 20, 0, 2 * Math.PI);
    ctx.arc(x + size / 8, y - size / 3, size / 20, 0, 2 * Math.PI);
    ctx.fill();

    // Mouth
    ctx.beginPath();
    ctx.strokeStyle = "#6a3d00";
    ctx.lineWidth = 2;
    ctx.arc(x, y - size / 4, size / 10, 0, Math.PI, false);
    ctx.stroke();

    // Backpack: rounded rectangle behind torso
    ctx.fillStyle = "#716aca";
    drawRoundedRect(ctx, x - size / 2 - 8, y - size / 2 + 15, 18, size * 0.7, 5, "#716aca", COLORS.outline);

    // Hat: triangle on top
    ctx.beginPath();
    ctx.fillStyle = "#a52a2a";
    ctx.moveTo(x - size / 2, y - size / 2.8);
    ctx.lineTo(x + size / 2, y - size / 2.8);
    ctx.lineTo(x, y - size);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.restore();
  }

  // DRAW HUD & TEXTS - score, instructions, messages
  function drawHUD(ctx) {
    ctx.save();

    // Background panel
    ctx.fillStyle = COLORS.hudBg;
    ctx.fillRect(0, HEIGHT - 60, WIDTH, 60);
    ctx.strokeStyle = COLORS.outline;
    ctx.lineWidth = 2;
    ctx.strokeRect(0, HEIGHT - 60, WIDTH, 60);

    // Score
    ctx.fillStyle = COLORS.text;
    ctx.font = "20px Comic Sans MS, cursive, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText(`Score: ${gameState.score}`, 15, HEIGHT - 30);

    // Message / instruction
    ctx.textAlign = "center";
    ctx.fillText(gameState.message, WIDTH / 2, HEIGHT - 30);

    // Sound toggle indicator with text + icon
    ctx.textAlign = "right";
    ctx.fillText(gameState.soundOn ? "ðŸ”Š Sound On (S)" : "ðŸ”‡ Sound Off (S)", WIDTH - 15, HEIGHT - 30);

    ctx.restore();
  }

  // CLEAR WHOLE CANVAS
  function clearCanvas() {
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  // LOGIC HELPERS

  // Distance squared between two points for collision detection
  function distSq(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return dx * dx + dy * dy;
  }

  // Check if explorer overlaps with fruit (for "picking up" fruits)
  function checkExplorerFruitCollision() {
    const ex = gameState.explorer.x;
    const ey = gameState.explorer.y;

    // Selected fruit index corresponds to fruit in fruits array, but only those NOT collected
    // Space or Enter to pick the selected fruit and attempt to deliver to nearest creature.

    // The player picks a fruit by space or enter and then moves close to a creature to deliver.

    // Only allow pickup of the selected fruit if close enough to explorer

    // On selection, check if explorer collides with fruit to "grab" it

    const fruit = gameState.fruits[gameState.selectedFruitIndex];
    if (!fruit || fruit.collected) return;

    const ds = distSq(ex, ey, fruit.x, fruit.y);
    if (ds < (gameState.explorer.size / 2 + fruit.size) ** 2) {
      return fruit;
    }

    return null;
  }

  // Check if explorer is close enough to any creature to deliver a selected fruit as part of the bond
  function getNearbyCreature() {
    const ex = gameState.explorer.x;
    const ey = gameState.explorer.y;
    for (const creature of gameState.creatures) {
      const ds = distSq(ex, ey, creature.x, creature.y);
      if (ds < (gameState.explorer.size / 2 + creature.size) ** 2) {
        return creature;
      }
    }
    return null;
  }

  // Check if delivery of fruit fits the current bond parts for a creature
  // The creature must receive two numbers that sum to the total.
  // Delivery order does not matter.

  // Returns:
  // 0 - not ready (need more numbers)
  // 1 - success (sum to total)
  // 2 - wrong (sum not total)
  function checkDelivery(creature) {
    const nums = creature.deliveredNums;
    const total = creature.currentBond.total;
    if (nums.length < 2) return 0;
    const sum = nums.reduce((a, b) => a + b, 0);
    if (sum === total) return 1;
    return 2;
  }

  // PROCESS DELIVERY: after the player selects fruit and is near creature
  function processDelivery(fruit, creature) {
    if (!fruit || !creature) {
      gameState.message = "Move close to a creature to deliver fruit";
      playWrongSound();
      return;
    }

    if (fruit.collected) {
      gameState.message = "That fruit is already used!";
      playWrongSound();
      return;
    }

    creature.deliveredNums.push(fruit.num);
    fruit.collected = true;

    const result = checkDelivery(creature);
    if (result === 0) {
      gameState.message = `Delivered ${fruit.num}. One more fruit to go!`;
      playTone(600, 0.12, "triangle");
    } else if (result === 1) {
      // Success! Creature becomes happy
      gameState.score += 5;
      creature.happy = true;
      gameState.message = "Yay! The creature is happy and thanks you!";
      playCorrectSound();
      // Reset for next bond after delay
      setTimeout(() => {
        creature.happy = false;
        creature.currentBond = generateNumberBond();
        creature.deliveredNums = [];
      }, 4000);
    } else {
      // Wrong sum
      gameState.score = Math.max(0, gameState.score - 3);
      gameState.message = `Oops! The sum doesn't match ${creature.currentBond.total}. Try again!`;
      playWrongSound();
      // Reset deliveries and collected fruits used by this delivery attempt (only the last 2)
      creature.deliveredNums = [];
      // Mark all fruits again unused to retry (simple way)
      gameState.fruits.forEach(f => (f.collected = false));
    }
  }

  // PLAYER MOVEMENT AND CONTROLS

  function updateExplorerPosition() {
    const s = gameState.explorer.speed;
    if (gameState.keysPressed["ArrowUp"]) {
      gameState.explorer.y = Math.max(gameState.explorer.size / 2, gameState.explorer.y - s);
    }
    if (gameState.keysPressed["ArrowDown"]) {
      gameState.explorer.y = Math.min(HEIGHT - gameState.explorer.size / 2, gameState.explorer.y + s);
    }
    if (gameState.keysPressed["ArrowLeft"]) {
      gameState.explorer.x = Math.max(gameState.explorer.size / 2, gameState.explorer.x - s);
    }
    if (gameState.keysPressed["ArrowRight"]) {
      gameState.explorer.x = Math.min(WIDTH - gameState.explorer.size / 2, gameState.explorer.x + s);
    }
  }

  // Cycle selection index for fruit when the player presses Q or E keys
  function cycleSelectedFruit(forward = true) {
    if (forward) {
      gameState.selectedFruitIndex++;
      if (gameState.selectedFruitIndex >= gameState.fruits.length) {
        gameState.selectedFruitIndex = 0;
      }
    } else {
      gameState.selectedFruitIndex--;
      if (gameState.selectedFruitIndex < 0) {
        gameState.selectedFruitIndex = gameState.fruits.length - 1;
      }
    }
    gameState.message = `Selected fruit ${gameState.fruits[gameState.selectedFruitIndex].num}`;
    playTone(440, 0.08, "square");
  }

  // EVENT HANDLERS

  function onKeyDown(e) {
    if (e.repeat) return; // no repeats for sustain

    switch (e.code) {
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
        gameState.keysPressed[e.code] = true;
        break;
      case "Space":
      case "Enter":
        e.preventDefault();
        // Select fruit if accessible and try to deliver if near creature
        if (!audioCtx) {
          try {
            audioCtx = createAudioContext();
            if (audioCtx) {
              playBackgroundHum();
            }
          } catch {}
        }
        const fruit = gameState.fruits[gameState.selectedFruitIndex];
        const explorer = gameState.explorer;
        // Check distance to fruit to pick it up
        if (!fruit.collected && distSq(explorer.x, explorer.y, fruit.x, fruit.y) < (explorer.size / 2 + fruit.size) ** 2) {
          // Pick fruit and try to deliver to a creature nearby
          const creature = getNearbyCreature();
          if (creature) {
            processDelivery(fruit, creature);
          } else {
            gameState.message = "Move close to a creature to deliver fruit";
            playWrongSound();
          }
        } else {
          gameState.message = "Move closer to the selected fruit first";
          playWrongSound();
        }
        break;
      case "KeyQ":
        cycleSelectedFruit(false);
        break;
      case "KeyE":
        cycleSelectedFruit(true);
        break;
      case "KeyS":
        // Toggle sound
        gameState.soundOn = !gameState.soundOn;
        if (gameState.soundOn) {
          if (audioCtx && audioCtx.state === "suspended") {
            audioCtx.resume();
          }
          playBackgroundHum();
          gameState.message = "Sound turned ON";
        } else {
          stopBackgroundHum();
          gameState.message = "Sound turned OFF";
        }
        break;
    }
  }

  function onKeyUp(e) {
    if (e.repeat) return;
    if (
      e.code === "ArrowUp" ||
      e.code === "ArrowDown" ||
      e.code === "ArrowLeft" ||
      e.code === "ArrowRight"
    ) {
      delete gameState.keysPressed[e.code];
    }
  }

  // GAME LOOP

  function update() {
    updateExplorerPosition();
  }

  // DRAW ALL GAME ELEMENTS
  function draw() {
    clearCanvas();

    // Draw creatures first (background layer)
    for (const creature of gameState.creatures) {
      drawCreature(ctx, creature);
    }

    // Draw fruits, highlight selected
    gameState.fruits.forEach((fruit, i) => {
      drawFruit(ctx, fruit, i === gameState.selectedFruitIndex && !fruit.collected);
    });

    // Draw explorer on top
    drawExplorer(ctx, gameState.explorer);

    // HUD overlay
    drawHUD(ctx);
  }

  // MAIN ANIMATION FRAME
  function gameLoop() {
    gameState.frame++;
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  // INITIALIZE
  function init() {
    try {
      const container = document.getElementById("game-of-the-day-stage");
      if (!container) {
        console.error("Error: Container element with id 'game-of-the-day-stage' not found.");
        return;
      }
      container.tabIndex = 0; // Make focusable for keyboard controls
      container.style.outline = "none";

      canvas = document.createElement("canvas");
      canvas.width = WIDTH;
      canvas.height = HEIGHT;
      canvas.setAttribute("role", "img");
      canvas.setAttribute("aria-label", "Open World Math Exploration Game. Use arrow keys to move, space to interact.");
      container.innerHTML = "";
      container.appendChild(canvas);

      ctx = canvas.getContext("2d");
      ctx.font = "20px Comic Sans MS, cursive, sans-serif";

      // Audio context setup
      audioCtx = createAudioContext();
      if (!audioCtx) {
        gameState.message = "Audio not supported in this browser.";
      } else {
        gainNode = audioCtx.createGain();
        gainNode.connect(audioCtx.destination);
        playBackgroundHum();
      }

      initializeGameObjects();

      container.focus();

      container.addEventListener("keydown", onKeyDown);
      container.addEventListener("keyup", onKeyUp);
      container.addEventListener("blur", () => {
        gameState.keysPressed = {};
      });

      gameState.message = "Welcome! Use arrow keys to move, Q/E to select fruit, Space to deliver fruit.";
      gameLoop();
    } catch (err) {
      console.error("Initialization error:", err);
      alert("Failed to initialize the game. Your browser might not support required features.");
    }
  }

  window.addEventListener("load", init);
})();
---

