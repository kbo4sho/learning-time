# Game of the Day - 2025-08-15

## Metadata
- **Generated Date:** 2025-08-15
- **Generated Time:** 2025-08-15T00:24:05.700916
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-15.js
- **File Size:** 31123 bytes
- **Tokens Used:** 10818

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-15.js` - The playable game
- `2025-08-15.meta.json` - Machine-readable metadata
- `2025-08-15.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22659

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 25160

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  'use strict';

  // Game for ages 7-9: "Spark & the Electric Sum"
  // Renders into element with ID 'game-of-the-day-stage'
  // Canvas 720x480. All graphics drawn via canvas methods.
  // Audio via Web Audio API (oscillators only). Includes error handling and accessibility.

  // -------------------------
  // Utility functions
  // -------------------------
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }
  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }
  function pick(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  // -------------------------
  // Setup stage and canvas
  // -------------------------
  const stage = document.getElementById('game-of-the-day-stage');
  if (!stage) {
    console.error('Element with ID "game-of-the-day-stage" not found. Creating one automatically.');
    const fallback = document.createElement('div');
    fallback.id = 'game-of-the-day-stage';
    document.body.appendChild(fallback);
  }
  // Clear stage content
  stage.innerHTML = '';
  stage.style.outline = 'none';

  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.tabIndex = 0; // make focusable
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Spark and the Electric Sum: use arrow keys to move Spark, space to collect electrons, click to drag electrons. Toggle sound with S. Press Enter to submit collected charge. Instructions are shown on screen.');
  canvas.style.display = 'block';
  canvas.style.margin = '0';
  stage.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // -------------------------
  // Audio setup with error handling
  // -------------------------
  let audioCtx = null;
  let audioAvailable = true;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) throw new Error('Web Audio API not supported');
    audioCtx = new AudioContext();
  } catch (e) {
    console.warn('Audio context could not be created:', e);
    audioAvailable = false;
  }

  // Background hum nodes
  let bgOsc = null;
  let bgGain = null;
  let audioOn = true; // user-controlled toggle

  function safeResumeAudio() {
    if (!audioAvailable || !audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch((e) => {
        console.warn('Audio resume failed', e);
      });
    }
  }

  // Sound generators
  function playTone({ freq = 440, duration = 0.3, type = 'sine', volume = 0.12, detune = 0, filterFreq = null }) {
    if (!audioAvailable || !audioOn) return Promise.resolve();
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      o.detune.value = detune;
      if (filterFreq) {
        const f = audioCtx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = filterFreq;
        o.connect(f);
        f.connect(g);
      } else {
        o.connect(g);
      }
      g.gain.value = 0;
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(volume, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.02);
      return Promise.resolve();
    } catch (err) {
      console.warn('playTone failed', err);
      return Promise.resolve();
    }
  }

  function playCorrectChord() {
    if (!audioAvailable || !audioOn) return;
    // simple arpeggio
    const now = audioCtx.currentTime;
    const freqs = [523.25, 659.25, 783.99]; // C5, E5, G5
    freqs.forEach((f, i) => {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'triangle';
      o.frequency.value = f;
      o.connect(g);
      g.connect(audioCtx.destination);
      const t = now + i * 0.06;
      g.gain.setValueAtTime(0.001, t);
      g.gain.linearRampToValueAtTime(0.12, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.28);
      o.start(t);
      o.stop(t + 0.3);
    });
  }

  function playWrongBuzz() {
    if (!audioAvailable || !audioOn) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.type = 'sawtooth';
      o.frequency.value = 120;
      f.type = 'lowpass';
      f.frequency.value = 600;
      o.connect(f);
      f.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.001, now);
      g.gain.linearRampToValueAtTime(0.14, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      o.start(now);
      o.stop(now + 0.36);
    } catch (e) {
      console.warn('playWrongBuzz failed', e);
    }
  }

  function playPickupPluck() {
    playTone({ freq: 880, duration: 0.12, type: 'square', volume: 0.08 });
    playTone({ freq: 660, duration: 0.14, type: 'sine', volume: 0.06, detune: 10 });
  }

  function startBackgroundHum() {
    if (!audioAvailable || !audioOn) return;
    try {
      if (bgOsc) {
        bgOsc.stop();
        bgOsc.disconnect();
      }
      bgOsc = audioCtx.createOscillator();
      bgGain = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      f.type = 'lowpass';
      f.frequency.value = 600;
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 110; // low hum
      bgOsc.connect(f);
      f.connect(bgGain);
      bgGain.connect(audioCtx.destination);
      bgGain.gain.value = 0.02;
      bgOsc.start();
    } catch (e) {
      console.warn('startBackgroundHum failed', e);
    }
  }

  function stopBackgroundHum() {
    try {
      if (bgOsc) {
        bgOsc.stop();
        bgOsc.disconnect();
        bgOsc = null;
      }
      if (bgGain) {
        bgGain.disconnect();
        bgGain = null;
      }
    } catch (e) {
      // ignore
    }
  }

  if (audioAvailable) {
    // start background when user interacts later (click/keypress)
    audioOn = true;
  } else {
    audioOn = false;
  }

  // -------------------------
  // Game constants and state
  // -------------------------
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  const PANEL_X = 540;
  const PANEL_Y = 120;
  const PANEL_W = 150;
  const PANEL_H = 180;

  const BULB_X = PANEL_X + PANEL_W / 2;
  const BULB_Y = PANEL_Y + PANEL_H + 70;

  let lastTime = 0;
  let running = false;
  let showInstructions = true;
  let level = 1;
  let score = 0;
  let targetCharge = 8;
  let currentCharge = 0;
  let electrons = [];
  let messages = []; // temporary messages
  let glowTime = 0; // visual cue when sound plays
  let controlsActive = true;

  // Spark (player)
  const spark = {
    x: 140,
    y: HEIGHT / 2,
    vx: 0,
    vy: 0,
    radius: 32,
    color: '#FFD66B',
    speed: 240 // px per second
  };

  // Input state
  const keys = {};
  let mouse = { x: 0, y: 0, down: false, dragElectron: null };

  // Accessibility: keyboard mapping note: Arrow keys move, Space collect nearest, Enter submit.
  // Also 'S' toggles sound.

  // -------------------------
  // Game functions
  // -------------------------
  function resetLevel() {
    currentCharge = 0;
    electrons = [];
    messages = [];
    glowTime = 0;
    // targetCharge increases with level but remains reasonable for age 7-9
    targetCharge = Math.min(20, 5 + Math.floor(level * 1.7));
    // spawn electrons - ensure there are numbers such that sums can reach target
    // We'll generate a mix of 1..9 values
    const count = 6 + Math.min(4, level);
    for (let i = 0; i < count; i++) {
      const v = generateElectronValue(i);
      const e = {
        id: Math.random().toString(36).slice(2),
        x: rand(220, 480),
        y: rand(60, HEIGHT - 80),
        r: 22,
        vx: rand(-30, 30),
        vy: rand(-20, 20),
        value: v,
        grabbed: false,
        beingSent: false,
        sendT: 0
      };
      electrons.push(e);
    }
    // ensure solvable: include at least one electron equal to target or combination possible:
    // add one electron equal to target if small enough
    if (targetCharge <= 9 && !electrons.some(e => e.value === targetCharge)) {
      electrons.push({
        id: 'guarantee',
        x: rand(260, 400),
        y: rand(80, HEIGHT - 100),
        r: 22,
        vx: 0,
        vy: 0,
        value: targetCharge,
        grabbed: false,
        beingSent: false,
        sendT: 0
      });
    }

    // Provide gentle audio cue
    if (audioAvailable && audioOn) {
      playTone({ freq: 300 + targetCharge * 8, duration: 0.18, type: 'sine', volume: 0.06 });
    }
  }

  function generateElectronValue(i) {
    // make more smaller numbers; occasionally bigger
    const base = Math.random();
    if (base < 0.5) return Math.floor(rand(1, 5)); // 1-4
    if (base < 0.85) return Math.floor(rand(4, 8)); // 4-7
    return Math.floor(rand(7, 10)); // 7-9
  }

  function addMessage(text, duration = 1600) {
    messages.push({ text, t: duration });
  }

  function collectNearestElectron() {
    // find nearest electron within range
    let nearest = null;
    let nd = Infinity;
    for (const e of electrons) {
      if (e.beingSent) continue;
      const dx = e.x - spark.x;
      const dy = e.y - spark.y;
      const d = Math.hypot(dx, dy);
      if (d < nd) {
        nd = d;
        nearest = e;
      }
    }
    if (nearest && nd <= 90) {
      pickUpElectron(nearest);
    } else {
      addMessage('Too far! Move closer to collect electrons.');
      playWrongBuzz();
    }
  }

  function pickUpElectron(e) {
    if (e.grabbed || e.beingSent) return;
    e.grabbed = true;
    if (audioAvailable && audioOn) playPickupPluck();
    addMessage('Electron ' + e.value + ' collected!');
  }

  function submitCharge() {
    // send current electrons to panel -> but we instead sum values of electrons that were pulled to panel
    // In this implementation, pressing Enter will "submit" the currentCharge (we update when sending electrons)
    // We only check equal/exceed logic here:
    if (currentCharge === targetCharge) {
      // success!
      addMessage('Perfect! Bulb lit! +1 level');
      score += 10 * level;
      level++;
      glowTime = 0.8;
      if (audioAvailable && audioOn) playCorrectChord();
      resetLevel();
    } else if (currentCharge < targetCharge) {
      addMessage('Not enough charge. Try adding more electrons.');
      if (audioAvailable && audioOn) playTone({ freq: 260, duration: 0.18, type: 'sine', volume: 0.08 });
    } else {
      // overcharged
      addMessage('Oh no, you overloaded the bulb! It popped! -1 level');
      score = Math.max(0, score - 5);
      level = Math.max(1, level - 1);
      if (audioAvailable && audioOn) playWrongBuzz();
      resetLevel();
    }
  }

  function sendElectronToPanel(e) {
    e.beingSent = true;
    e.sendStart = { x: e.x, y: e.y };
    e.sendT = 0;
    if (audioAvailable && audioOn) playTone({ freq: 880 - e.value * 20, duration: 0.18, type: 'sine', volume: 0.06 });
  }

  // -------------------------
  // Drawing functions
  // -------------------------
  function drawBackground() {
    // calming gradient background with wacky swirls
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#e8f7ff');
    g.addColorStop(1, '#f5fff7');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft circuit pattern (light)
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.strokeStyle = '#8cf0ff';
    ctx.lineWidth = 2;
    for (let i = 0; i < 8; i++) {
      ctx.beginPath();
      const y = 20 + i * 55;
      ctx.moveTo(0, y);
      ctx.bezierCurveTo(150, y + 20, 300, y - 20, WIDTH, y + 10);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawPanel() {
    // Power panel on the right
    ctx.save();
    // panel background
    ctx.fillStyle = '#2d3b4a';
    roundRect(ctx, PANEL_X, PANEL_Y, PANEL_W, PANEL_H, 12);
    ctx.fill();

    // label
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Power Panel', PANEL_X + PANEL_W / 2, PANEL_Y + 24);

    // target display
    ctx.fillStyle = '#0fffcf';
    ctx.font = 'bold 28px sans-serif';
    ctx.fillText('Need: ' + targetCharge, PANEL_X + PANEL_W / 2, PANEL_Y + 64);

    // current charge gauge
    ctx.fillStyle = '#222';
    roundRect(ctx, PANEL_X + 18, PANEL_Y + 78, PANEL_W - 36, 26, 8);
    ctx.fill();
    const pct = clamp(currentCharge / Math.max(targetCharge, 1), 0, 1);
    ctx.fillStyle = '#00ff9e';
    roundRect(ctx, PANEL_X + 18, PANEL_Y + 78, (PANEL_W - 36) * pct, 26, 8);
    ctx.fill();

    // gauge text
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 18px sans-serif';
    ctx.fillText('Charge: ' + currentCharge, PANEL_X + PANEL_W / 2, PANEL_Y + 98);

    ctx.restore();
  }

  function drawBulb() {
    // bulb character
    ctx.save();
    // base wires
    ctx.strokeStyle = '#e8ffea';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(BULB_X - 48, BULB_Y + 36);
    ctx.lineTo(BULB_X - 10, BULB_Y + 36);
    ctx.moveTo(BULB_X + 48, BULB_Y + 36);
    ctx.lineTo(BULB_X + 10, BULB_Y + 36);
    ctx.stroke();

    // bulb glass
    const lit = currentCharge >= targetCharge && currentCharge === targetCharge;
    const bulbGlow = glowTime > 0 ? Math.min(1, glowTime * 1.6) : (lit ? 1 : 0);

    // soft glow
    if (bulbGlow > 0) {
      ctx.beginPath();
      const rg = ctx.createRadialGradient(BULB_X, BULB_Y - 10, 8, BULB_X, BULB_Y - 10, 120);
      rg.addColorStop(0, `rgba(255,230,120,${0.8 * bulbGlow})`);
      rg.addColorStop(1, `rgba(255,230,120,0)`);
      ctx.fillStyle = rg;
      ctx.fillRect(BULB_X - 120, BULB_Y - 120, 240, 240);
    }

    // bulb outline
    ctx.beginPath();
    ctx.fillStyle = lit ? '#fff6b3' : '#ffffff';
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 2;
    ctx.ellipse(BULB_X, BULB_Y - 10, 36, 50, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // filament (friendly face)
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(BULB_X - 10, BULB_Y - 18, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(BULB_X + 10, BULB_Y - 18, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.beginPath();
    ctx.moveTo(BULB_X - 8, BULB_Y - 6);
    ctx.quadraticCurveTo(BULB_X, BULB_Y + 2, BULB_X + 8, BULB_Y - 6);
    ctx.stroke();

    // base
    ctx.fillStyle = '#667';
    roundRect(ctx, BULB_X - 20, BULB_Y + 18, 40, 24, 6);
    ctx.fill();

    ctx.restore();
  }

  function drawSpark() {
    ctx.save();
    // shadow
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.ellipse(spark.x, spark.y + 38, 28, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // body - magnet-like friendly robot
    ctx.beginPath();
    ctx.fillStyle = spark.color;
    ctx.strokeStyle = '#d08f2a';
    ctx.lineWidth = 2;
    ctx.ellipse(spark.x, spark.y - 6, spark.radius, spark.radius + 6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // eyes
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(spark.x - 10, spark.y - 14, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(spark.x + 10, spark.y - 14, 5, 0, Math.PI * 2);
    ctx.fill();

    // mouth smile
    ctx.beginPath();
    ctx.strokeStyle = '#3b3b3b';
    ctx.lineWidth = 2;
    ctx.arc(spark.x, spark.y - 2, 8, 0, Math.PI);
    ctx.stroke();

    // magnet prongs - goofy
    ctx.fillStyle = '#ff7b7b';
    ctx.fillRect(spark.x - 30, spark.y + 14, 12, 10);
    ctx.fillRect(spark.x + 18, spark.y + 14, 12, 10);
    ctx.strokeStyle = '#b24b4b';
    ctx.strokeRect(spark.x - 30, spark.y + 14, 12, 10);
    ctx.strokeRect(spark.x + 18, spark.y + 14, 12, 10);

    // range indicator for collection (when focused)
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.ellipse(spark.x, spark.y + 6, 90, 90, 0, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();
  }

  function drawElectron(e) {
    ctx.save();
    // body
    const g = ctx.createRadialGradient(e.x - 6, e.y - 6, 4, e.x + 6, e.y + 6, e.r + 6);
    g.addColorStop(0, '#fffef0');
    g.addColorStop(0.2, '#a0ffee');
    g.addColorStop(1, '#72d1ff');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#2d94b6';
    ctx.lineWidth = 2;
    ctx.stroke();

    // number
    ctx.fillStyle = '#073042';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(e.value), e.x, e.y + 1);

    // tail or spark
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.moveTo(e.x - e.r + 2, e.y - e.r + 2);
    ctx.lineTo(e.x - e.r - 10, e.y - e.r - 10);
    ctx.stroke();

    // highlight when grabbed
    if (e.grabbed) {
      ctx.beginPath();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.5;
      ctx.arc(e.x, e.y, e.r + 6, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawUI() {
    // top bar: score, level, instructions icon, sound icon
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    roundRect(ctx, 8, 8, WIDTH - 16, 48, 12);
    ctx.fill();

    ctx.fillStyle = '#073042';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Score: ' + score, 20, 34);
    ctx.fillText('Level: ' + level, 140, 34);

    // instructions toggle text
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#01303a';
    ctx.fillText(showInstructions ? 'Press H to hide help' : 'Press H to show help', 220, 34);

    // sound icon
    const sx = WIDTH - 80;
    const sy = 18;
    ctx.fillStyle = audioOn ? '#ffdd57' : '#c4c4c4';
    ctx.beginPath();
    ctx.moveTo(sx, sy + 6);
    ctx.lineTo(sx + 12, sy + 6);
    ctx.lineTo(sx + 22, sy);
    ctx.lineTo(sx + 22, sy + 36);
    ctx.lineTo(sx + 12, sy + 30);
    ctx.lineTo(sx, sy + 30);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#6c4f18';
    ctx.stroke();

    ctx.fillStyle = '#01303a';
    ctx.textAlign = 'center';
    ctx.font = '12px sans-serif';
    ctx.fillText(audioOn ? 'Sound On (S)' : 'Muted (S)', sx + 11, sy + 46);

    // instructions summary (if enabled)
    if (showInstructions) {
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      roundRect(ctx, 16, 66, 380, 120, 10);
      ctx.fillStyle = '#01303a';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'left';
      wrapText(ctx, 'Goal: Collect electrons (numbers) to match the panel target charge exactly. Move Spark with arrow keys or mouse. Press SPACE to collect nearest electron, drag electrons with the mouse, press ENTER to submit your charge.', 24, 86, 360, 18);
      ctx.fillStyle = '#015a4a';
      ctx.font = 'bold 13px sans-serif';
      ctx.fillText('Controls: Arrows = move, Space = collect, Click/Drag = move electron, Enter = submit', 24, 160);
    }

    ctx.restore();
  }

  // Helper: rounded rect
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Helper: wrap text
  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line, x, y);
        line = words[n] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, y);
  }

  // -------------------------
  // Game update loop
  // -------------------------
  function update(dt) {
    // update spark from keys
    let moveX = 0;
    let moveY = 0;
    if (keys['ArrowLeft']) moveX -= 1;
    if (keys['ArrowRight']) moveX += 1;
    if (keys['ArrowUp']) moveY -= 1;
    if (keys['ArrowDown']) moveY += 1;
    if (moveX !== 0 || moveY !== 0) {
      const len = Math.hypot(moveX, moveY) || 1;
      spark.x += (moveX / len) * spark.speed * dt;
      spark.y += (moveY / len) * spark.speed * dt;
    }
    // mouse movement when dragging spark: if focused and mouse down but not dragging electron, spark follows
    if (mouse.down && !mouse.dragElectron) {
      // smooth follow
      spark.x += (mouse.x - spark.x) * 8 * dt;
      spark.y += (mouse.y - spark.y) * 8 * dt;
    }

    // clamp spark within left half to encourage movement
    spark.x = clamp(spark.x, 60, WIDTH - 220);
    spark.y = clamp(spark.y, 60, HEIGHT - 60);

    // update electrons
    for (const e of electrons) {
      if (e.beingSent) {
        // animate along curve to panel center
        e.sendT += dt * 1.6;
        const t = clamp(e.sendT, 0, 1);
        const sx = e.sendStart.x;
        const sy = e.sendStart.y;
        // simple quadratic curve to BULB position
        const cx = (sx + BULB_X) / 2 + rand(-30, 30);
        const cy = Math.min(sy, BULB_Y) - 60;
        // Quadratic Bezier interpolation
        e.x = (1 - t) * (1 - t) * sx + 2 * (1 - t) * t * cx + t * t * BULB_X;
        e.y = (1 - t) * (1 - t) * sy + 2 * (1 - t) * t * cy + t * t * BULB_Y;
        e.r = 20 * (1 - 0.2 * t);
        if (t >= 1) {
          // reached panel - add value
          currentCharge += e.value;
          // remove electron
          e.toRemove = true;
          if (audioAvailable && audioOn) {
            playTone({ freq: 520 + e.value * 16, duration: 0.14, type: 'sine', volume: 0.06 });
          }
        }
      } else if (e.grabbed) {
        // follow spark
        e.x += (spark.x + 18 - e.x) * 12 * dt;
        e.y += (spark.y - 8 - e.y) * 12 * dt;
        // if close to panel area, send to panel
        const dx = e.x - (PANEL_X + PANEL_W / 2);
        const dy = e.y - (PANEL_Y + PANEL_H / 2);
        if (Math.hypot(dx, dy) < 54) {
          sendElectronToPanel(e);
          e.grabbed = false;
        }
      } else if (mouse.dragElectron && mouse.dragElectron.id === e.id) {
        // follow mouse coordinates when manual dragging
        e.x = mouse.x;
        e.y = mouse.y;
      } else {
        // free movement
        e.x += e.vx * dt;
        e.y += e.vy * dt;
        // bounce
        if (e.x < 60 || e.x > PANEL_X - 30) e.vx *= -1;
        if (e.y < 80 || e.y > HEIGHT - 80) e.vy *= -1;
      }
    }
    // remove electrons marked for removal
    electrons = electrons.filter(e => !e.toRemove);

    // messages decay
    for (const m of messages) {
      m.t -= dt * 1000;
    }
    messages = messages.filter(m => m.t > 0);

    // glowTime decay
    if (glowTime > 0) glowTime = Math.max(0, glowTime - dt);

    // Occasionally spawn a wandering electron to keep things playful
    if (Math.random() < dt * 0.2 && electrons.length < 10) {
      electrons.push({
        id: Math.random().toString(36).slice(2),
        x: rand(220, 440),
        y: rand(60, HEIGHT - 80),
        r: 20,
        vx: rand(-20, 20),
        vy: rand(-20, 20),
        value: Math.floor(rand(1, 9)),
        grabbed: false,
        beingSent: false,
        sendT: 0
      });
    }
  }

  function render() {
    drawBackground();
    drawPanel();
    drawBulb();

    // connector wires from panel to bulb
    ctx.save();
    ctx.strokeStyle = '#5df0c8';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(PANEL_X + PANEL_W / 2 - 10, PANEL_Y + PANEL_H);
    ctx.quadraticCurveTo(PANEL_X + PANEL_W / 2 + 30, PANEL_Y + PANEL_H + 80, BULB_X - 20, BULB_Y + 30);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(PANEL_X + PANEL_W / 2 + 10, PANEL_Y + PANEL_H);
    ctx.quadraticCurveTo(PANEL_X + PANEL_W / 2 - 40, PANEL_Y + PANEL_H + 80, BULB_X + 20, BULB_Y + 30);
    ctx.stroke();
    ctx.restore();

    // electrons under other elements
    for (const e of electrons) {
      drawElectron(e);
    }

    drawSpark();

    // messages
    ctx.save();
    ctx.textAlign = 'center';
    ctx.font = 'bold 16px sans-serif';
    ctx.fillStyle = '#05323a';
    let mmY = HEIGHT - 40;
    for (const m of messages) {
      ctx.globalAlpha = clamp(m.t / 1200, 0, 1);
      ctx.fillText(m.text, WIDTH / 2, mmY);
      mmY -= 22;
    }
    ctx.globalAlpha = 1;
    ctx.restore();

    // draw UI overlays
    drawUI();

    // bottom instructions: interactive hints
    ctx.save();
    ctx.fillStyle = 'rgba(1,48,52,0.06)';
    roundRect(ctx, 12, HEIGHT - 72, 420, 56, 8);
    ctx.fill();
    ctx.fillStyle = '#025b54';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Tip: Match numbers exactly to light the bulb. Overcharging pops it!', 24, HEIGHT - 44);
    ctx.fillText('Click an electron to drag it or press SPACE near one.', 24, HEIGHT - 24);
    ctx.restore();

    // visual cue for audio events (when glowTime)
    if (glowTime > 0) {
      ctx.save();
      ctx.globalAlpha = clamp(glowTime, 0, 1) * 0.8;
      ctx.fillStyle = '#fff6b3';
      ctx.beginPath();
      ctx.ellipse(BULB_X, BULB_Y - 10, 100 * glowTime, 140 * glowTime, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // show helpful overlay when paused or on instructions
    if (!running) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.46)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 28px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Spark & the Electric Sum', WIDTH / 2, HEIGHT / 2 - 40);
      ctx.font = '18px sans-serif';
      ctx.fillText('Click to start! Use arrow keys, space, enter. S to toggle sound.', WIDTH / 2, HEIGHT / 2 + 4);
      ctx.restore();
    }
  }

  function gameLoop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = Math.min(0.05, (ts - lastTime) / 1000);
    lastTime = ts;
    if (running) update(dt);
    render();
    requestAnimationFrame(gameLoop);
  }

  // -------------------------
  // Input handlers
  // -------------------------
  function onKeyDown(e) {
    // Accessibility: allow starting audio on first user gesture
    safeResumeAudio();
    if (!audioAvailable) {
      // do nothing
    }
    keys[e.key] = true;

    if (e.key === ' ' || e.key === 'Spacebar') {
      e.preventDefault();
      collectNearestElectron();
    } else if (e.key === 'Enter') {
      submitCharge();
    } else if (e.key === 's' || e.key === 'S') {
      audioOn = !audioOn;
      if (!audioOn) stopBackgroundHum();
      else startBackgroundHum();
      glowTime = 0.5;
    } else if (e.key === 'h' || e.key === 'H') {
      showInstructions = !showInstructions;
    } else if (!running) {
      // start game on any other key
      startGame();
    }
  }

  function onKeyUp(e) {
    keys[e.key] = false;
  }

  function onMouseDown(e) {
    safeResumeAudio();
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    mouse.down = true;

    // check if clicked an electron
    for (let i = electrons.length - 1; i >= 0; i--) {
      const el = electrons[i];
      const d = Math.hypot(el.x - mouse.x, el.y - mouse.y);
      if (d <= el.r + 6) {
        mouse.dragElectron = el;
        el.grabbed = false;
        el.beingSent = false;
        return;
      }
    }

    // if clicked start overlay, start
    if (!running) {
      startGame();
    }
  }

  function onMouseMove(e) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    // for keyboard-less users, let spark follow pointer when not dragging electron and mouse pressed
    if (!mouse.down) {
      // no auto-follow to avoid annoyances
    }
  }

  function onMouseUp(e) {
    mouse.down = false;
    // release dragged electron
    if (mouse.dragElectron) {
      // if near panel center, send to panel
      const el = mouse.dragElectron;
      const dx = el.x - (PANEL_X + PANEL_W / 2);
      const dy = el.y - (PANEL_Y + PANEL_H / 2);
      if (Math.hypot(dx, dy) < 54) {
        sendElectronToPanel(el);
      } else {
        // drop where released
      }
      mouse.dragElectron = null;
    }
  }

  // click on canvas for toggles such as sound or instructions
  function onClick(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;

    // detect click on sound icon area
    const sx = WIDTH - 80;
    const sy = 18;
    if (cx >= sx - 4 && cx <= sx + 40 && cy >= sy - 4 && cy <= sy + 64) {
      audioOn = !audioOn;
      if (!audioOn) stopBackgroundHum();
      else startBackgroundHum();
      return;
    }

    // toggle show instructions by clicking the instructions panel
    if (cx >= 16 && cx <= 396 && cy >= 66 && cy <= 186) {
      showInstructions = !showInstructions;
    }
  }

  // -------------------------
  // Game start/stop
  // -------------------------
  function startGame() {
    running = true;
    showInstructions = false;
    lastTime = 0;
    level = Math.max(1, level);
    score = Math.max(0, score);
    resetLevel();
    safeResumeAudio();
    if (audioAvailable && audioOn) startBackgroundHum();
    addMessage('Welcome Spark! Match the number to light the bulb.');
  }

  // initialize and attach events
  canvas.addEventListener('keydown', onKeyDown);
  canvas.addEventListener('keyup', onKeyUp);
  canvas.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('click', onClick);

  // Prevent losing focus on click (for keyboard)
  canvas.addEventListener('blur', function () {
    // clear keys to avoid stuck controls
    for (const k in keys) keys[k] = false;
  });

  // Make sure the canvas is focused for keyboard controls
  canvas.addEventListener('mouseenter', function () {
    canvas.focus();
  });

  // Start rendering loop
  requestAnimationFrame(gameLoop);

  // Helpful startup visual instructions for screen readers / users without canvas access
  try {
    if ('ariaLabel' in canvas) {
      // already set above
    }
  } catch (e) {
    // ignore
  }

  // Small accessibility feature: provide keyboard help if no pointer events or if tabbed
  canvas.addEventListener('focus', function () {
    // show instructions briefly when focused
    showInstructions = true;
    setTimeout(() => {
      showInstructions = false;
    }, 3500);
  });

  // Expose simple API on the canvas element for testing or accessibility tools
  canvas.gameState = {
    get score() {
      return score;
    },
    get level() {
      return level;
    },
    get targetCharge() {
      return targetCharge;
    },
    get currentCharge() {
      return currentCharge;
    }
  };

  // End of game code
})();
---

