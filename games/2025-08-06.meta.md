# Game of the Day - 2025-08-06

## Metadata
- **Generated Date:** 2025-08-06
- **Generated Time:** 2025-08-06T03:17:36.559404
- **Model:** gpt-4.1-mini
- **Theme:** open world exploration
- **Game File:** 2025-08-06.js
- **File Size:** 19816 bytes
- **Tokens Used:** 5958

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: open world exploration

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-4.1-mini model with the theme: "open world exploration".

## Files Generated
- `2025-08-06.js` - The playable game
- `2025-08-06.meta.json` - Machine-readable metadata
- `2025-08-06.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 13810

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 16029

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Math open world exploration game for ages 7-9
// Theme: Exploring a colorful island to collect magic fruit by solving addition problems
// Render inside #game-of-the-day-stage, 720x480 canvas
// Use canvas-only graphics & Web Audio API only (no external assets)
// Keyboard controls, text instructions, visual cues, error handling included

(() => {
  const stage = document.getElementById("game-of-the-day-stage");
  if (!stage) {
    console.error("Element with ID 'game-of-the-day-stage' not found.");
    return;
  }
  const CANVAS_WIDTH = 720;
  const CANVAS_HEIGHT = 480;

  // Clear stage, create canvas
  stage.innerHTML = "";
  const canvas = document.createElement("canvas");
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  canvas.tabIndex = 0; // make focusable for keyboard controls
  canvas.setAttribute("aria-label", "Open world math exploration game");
  stage.appendChild(canvas);

  const ctx = canvas.getContext("2d");

  // Audio setup and helper functions
  let audioCtx;
  try {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
  } catch (e) {
    console.warn("Web Audio API not supported or failed: ", e);
    audioCtx = null;
  }

  // Play sound helpers
  function playTone(freq, duration, type = "sine") {
    if (!audioCtx) return;
    try {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.type = type;
      oscillator.frequency.value = freq;
      gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
      oscillator.start();
      gainNode.gain.exponentialRampToValueAtTime(
        0.0001,
        audioCtx.currentTime + duration
      );
      oscillator.stop(audioCtx.currentTime + duration);
    } catch (e) {
      console.warn("Audio playback error", e);
    }
  }
  function playCorrectSound() {
    // Joyful quick ascending arpeggio
    if (!audioCtx) return;
    try {
      let now = audioCtx.currentTime;
      let freqs = [440, 660, 880, 990];
      freqs.forEach((f, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = "triangle";
        osc.frequency.value = f;
        gain.gain.setValueAtTime(0.12, now + 0.15 * i);
        osc.start(now + 0.15 * i);
        gain.gain.exponentialRampToValueAtTime(
          0.0001,
          now + 0.15 * i + 0.1
        );
        osc.stop(now + 0.15 * i + 0.1);
      });
    } catch (e) {
      console.warn("Correct sound playback error", e);
    }
  }
  function playIncorrectSound() {
    // Single low buzz sound
    if (!audioCtx) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = "square";
      osc.frequency.value = 120;
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
      osc.start();
      gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.4);
      osc.stop(audioCtx.currentTime + 0.4);
    } catch (e) {
      console.warn("Incorrect sound playback error", e);
    }
  }
  function playBackgroundAmbience() {
    if (!audioCtx) return null;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.value = 220;
      gain.gain.setValueAtTime(0.02, audioCtx.currentTime);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      // Slowly vary the frequency for gentle movement
      let freqStart = 210;
      let freqEnd = 230;
      let direction = 1;
      let interval = setInterval(() => {
        if (!audioCtx) return;
        if (direction > 0) {
          freqStart += 0.2;
          if (freqStart >= freqEnd) direction = -1;
        } else {
          freqStart -= 0.2;
          if (freqStart <= 210) direction = 1;
        }
        osc.frequency.setValueAtTime(freqStart, audioCtx.currentTime);
      }, 200);
      return {
        stop: () => {
          clearInterval(interval);
          osc.stop();
        }
      };
    } catch (e) {
      console.warn("Background ambience error", e);
      return null;
    }
  }

  // Game variables and constants
  const TILE_SIZE = 48;
  const ROWS = 10;
  const COLS = 15;

  // Player variables
  const player = {
    x: 1,
    y: 1,
    color: "#FF7F50", // coral orange
    radius: 18,
    speed: 1,
  };
  // Character name: "Zappy" - a quirky electric parrot explorer
  // Zappy's tail feathers crackle with tiny lightning bolts occasionally

  // Magic fruits scattered on island, each with an addition problem displayed
  // Player collects fruit by answering addition questions to unlock them.

  // Fruit types/colors/colors will be whimsical
  const fruitTypes = [
    { name: "Mystic Mango", color: "#F4C430" },  // bright golden yellow
    { name: "Rainbow Berry", color: "#9B30FF" },  // electric purple
    { name: "Bubble Banana", color: "#FFE135" },  // pale bright yellow
    { name: "Tickle Tomato", color: "#FF6347" },  // soft red orange
  ];

  // Island map array: 2D grid where 0 = empty grass, 1 = tree obstacle, 2 = fruit
  // Create a simple island with scattered trees and fruits
  const islandMap = [];
  for (let r = 0; r < ROWS; r++) {
    islandMap[r] = [];
    for (let c = 0; c < COLS; c++) {
      if (r === 0 || r === ROWS-1 || c === 0 || c === COLS-1) {
        islandMap[r][c] = 1; // border trees
      } else {
        islandMap[r][c] = 0; // start empty grass
      }
    }
  }
  // Add some random tree obstacles inside island (15 trees)
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  let treeCount = 0;
  while (treeCount < 15) {
    let r = getRandomInt(2, ROWS - 3);
    let c = getRandomInt(2, COLS - 3);
    if (islandMap[r][c] === 0 && (r !== player.y || c !== player.x)) {
      islandMap[r][c] = 1;
      treeCount++;
    }
  }
  // Add fruit positions with math problems
  // 8 fruits randomly positioned, no conflicts with trees or player start
  const fruits = [];
  while (fruits.length < 8) {
    let r = getRandomInt(1, ROWS - 2);
    let c = getRandomInt(1, COLS - 2);
    if (
      islandMap[r][c] === 0 &&
      !(r === player.y && c === player.x) &&
      !fruits.some(f => f.x === c && f.y === r)
    ) {
      // Add random addition problem 2-digit + 1-digit sums to age-appropriate
      let addend1 = getRandomInt(5, 20);
      let addend2 = getRandomInt(1, 9);
      fruits.push({
        x: c,
        y: r,
        type: fruitTypes[getRandomInt(0, fruitTypes.length - 1)],
        question: `${addend1} + ${addend2}`,
        answer: addend1 + addend2,
        collected: false,
      });
      islandMap[r][c] = 2; // mark fruit presence
    }
  }

  // Track game state
  let inputAnswer = "";
  let currentFruit = null; // fruit player is answering for
  let message = "Explore the island! Use arrow keys to move. Collect magic fruit by solving addition.";
  let showMessageTimer = 0;
  const SHOW_MESSAGE_DURATION = 4000;
  const collectedCount = { count: 0 };

  // Keyboard input handling
  const keys = {};
  canvas.addEventListener("keydown", e => {
    e.preventDefault();
    keys[e.key] = true;
    if (e.key === "Enter" || e.key === "NumpadEnter") {
      if (currentFruit) {
        checkAnswer();
      }
    }
    if (e.key === "Backspace") {
      if (currentFruit) {
        inputAnswer = inputAnswer.slice(0, -1);
      }
    }
    if (currentFruit && /^[0-9]$/.test(e.key)) {
      // Allow numbers input (only digits)
      inputAnswer += e.key;
      if (inputAnswer.length > 3) inputAnswer = inputAnswer.slice(0, 3); // limit input length
    }
  });
  canvas.addEventListener("keyup", e => {
    e.preventDefault();
    keys[e.key] = false;
  });

  // Check if move is possible (no trees, within borders)
  function canMoveTo(x, y) {
    if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
    if (islandMap[y][x] === 1) return false;
    return true;
  }

  // Check if tile has collectible fruit
  function getFruitAt(x, y) {
    for (const f of fruits) {
      if (f.x === x && f.y === y && !f.collected) return f;
    }
    return null;
  }

  // Check player's current tile and possibly trigger question mode
  function checkForFruitCollection() {
    if (currentFruit) return; // already in question mode
    const f = getFruitAt(player.x, player.y);
    if (f) {
      currentFruit = f;
      inputAnswer = "";
      message = `Solve: ${f.question} = ? (type answer and press Enter)`;
      playTone(660, 0.15, "square"); // playful chime to indicate question start
      showMessageTimer = SHOW_MESSAGE_DURATION;
    }
  }

  // Check submitted answer
  function checkAnswer() {
    if (!currentFruit) return;
    const submitted = Number(inputAnswer);
    if (isNaN(submitted)) {
      // Invalid input
      message = "Please enter a number.";
      playIncorrectSound();
      showMessageTimer = SHOW_MESSAGE_DURATION;
      inputAnswer = "";
      return;
    }
    if (submitted === currentFruit.answer) {
      // Correct
      currentFruit.collected = true;
      collectedCount.count++;
      message = `Correct! You collected the ${currentFruit.type.name}! Total fruits: ${collectedCount.count}/8`;
      playCorrectSound();
      currentFruit = null;
      inputAnswer = "";
      showMessageTimer = SHOW_MESSAGE_DURATION;
      if (collectedCount.count === fruits.length) {
        message = "Wow! You collected all the magic fruit! You are the island hero!";
      }
    } else {
      // Incorrect
      message = "Oops, try again!";
      playIncorrectSound();
      showMessageTimer = SHOW_MESSAGE_DURATION;
      inputAnswer = "";
    }
  }

  // Draw a wacky, calming grass tile with some gentle curves and colors
  function drawGrassTile(x, y) {
    ctx.fillStyle = "#A2D149"; // soft grass green
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
    // Draw some gentle waving blades or dots
    for (let i = 0; i < 3; i++) {
      let cx = x + 5 + i * 12 + (Math.sin(Date.now() / 400 + i) * 2);
      let cy = y + 40 + Math.cos(Date.now() / 400 + i) * 2;
      ctx.beginPath();
      ctx.strokeStyle = "#7BAE2F";
      ctx.lineWidth = 2;
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx, cy - 10);
      ctx.stroke();
    }
  }

  // Draw a stylized tree obstacle - thick trunk plus spiky leaves blob in calming blue-green hues
  function drawTreeTile(x, y) {
    // Draw trunk
    ctx.fillStyle = "#6B4226";
    ctx.fillRect(x + 18, y + 28, 12, 20);
    // Draw leaves blob - large dark turquoise circle with spikes
    ctx.fillStyle = "#397D6A";
    ctx.beginPath();
    ctx.ellipse(x + 24, y + 20, 18, 22, 0, 0, Math.PI * 2);
    ctx.fill();
    // Spikes
    for (let i = 0; i < 10; i++) {
      let angle = (Math.PI * 2 / 10) * i;
      let spikeX = x + 24 + Math.cos(angle) * 18;
      let spikeY = y + 20 + Math.sin(angle) * 22;
      ctx.beginPath();
      ctx.moveTo(spikeX, spikeY);
      ctx.lineTo(
        spikeX + Math.cos(angle) * 5,
        spikeY + Math.sin(angle) * 5
      );
      ctx.lineTo(
        spikeX + Math.cos(angle + 0.1) * 2,
        spikeY + Math.sin(angle + 0.1) * 2
      );
      ctx.fill();
    }
  }

  // Draw a magic fruit with wacky shapes depending on type (fruit color)
  function drawFruit(x, y, color) {
    // Draw round fruit base
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(x + TILE_SIZE / 2, y + TILE_SIZE / 2, 15, 20, 0, 0, Math.PI * 2);
    ctx.fill();
    // Add some whimsical spots/stripes unique per fruit color
    ctx.fillStyle = "rgba(255,255,255,0.3)";
    for (let i = 0; i < 4; i++) {
      let offsetX = Math.sin(Date.now() / 300 + i) * 4;
      let offsetY = Math.cos(Date.now() / 350 + i) * 3;
      ctx.beginPath();
      ctx.ellipse(
        x + TILE_SIZE / 2 + offsetX,
        y + TILE_SIZE / 2 + offsetY,
        3,
        5,
        Math.PI / 6,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }
  }

  // Draw the player character "Zappy" the electric parrot
  function drawPlayer() {
    const px = player.x * TILE_SIZE + TILE_SIZE / 2;
    const py = player.y * TILE_SIZE + TILE_SIZE / 2;

    // Body circle
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(px, py, player.radius, 0, Math.PI * 2);
    ctx.fill();

    // Eyes - big and curious
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(px - 8, py - 5, 8, 0, Math.PI * 2);
    ctx.arc(px + 8, py - 5, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(px - 8, py - 5, 4, 0, Math.PI * 2);
    ctx.arc(px + 8, py - 5, 4, 0, Math.PI * 2);
    ctx.fill();

    // Beak - triangle yellow
    ctx.fillStyle = "#FFE066";
    ctx.beginPath();
    ctx.moveTo(px, py + 6);
    ctx.lineTo(px + 16, py + 4);
    ctx.lineTo(px, py + 14);
    ctx.closePath();
    ctx.fill();

    // Tail - 3 crackling feathers with tiny motion & occasional lightning bolt animation
    const time = Date.now() / 300;
    const tailStartX = px - 20;
    const tailStartY = py + 10;
    for (let i = 0; i < 3; i++) {
      let baseX = tailStartX - i * 10;
      let baseY = tailStartY + Math.sin(time + i) * 4;
      ctx.strokeStyle = "#ffec99";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(baseX - 20, baseY + 10);
      ctx.stroke();

      // Occasionally flash a tiny lightning bolt on tail feathers
      if (Math.random() < 0.02) {
        ctx.strokeStyle = "#FFFF00";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(baseX - 10, baseY + 2);
        ctx.lineTo(baseX - 15, baseY + 10);
        ctx.lineTo(baseX - 5, baseY + 7);
        ctx.lineTo(baseX - 12, baseY + 18);
        ctx.stroke();
      }
    }
  }

  // Draw math question input box
  function drawInputBox() {
    if (!currentFruit) return;
    const boxWidth = 280;
    const boxHeight = 80;
    const x = (CANVAS_WIDTH - boxWidth) / 2;
    const y = CANVAS_HEIGHT - boxHeight - 30;

    // Background rectangle
    ctx.fillStyle = "rgba(50, 150, 250, 0.8)";
    ctx.strokeStyle = "white";
    ctx.lineWidth = 4;
    ctx.fillRect(x, y, boxWidth, boxHeight);
    ctx.strokeRect(x, y, boxWidth, boxHeight);

    // Prompt text
    ctx.fillStyle = "white";
    ctx.font = "22px Comic Sans MS, cursive, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(`Solve: ${currentFruit.question}`, x + boxWidth / 2, y + 30);

    // Input text with blinking cursor
    ctx.font = "28px Arial, sans-serif";
    const displayText = inputAnswer + (Math.floor(Date.now() / 500) % 2 === 0 ? "|" : "");
    ctx.fillText(displayText, x + boxWidth / 2, y + 65);
  }

  // Draw collected fruit count in top left
  function drawHUD() {
    ctx.fillStyle = "#222";
    ctx.font = "20px Arial, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Magic fruits collected: ${collectedCount.count} / ${fruits.length}`, 12, 28);
    // Display current message below
    ctx.fillStyle = "#004080";
    ctx.font = "18px Comic Sans MS, cursive";
    ctx.textAlign = "center";
    ctx.fillText(message, CANVAS_WIDTH / 2, CANVAS_HEIGHT - 8);
  }

  // Draw entire map + objects + player
  function draw() {
    // Clear entire canvas with sky blue background
    ctx.fillStyle = "#9BD3E5"; // calming sky blue
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw island sand "beach" around island edges as beige stripes
    ctx.fillStyle = "#F6E7B4";
    ctx.fillRect(0, 0, CANVAS_WIDTH, TILE_SIZE);
    ctx.fillRect(0, CANVAS_HEIGHT - TILE_SIZE, CANVAS_WIDTH, TILE_SIZE);
    ctx.fillRect(0, 0, TILE_SIZE, CANVAS_HEIGHT);
    ctx.fillRect(CANVAS_WIDTH - TILE_SIZE, 0, TILE_SIZE, CANVAS_HEIGHT);

    // Draw island terrain tiles (grass, trees, fruits)
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const x = c * TILE_SIZE;
        const y = r * TILE_SIZE;
        if (islandMap[r][c] === 0) {
          drawGrassTile(x, y);
        } else if (islandMap[r][c] === 1) {
          drawTreeTile(x, y);
        } else if (islandMap[r][c] === 2) {
          // Draw grass as base
          drawGrassTile(x, y);
          // Draw fruit if not collected
          const fruit = getFruitAt(c, r);
          if (fruit) {
            drawFruit(x, y, fruit.type.color);
          }
        }
      }
    }

    // Draw player on top
    drawPlayer();

    // Draw input box if answering question
    drawInputBox();

    // Draw HUD info
    drawHUD();

    // Visual cue for audio on/off: show icon top right corner
    drawAudioIcon();
  }

  // Draw audio icon: speaker shape with waves if audio context running
  function drawAudioIcon() {
    const size = 28;
    const margin = 12;
    const x = CANVAS_WIDTH - size - margin;
    const y = margin + size / 2;

    ctx.lineWidth = 2;
    ctx.strokeStyle = "#555";
    ctx.fillStyle = "#99ccff";

    // Speaker base
    ctx.beginPath();
    ctx.moveTo(x - 10, y + 10);
    ctx.lineTo(x, y + 10);
    ctx.lineTo(x + 10, y);
    ctx.lineTo(x, y - 10);
    ctx.lineTo(x - 10, y - 10);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    if (audioCtx && audioCtx.state === "running") {
      // Draw sound waves (arcs)
      ctx.beginPath();
      ctx.strokeStyle = "#33aa33";
      ctx.arc(x + 14, y, 6, -Math.PI / 4, Math.PI / 4);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(x + 18, y, 10, -Math.PI / 6, Math.PI / 6);
      ctx.stroke();
    } else {
      // Draw muted cross
      ctx.strokeStyle = "red";
      ctx.beginPath();
      ctx.moveTo(x - 12, y - 12);
      ctx.lineTo(x + 18, y + 12);
      ctx.moveTo(x + 18, y - 12);
      ctx.lineTo(x - 12, y + 12);
      ctx.stroke();
    }
  }

  // Game loop and update movement
  let lastTime = 0;
  function update(delta) {
    // Movement handling - simple grid movement
    let moved = false;
    if (!currentFruit) {
      if (keys["ArrowUp"] && canMoveTo(player.x, player.y - 1)) {
        player.y -= player.speed;
        moved = true;
        keys["ArrowUp"] = false; // single move per key press
      }
      if (keys["ArrowDown"] && canMoveTo(player.x, player.y + 1)) {
        player.y += player.speed;
        moved = true;
        keys["ArrowDown"] = false;
      }
      if (keys["ArrowLeft"] && canMoveTo(player.x - 1, player.y)) {
        player.x -= player.speed;
        moved = true;
        keys["ArrowLeft"] = false;
      }
      if (keys["ArrowRight"] && canMoveTo(player.x + 1, player.y)) {
        player.x += player.speed;
        moved = true;
        keys["ArrowRight"] = false;
      }
    }

    if (moved) {
      message = "Keep exploring and collecting magic fruit!";
      showMessageTimer = SHOW_MESSAGE_DURATION;
      checkForFruitCollection();
    }

    if (showMessageTimer > 0) {
      showMessageTimer -= delta;
      if (showMessageTimer <= 0) {
        message = "";
      }
    }
  }

  // Main loop
  function loop(time = 0) {
    const delta = time - lastTime;
    lastTime = time;

    update(delta);
    draw();

    requestAnimationFrame(loop);
  }

  canvas.focus();

  // Start gentle background ambience sound
  const bgAmbience = playBackgroundAmbience();

  // Pause/resume audio context on first interaction if needed
  function resumeAudioContext() {
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume();
    }
  }
  window.addEventListener("keydown", resumeAudioContext);
  window.addEventListener("mousedown", resumeAudioContext);
  window.addEventListener("touchstart", resumeAudioContext);

  loop();
})();
---

