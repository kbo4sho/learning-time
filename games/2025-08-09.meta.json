{
  "generated_date": "2025-08-09",
  "generated_timestamp": "2025-08-09T00:21:14.535301",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8749,
  "game_filename": "2025-08-09.js",
  "game_size_bytes": 25464,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Electricity-themed Math Game for ages 7-9\n  // Renders entirely inside element with id \"game-of-the-day-stage\"\n  // Uses canvas-only graphics and Web Audio API generated sounds\n  // Keyboard accessible and includes error handling for audio and resources\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const BUBBLE_RADIUS = 20;\n  const BULB_COUNT = 4;\n  const START_LIVES = 3;\n  const TARGET_MIN = 6;\n  const TARGET_MAX = 14;\n  const SPAWN_INTERVAL_MS = 1500; // starting spawn pace\n  const DIFFICULTY_INCREASE_EVERY = 15000; // ms\n  const MAX_BUBBLE_VALUE = 5; // values 1..5\n\n  // Colors (calming and wacky palette)\n  const COLORS = {\n    bg: \"#E8F6FF\",\n    panel: \"#F4FAFF\",\n    bolt: \"#FFD166\",\n    spark: \"#60D394\",\n    bulbOff: \"#E0E6EE\",\n    bulbOn: \"#FFF9B1\",\n    text: \"#05386B\",\n    wrong: \"#FF6B6B\",\n    correct: \"#2ECC71\",\n    collector: \"#6D9BF1\",\n    bubbleFill: \"#9ED9CC\",\n    battery: \"#FFD166\",\n  };\n\n  // Elements and Canvas\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"No container with id 'game-of-the-day-stage' found.\");\n    return;\n  }\n\n  // Create accessible instructions area for screen readers\n  const srInstructions = document.createElement(\"div\");\n  srInstructions.setAttribute(\"aria-live\", \"polite\");\n  srInstructions.style.position = \"absolute\";\n  srInstructions.style.left = \"-9999px\";\n  srInstructions.style.width = \"1px\";\n  srInstructions.style.height = \"1px\";\n  srInstructions.style.overflow = \"hidden\";\n  srInstructions.id = \"game-of-the-day-sr\";\n  srInstructions.innerText =\n    \"Electric Math: Move the collector with arrow keys or mouse. Catch number charges and press 1-4 to send them to matching bulbs. Match sums exactly to light bulbs.\";\n  container.appendChild(srInstructions);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Electric Math game canvas\");\n  canvas.style.display = \"block\";\n  canvas.style.background = COLORS.bg;\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let audioEnabled = true;\n  try {\n    const AC = window.AudioContext || window.webkitAudioContext;\n    if (!AC) {\n      throw new Error(\"Web Audio API not supported in this browser.\");\n    }\n    audioCtx = new AC();\n  } catch (err) {\n    console.warn(\"Audio unavailable:\", err.message);\n    audioEnabled = false;\n    audioCtx = null;\n  }\n\n  // State\n  let lastTime = performance.now();\n  let spawnTimer = 0;\n  let spawnInterval = SPAWN_INTERVAL_MS;\n  let difficultyTimer = 0;\n  let running = false;\n  let muted = !audioEnabled; // if audio unavailable, control muted state\n  let score = 0;\n  let lives = START_LIVES;\n  let level = 1;\n  let bulbs = [];\n  let bubbles = [];\n  let collector = {\n    x: WIDTH / 2,\n    y: HEIGHT - 80,\n    width: 120,\n    height: 40,\n    speed: 300, // pixels per second\n    carrying: null, // holds bubble reference\n  };\n  let keys = {};\n  let lastSpawnId = 0;\n  let messages = []; // floating text messages\n\n  // Accessibility: announce function\n  function announce(text) {\n    srInstructions.innerText = text;\n  }\n\n  // Create initial bulbs\n  function initBulbs() {\n    bulbs = [];\n    const padding = 40;\n    const usableWidth = WIDTH - padding * 2;\n    const spacing = usableWidth / BULB_COUNT;\n    for (let i = 0; i < BULB_COUNT; i++) {\n      const target = randInt(TARGET_MIN, TARGET_MAX);\n      bulbs.push({\n        id: i + 1,\n        x: padding + spacing * i + spacing / 2,\n        y: HEIGHT - 160,\n        radius: 36,\n        current: 0,\n        target: target,\n        lit: false,\n        overloaded: false,\n      });\n    }\n  }\n\n  // Utility functions\n  function rand(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n  function randInt(min, max) {\n    return Math.floor(rand(min, max + 1));\n  }\n\n  // Bubble creation\n  function spawnBubble() {\n    const x = rand(40, WIDTH - 40);\n    const val = randInt(1, MAX_BUBBLE_VALUE);\n    const id = ++lastSpawnId;\n    bubbles.push({\n      id,\n      x,\n      y: -BUBBLE_RADIUS,\n      vy: rand(30, 60) + level * 5,\n      radius: BUBBLE_RADIUS,\n      value: val,\n      caught: false,\n      targetBulb: null,\n      returning: false,\n    });\n  }\n\n  // Audio helper functions with safe checks\n  function safeCreateGain() {\n    if (!audioCtx) return null;\n    try {\n      return audioCtx.createGain();\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function playBeep(type = \"correct\") {\n    if (muted || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      let freq = 660;\n      let dur = 0.18;\n      if (type === \"correct\") {\n        freq = 880;\n        dur = 0.22;\n        osc.type = \"sine\";\n      } else if (type === \"wrong\") {\n        freq = 150;\n        dur = 0.24;\n        osc.type = \"square\";\n      } else if (type === \"pickup\") {\n        freq = 520;\n        dur = 0.12;\n        osc.type = \"triangle\";\n      } else if (type === \"light\") {\n        freq = 1200;\n        dur = 0.26;\n        osc.type = \"sine\";\n      } else if (type === \"spark\") {\n        freq = 1000;\n        dur = 0.08;\n        osc.type = \"sawtooth\";\n      }\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);\n      osc.frequency.setValueAtTime(freq, now);\n      osc.connect(gain);\n      gain.connect(audioCtx.destination);\n      osc.start(now);\n      osc.stop(now + dur + 0.05);\n    } catch (err) {\n      console.warn(\"Sound playback failed:\", err);\n    }\n  }\n\n  // Gentle background hum using oscillator - resumed on user gesture\n  let humOsc = null;\n  function startBackgroundHum() {\n    if (muted || !audioCtx) return;\n    if (humOsc) return;\n    try {\n      humOsc = audioCtx.createOscillator();\n      const humGain = audioCtx.createGain();\n      humOsc.type = \"sine\";\n      humOsc.frequency.value = 60;\n      humGain.gain.value = 0.01;\n      // slight detune movement\n      humOsc.connect(humGain);\n      humGain.connect(audioCtx.destination);\n      humOsc.start();\n    } catch (err) {\n      console.warn(\"Background hum failed:\", err);\n      humOsc = null;\n    }\n  }\n  function stopBackgroundHum() {\n    if (humOsc) {\n      try {\n        humOsc.stop();\n      } catch (e) {}\n      humOsc = null;\n    }\n  }\n\n  // Input handling\n  document.addEventListener(\"keydown\", (e) => {\n    keys[e.key] = true;\n\n    // Allow space for pickup in addition to automatic grab\n    if (e.key === \" \" || e.key === \"Spacebar\") {\n      // attempt to pick up nearest bubble if in range\n      attemptPickup();\n      e.preventDefault();\n    }\n\n    // Send carried bubble to bulb 1-4\n    if ([\"1\", \"2\", \"3\", \"4\"].includes(e.key)) {\n      const bulbIndex = Number(e.key) - 1;\n      sendToBulb(bulbIndex);\n    }\n\n    // mute toggle\n    if (e.key.toLowerCase() === \"m\") {\n      toggleMute();\n    }\n\n    // Start sounds on first user gesture\n    if (!running) {\n      startGame();\n    }\n  });\n  document.addEventListener(\"keyup\", (e) => {\n    keys[e.key] = false;\n  });\n\n  // Mouse\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    collector.x = Math.min(\n      WIDTH - collector.width / 2,\n      Math.max(collector.width / 2, e.clientX - rect.left)\n    );\n  });\n  canvas.addEventListener(\"click\", (e) => {\n    // click to start or pick up\n    if (!running) {\n      startGame();\n      return;\n    }\n    // on click while carrying bubble, choose bulb by clicking near it\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    for (let i = 0; i < bulbs.length; i++) {\n      const b = bulbs[i];\n      const dx = x - b.x;\n      const dy = y - b.y;\n      if (dx * dx + dy * dy <= (b.radius + 10) * (b.radius + 10)) {\n        sendToBulb(i);\n        return;\n      }\n    }\n    // otherwise attempt to pick up if near\n    attemptPickup();\n  });\n\n  // Game actions\n  function attemptPickup() {\n    if (collector.carrying) return;\n    for (let bub of bubbles) {\n      if (bub.caught || bub.returning) continue;\n      // detect overlap with collector box\n      const withinX = bub.x >= collector.x - collector.width / 2 - bub.radius &&\n        bub.x <= collector.x + collector.width / 2 + bub.radius;\n      const withinY = bub.y + bub.radius >= collector.y - collector.height / 2 &&\n        bub.y - bub.radius <= collector.y + collector.height / 2;\n      if (withinX && withinY) {\n        bub.caught = true;\n        collector.carrying = bub;\n        playBeep(\"pickup\");\n        announce(`Picked up a ${bub.value} charge. Press 1 to 4 to send to a bulb.`);\n        break;\n      }\n    }\n  }\n\n  function sendToBulb(index) {\n    if (!collector.carrying) {\n      announce(\"No charge to send. Move to a falling charge and catch it.\");\n      return;\n    }\n    if (index < 0 || index >= bulbs.length) return;\n    const bub = collector.carrying;\n    bub.caught = false;\n    bub.returning = true;\n    bub.targetBulb = index;\n    // set velocity to move towards bulb\n    const b = bulbs[index];\n    const dx = b.x - bub.x;\n    const dy = b.y - bub.y;\n    const dist = Math.hypot(dx, dy);\n    const travelTime = 0.5; // seconds\n    bub.vx = dx / travelTime;\n    bub.vy = dy / travelTime;\n    collector.carrying = null;\n    playBeep(\"spark\");\n    announce(`Sent a ${bub.value} charge to bulb ${index + 1}.`);\n  }\n\n  // Game start and reset\n  function startGame() {\n    running = true;\n    score = 0;\n    lives = START_LIVES;\n    level = 1;\n    spawnInterval = SPAWN_INTERVAL_MS;\n    difficultyTimer = 0;\n    messages = [];\n    initBulbs();\n    bubbles = [];\n    collector.x = WIDTH / 2;\n    collector.carrying = null;\n    lastTime = performance.now();\n    spawnTimer = 0;\n    lastSpawnId = 0;\n    muted = muted && !audioCtx ? true : muted; // keep disabled if no audio\n    // resume audio context on user gesture if available\n    if (audioCtx && audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((err) => {\n        console.warn(\"AudioContext resume failed:\", err);\n      });\n    }\n    if (audioCtx) startBackgroundHum();\n    announce(\"Game started. Catch charges and send to bulbs to light them.\");\n    requestAnimationFrame(loop);\n  }\n\n  // End game\n  function endGame(win = false) {\n    running = false;\n    stopBackgroundHum();\n    if (win) {\n      announce(`Congratulations! You lit all the bulbs. Score ${score}. Press any key to play again.`);\n      playBeep(\"light\");\n    } else {\n      announce(`Game over. Score ${score}. Press any key to try again.`);\n    }\n  }\n\n  // Message system for floating text\n  function pushMessage(text, x, y, color = COLORS.text) {\n    messages.push({\n      text,\n      x,\n      y,\n      life: 2000,\n      created: performance.now(),\n      color,\n    });\n  }\n\n  // Update and draw loop\n  function loop(ts) {\n    const dt = Math.min(50, ts - lastTime) / 1000; // delta seconds, clamp\n    lastTime = ts;\n    if (!running) {\n      // draw static screen with instructions\n      drawIntro();\n      return;\n    }\n    // Update timers\n    spawnTimer += dt * 1000;\n    difficultyTimer += dt * 1000;\n\n    if (difficultyTimer >= DIFFICULTY_INCREASE_EVERY) {\n      difficultyTimer = 0;\n      level++;\n      spawnInterval = Math.max(600, spawnInterval - 120);\n      pushMessage(`Level ${level}! Bubbles fall faster.`, WIDTH / 2, 60, COLORS.spark);\n    }\n\n    if (spawnTimer >= spawnInterval) {\n      spawnTimer = 0;\n      spawnBubble();\n    }\n\n    // Move collector with keyboard\n    if (keys[\"ArrowLeft\"] || keys[\"a\"]) {\n      collector.x -= collector.speed * dt;\n    }\n    if (keys[\"ArrowRight\"] || keys[\"d\"]) {\n      collector.x += collector.speed * dt;\n    }\n    // clamp\n    collector.x = Math.max(collector.width / 2, Math.min(WIDTH - collector.width / 2, collector.x));\n\n    // Update bubbles\n    for (let i = bubbles.length - 1; i >= 0; i--) {\n      const b = bubbles[i];\n      if (b.caught && b !== collector.carrying) {\n        // should not happen, but fix\n        b.caught = false;\n      }\n      if (b.caught && b === collector.carrying) {\n        // follow collector\n        b.x = collector.x;\n        b.y = collector.y - collector.height / 2 - b.radius - 4;\n      } else if (b.returning && b.targetBulb != null) {\n        // move to bulb location\n        const tb = bulbs[b.targetBulb];\n        // simple linear movement using vx, vy\n        // Convert vx, vy per second to per dt\n        b.x += b.vx * dt;\n        b.y += b.vy * dt;\n        // check arrival\n        const dx = b.x - tb.x;\n        const dy = b.y - tb.y;\n        if (Math.hypot(dx, dy) < tb.radius + b.radius) {\n          // arrive\n          b.returning = false;\n          b.vx = 0;\n          b.vy = 0;\n          resolveBubbleArrival(b, tb);\n          // remove bubble from array\n          bubbles.splice(i, 1);\n        }\n      } else {\n        // falling normally\n        b.y += b.vy * dt;\n      }\n\n      // if off-screen bottom (not caught), lose life\n      if (b.y - b.radius > HEIGHT + 40) {\n        // remove\n        if (b.caught) {\n          collector.carrying = null;\n        }\n        bubbles.splice(i, 1);\n        // penalty: lose life\n        lives--;\n        pushMessage(\"Missed!\", WIDTH / 2, 80, COLORS.wrong);\n        playBeep(\"wrong\");\n        announce(`You missed a charge. Lives remaining ${lives}.`);\n        if (lives <= 0) {\n          endGame(false);\n          return;\n        }\n      }\n    }\n\n    // Update messages\n    const now = performance.now();\n    messages = messages.filter((m) => now - m.created < m.life);\n\n    // Check win: all bulbs lit\n    if (bulbs.every((b) => b.lit)) {\n      endGame(true);\n      return;\n    }\n\n    // Draw everything\n    draw();\n\n    requestAnimationFrame(loop);\n  }\n\n  function resolveBubbleArrival(bubble, bulb) {\n    // Add bubble value to bulb\n    bulb.current += bubble.value;\n    // Visual feedback and sounds\n    if (bulb.current === bulb.target) {\n      bulb.lit = true;\n      bulb.overloaded = false;\n      score += 10;\n      pushMessage(\"Perfect! Bulb lit.\", bulb.x, bulb.y - 60, COLORS.correct);\n      playBeep(\"light\");\n      announce(`Bulb ${bulb.id} lit! Good job. Score ${score}.`);\n    } else if (bulb.current < bulb.target) {\n      score += 1;\n      pushMessage(`+${bubble.value}`, bulb.x, bulb.y - 30, COLORS.spark);\n      playBeep(\"correct\");\n      announce(`Added ${bubble.value} to bulb ${bulb.id}. It now has ${bulb.current} of ${bulb.target}.`);\n    } else {\n      // overload\n      bulb.overloaded = true;\n      bulb.lit = false;\n      score = Math.max(0, score - 3);\n      lives = Math.max(0, lives - 1);\n      pushMessage(\"Overloaded!\", bulb.x, bulb.y - 50, COLORS.wrong);\n      playBeep(\"wrong\");\n      announce(`Oh no! Bulb ${bulb.id} overloaded. Lives ${lives}.`);\n      // reset bulb after small delay\n      setTimeout(() => {\n        bulb.current = 0;\n        bulb.overloaded = false;\n      }, 900);\n      if (lives <= 0) {\n        endGame(false);\n      }\n    }\n  }\n\n  // Drawing functions\n  function draw() {\n    // background\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawBackground();\n\n    // top panel with characters and text\n    drawTopPanel();\n\n    // bulbs\n    for (let i = 0; i < bulbs.length; i++) {\n      drawBulb(bulbs[i], i);\n      // number label (1-4) for keyboard reference\n      ctx.save();\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"16px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(`(${i + 1})`, bulbs[i].x, bulbs[i].y + bulbs[i].radius + 22);\n      ctx.restore();\n    }\n\n    // bubbles\n    for (let b of bubbles) {\n      drawBubble(b);\n    }\n\n    // collector\n    drawCollector();\n\n    // HUD: score, lives, instructions\n    drawHUD();\n\n    // messages\n    drawMessages();\n  }\n\n  function drawBackground() {\n    // gentle gradient (calming)\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#E8F6FF\");\n    g.addColorStop(1, \"#F8FFFF\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // soft wavy circuits doodles\n    ctx.save();\n    ctx.globalAlpha = 0.12;\n    ctx.strokeStyle = COLORS.bolt;\n    ctx.lineWidth = 3;\n    for (let i = 0; i < 6; i++) {\n      ctx.beginPath();\n      const y = 40 + i * 70;\n      ctx.moveTo(20, y);\n      ctx.bezierCurveTo(160, y - 20, 300, y + 40, WIDTH - 20, y);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawTopPanel() {\n    // Left character: Sparky the squirrel battery friend\n    drawSparky(80, 100);\n\n    // Right character: Volt the friendly robot\n    drawVolt(WIDTH - 110, 100);\n\n    // Title and instructions\n    ctx.save();\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"24px Comic Sans MS, Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Electric Math: Charge the Bulbs!\", WIDTH / 2, 50);\n\n    ctx.font = \"14px Arial\";\n    ctx.fillStyle = \"#27496D\";\n    ctx.fillText(\n      \"Catch numbered charges and press 1-4 to send them to bulbs. Match the sums exactly to light them!\",\n      WIDTH / 2,\n      72\n    );\n\n    // audio indicator\n    ctx.fillStyle = muted ? COLORS.wrong : COLORS.correct;\n    ctx.beginPath();\n    ctx.arc(WIDTH - 30, 30, 10, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.font = \"12px Arial\";\n    ctx.fillStyle = \"#fff\";\n    ctx.fillText(muted ? \"M\" : \"S\", WIDTH - 30, 34);\n    ctx.restore();\n  }\n\n  function drawSparky(cx, cy) {\n    // Cute battery-squirrel hybrid\n    ctx.save();\n    // body\n    ctx.fillStyle = COLORS.battery;\n    roundRect(ctx, cx - 36, cy - 28, 72, 56, 12);\n    ctx.fill();\n\n    // face\n    ctx.fillStyle = \"#FFF\";\n    circle(ctx, cx - 6, cy - 6, 10);\n    circle(ctx, cx + 14, cy - 6, 10);\n    // eyes\n    ctx.fillStyle = \"#05386B\";\n    circle(ctx, cx - 8, cy - 6, 3);\n    circle(ctx, cx + 12, cy - 6, 3);\n    // smile\n    ctx.strokeStyle = \"#05386B\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(cx + 3, cy + 2, 8, 0.1 * Math.PI, 0.9 * Math.PI);\n    ctx.stroke();\n\n    // tail (wacky spark tail)\n    ctx.fillStyle = COLORS.spark;\n    ctx.beginPath();\n    ctx.moveTo(cx - 40, cy + 8);\n    ctx.quadraticCurveTo(cx - 70, cy - 30, cx - 30, cy - 40);\n    ctx.quadraticCurveTo(cx - 10, cy - 20, cx - 20, cy - 10);\n    ctx.fill();\n\n    // little bolt on battery\n    ctx.fillStyle = COLORS.bolt;\n    ctx.beginPath();\n    ctx.moveTo(cx + 20, cy + 8);\n    ctx.lineTo(cx + 10, cy + 2);\n    ctx.lineTo(cx + 16, cy + 2);\n    ctx.lineTo(cx + 6, cy - 8);\n    ctx.lineTo(cx + 22, cy + 6);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawVolt(cx, cy) {\n    // Friendly robot with antenna spark\n    ctx.save();\n    // head\n    ctx.fillStyle = \"#DDEBFF\";\n    roundRect(ctx, cx - 30, cy - 34, 60, 44, 8);\n    ctx.fill();\n\n    // eyes\n    ctx.fillStyle = \"#05386B\";\n    circle(ctx, cx - 10, cy - 14, 5);\n    circle(ctx, cx + 10, cy - 14, 5);\n\n    // antenna\n    ctx.strokeStyle = COLORS.bolt;\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(cx, cy - 34);\n    ctx.lineTo(cx, cy - 52);\n    ctx.stroke();\n    ctx.fillStyle = COLORS.spark;\n    circle(ctx, cx, cy - 56, 6);\n\n    // body\n    ctx.fillStyle = \"#BEE3F8\";\n    roundRect(ctx, cx - 36, cy + 12, 72, 52, 10);\n    ctx.fill();\n\n    // smile\n    ctx.strokeStyle = \"#05386B\";\n    ctx.beginPath();\n    ctx.moveTo(cx - 8, cy + 6);\n    ctx.quadraticCurveTo(cx, cy + 14, cx + 8, cy + 6);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function drawBulb(bulb, index) {\n    ctx.save();\n    // socket base\n    ctx.fillStyle = \"#D1D9E6\";\n    roundRect(ctx, bulb.x - 30, bulb.y + 24, 60, 18, 6);\n    ctx.fill();\n\n    // glass bulb\n    ctx.beginPath();\n    ctx.arc(bulb.x, bulb.y, bulb.radius, 0, Math.PI * 2);\n    ctx.fillStyle = bulb.lit ? COLORS.bulbOn : COLORS.bulbOff;\n    ctx.fill();\n\n    // filament drawing\n    ctx.strokeStyle = bulb.lit ? COLORS.bolt : \"#A0A8B6\";\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(bulb.x - 10, bulb.y);\n    ctx.lineTo(bulb.x, bulb.y + 8);\n    ctx.lineTo(bulb.x + 10, bulb.y);\n    ctx.stroke();\n\n    // value text\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"bold 16px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(`${bulb.current} / ${bulb.target}`, bulb.x, bulb.y + 6);\n\n    // small overload flash\n    if (bulb.overloaded) {\n      ctx.globalAlpha = 0.7;\n      ctx.fillStyle = COLORS.wrong;\n      ctx.beginPath();\n      ctx.arc(bulb.x, bulb.y, bulb.radius + 8, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n\n    ctx.restore();\n  }\n\n  function drawBubble(b) {\n    ctx.save();\n    // rim\n    ctx.beginPath();\n    ctx.arc(b.x, b.y, b.radius + 2, 0, Math.PI * 2);\n    ctx.fillStyle = \"#BEECE6\";\n    ctx.fill();\n\n    // fill with gradient\n    const g = ctx.createLinearGradient(b.x - b.radius, b.y - b.radius, b.x + b.radius, b.y + b.radius);\n    g.addColorStop(0, COLORS.bubbleFill);\n    g.addColorStop(1, \"#DFF6F0\");\n    ctx.beginPath();\n    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);\n    ctx.fillStyle = g;\n    ctx.fill();\n\n    // number\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"bold 18px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(String(b.value), b.x, b.y + 6);\n\n    // tiny spark if returning\n    if (b.returning) {\n      ctx.fillStyle = COLORS.spark;\n      ctx.beginPath();\n      ctx.arc(b.x + b.radius - 6, b.y - b.radius + 6, 4, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    ctx.restore();\n  }\n\n  function drawCollector() {\n    ctx.save();\n    // collector base\n    ctx.fillStyle = COLORS.collector;\n    roundRect(ctx, collector.x - collector.width / 2, collector.y - collector.height / 2, collector.width, collector.height, 10);\n    ctx.fill();\n\n    // cute face\n    ctx.fillStyle = \"#fff\";\n    circle(ctx, collector.x - 24, collector.y - 6, 6);\n    circle(ctx, collector.x - 10, collector.y - 6, 6);\n    ctx.fillStyle = \"#05386B\";\n    circle(ctx, collector.x - 24, collector.y - 6, 2);\n    circle(ctx, collector.x - 10, collector.y - 6, 2);\n    ctx.strokeStyle = \"#05386B\";\n    ctx.beginPath();\n    ctx.moveTo(collector.x - 18, collector.y + 0);\n    ctx.quadraticCurveTo(collector.x - 14, collector.y + 10, collector.x - 6, collector.y + 0);\n    ctx.stroke();\n\n    // display carried number\n    if (collector.carrying) {\n      ctx.fillStyle = \"#fff\";\n      ctx.beginPath();\n      ctx.arc(collector.x + 26, collector.y - 6, 14, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"bold 14px Arial\";\n      ctx.fillText(String(collector.carrying.value), collector.x + 26, collector.y - 2);\n    }\n\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    ctx.save();\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"16px Arial\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Score: ${score}`, 20, 30);\n    ctx.fillText(`Lives: ${lives}`, 20, 52);\n    ctx.fillText(`Level: ${level}`, 140, 30);\n    ctx.font = \"12px Arial\";\n    ctx.fillStyle = \"#27496D\";\n    ctx.fillText(`Move: \u2190 \u2192  or mouse \u2022 Catch: move into charge \u2022 Send: 1-4 or click a bulb`, 20, 74);\n    ctx.restore();\n  }\n\n  function drawMessages() {\n    ctx.save();\n    for (let m of messages) {\n      const age = performance.now() - m.created;\n      const alpha = 1 - age / m.life;\n      ctx.globalAlpha = alpha;\n      ctx.fillStyle = m.color;\n      ctx.font = \"18px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(m.text, m.x, m.y - age / 30);\n    }\n    ctx.globalAlpha = 1;\n    ctx.restore();\n  }\n\n  function drawIntro() {\n    // show start instructions and static scene\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawBackground();\n    drawTopPanel();\n    drawCollector();\n    initBulbs();\n    for (let i = 0; i < bulbs.length; i++) {\n      drawBulb(bulbs[i], i);\n    }\n    ctx.save();\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"20px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Click or press any key to begin\", WIDTH / 2, HEIGHT / 2 + 20);\n    ctx.font = \"14px Arial\";\n    ctx.fillText(\"Use arrows or mouse to move. Catch number charges and press 1-4 to send them to bulbs.\", WIDTH / 2, HEIGHT / 2 + 46);\n    ctx.restore();\n  }\n\n  // Drawing helpers\n  function circle(ctx, x, y, r) {\n    ctx.beginPath();\n    ctx.arc(x, y, r, 0, Math.PI * 2);\n    ctx.fill();\n  }\n  function roundRect(ctx, x, y, w, h, r) {\n    const radius = Math.min(r, w / 2, h / 2);\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.arcTo(x + w, y, x + w, y + h, radius);\n    ctx.arcTo(x + w, y + h, x, y + h, radius);\n    ctx.arcTo(x, y + h, x, y, radius);\n    ctx.arcTo(x, y, x + w, y, radius);\n    ctx.closePath();\n  }\n\n  // Toggle mute\n  function toggleMute() {\n    muted = !muted;\n    if (muted) {\n      stopBackgroundHum();\n      playBeep(\"wrong\"); // small click to indicate\n      announce(\"Audio muted\");\n    } else {\n      // resume audio\n      if (audioCtx && audioCtx.state === \"suspended\") {\n        audioCtx.resume().catch((err) => {\n          console.warn(\"Audio resume failed:\", err);\n        });\n      }\n      startBackgroundHum();\n      playBeep(\"correct\");\n      announce(\"Audio unmuted\");\n    }\n  }\n\n  // Initialize and draw initial screen\n  initBulbs();\n  drawIntro();\n\n  // Provide instructions in SR for initial state\n  announce(\"Electric Math ready. Click or press any key to start.\");\n\n  // Expose some debugging to window (optional, harmless)\n  window.__electricMath = {\n    startGame,\n    endGame,\n    toggleMute,\n  };\n})();\n---\n",
  "improve_response_tokens": 18201,
  "formatted_code": true,
  "formatting_response_tokens": 19972,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}