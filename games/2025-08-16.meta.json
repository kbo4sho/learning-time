{
  "generated_date": "2025-08-16",
  "generated_timestamp": "2025-08-16T00:21:35.753213",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9639,
  "game_filename": "2025-08-16.js",
  "game_size_bytes": 26678,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Electricity Math Game for ages 7-9\n// Renders into element with id \"game-of-the-day-stage\"\n// Canvas-based visuals and Web Audio API for sounds\n// Accessible: keyboard controls, text alternatives, audio toggle, and clear instructions\n\n(() => {\n  // Ensure container exists\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.style.width = '720px';\n  container.style.height = '480px';\n  container.style.outline = 'none';\n\n  // Create hidden accessible instructions (for screen readers)\n  const sr = document.createElement('div');\n  sr.setAttribute('aria-live', 'polite');\n  sr.setAttribute('role', 'status');\n  sr.style.position = 'absolute';\n  sr.style.left = '-10000px';\n  sr.style.top = 'auto';\n  sr.style.width = '1px';\n  sr.style.height = '1px';\n  sr.style.overflow = 'hidden';\n  container.appendChild(sr);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.setAttribute('tabindex', '0'); // make focusable\n  canvas.style.display = 'block';\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n  canvas.style.cursor = 'crosshair';\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // Game constants\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n  const GRID_COLS = 5;\n  const GRID_ROWS = 3;\n  const NODE_RADIUS = 28;\n  const MARGIN_X = 80;\n  const MARGIN_Y = 140;\n  const SPACING_X = (WIDTH - 2 * MARGIN_X) / (GRID_COLS - 1);\n  const SPACING_Y = 90;\n  const MAX_ROUNDS = 8;\n\n  // Game state\n  let nodes = []; // {col,row,x,y,value,lit,used}\n  let spark = {col: 2, row: 1, x: 0, y: 0}; // starts center-ish\n  let selected = []; // list of selected node indexes\n  let targetSum = 10;\n  let score = 0;\n  let round = 1;\n  let message = 'Welcome to Spark Circuit! Use arrows to move. Press Space to pick.';\n  let showHelp = true;\n  let audioEnabled = true;\n  let audioCtx = null;\n  let audioAllowed = true;\n  let bgHum = null;\n  let lastMoveSoundTime = 0;\n  let animTick = 0;\n  let locked = false; // prevents input during animations\n\n  // Accessibility helper\n  function announce(text) {\n    sr.textContent = text;\n  }\n\n  // Initialize audio context with error handling\n  function initAudio() {\n    if (audioCtx) return;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      if (!AudioContext) {\n        audioAllowed = false;\n        console.warn('Web Audio API not supported in this browser.');\n        return;\n      }\n      audioCtx = new AudioContext();\n      // create gentle background hum\n      try {\n        bgHum = audioCtx.createOscillator();\n        const humGain = audioCtx.createGain();\n        humGain.gain.value = 0.0025; // very gentle\n        bgHum.type = 'sine';\n        bgHum.frequency.value = 120;\n        bgHum.connect(humGain);\n        humGain.connect(audioCtx.destination);\n        bgHum.start();\n      } catch (e) {\n        console.warn('Background hum failed to start:', e);\n      }\n    } catch (e) {\n      audioAllowed = false;\n      console.warn('Failed to create AudioContext:', e);\n    }\n  }\n\n  // Ensure audio resumed on first user gesture (for browsers that require gesture)\n  function tryUnlockAudio() {\n    if (!audioCtx) initAudio();\n    if (!audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().catch(e => console.warn('Audio resume failed:', e));\n    }\n  }\n\n  // Sound utilities using oscillators\n  function playBeep(freq = 880, duration = 0.12, type = 'sine') {\n    if (!audioAllowed || !audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.05, now + 0.01);\n      o.start(now);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn('playBeep error:', e);\n    }\n  }\n\n  function playSuccess() {\n    if (!audioAllowed || !audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      // ascending triad\n      [660, 880, 990].forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        const g = audioCtx.createGain();\n        o.type = 'triangle';\n        o.frequency.value = f;\n        o.connect(g);\n        g.connect(audioCtx.destination);\n        const t = now + i * 0.09;\n        g.gain.setValueAtTime(0.0001, t);\n        g.gain.exponentialRampToValueAtTime(0.06, t + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.14);\n        o.start(t);\n        o.stop(t + 0.16);\n      });\n    } catch (e) {\n      console.warn('playSuccess error:', e);\n    }\n  }\n\n  function playBuzz() {\n    if (!audioAllowed || !audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const f = audioCtx.createBiquadFilter();\n      const g = audioCtx.createGain();\n      o.type = 'sawtooth';\n      o.frequency.value = 160;\n      f.type = 'lowpass';\n      f.frequency.value = 500;\n      g.gain.value = 0.0001;\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioCtx.destination);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.06, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);\n      o.start(now);\n      o.stop(now + 0.26);\n    } catch (e) {\n      console.warn('playBuzz error:', e);\n    }\n  }\n\n  // Game logic helpers\n  function nodeIndex(col, row) {\n    return row * GRID_COLS + col;\n  }\n\n  function createNodes() {\n    nodes = [];\n    for (let r = 0; r < GRID_ROWS; r++) {\n      for (let c = 0; c < GRID_COLS; c++) {\n        const x = MARGIN_X + c * SPACING_X;\n        const y = MARGIN_Y + r * SPACING_Y + Math.sin((c + r) * 0.8) * 6;\n        nodes.push({\n          col: c,\n          row: r,\n          x,\n          y,\n          value: 0,\n          lit: false,\n          used: false\n        });\n      }\n    }\n  }\n\n  // Generate values ensuring at least one pair sums to target\n  function generateRound() {\n    locked = false;\n    // choose target between 5 and 18\n    targetSum = Math.floor(Math.random() * 14) + 5;\n    // Generate values ensuring at least one valid pair\n    createNodes();\n    // pick a pair indices for guaranteed solution\n    const idxA = Math.floor(Math.random() * nodes.length);\n    let idxB = idxA;\n    while (idxB === idxA) idxB = Math.floor(Math.random() * nodes.length);\n    const valA = Math.floor(Math.random() * Math.min(9, targetSum - 1)) + 1; // at least 1\n    const valB = targetSum - valA;\n    // Fill values: place the pair\n    nodes[idxA].value = valA;\n    nodes[idxB].value = valB;\n    // Fill others randomly but avoid accidental extra trivial pairs? It's okay to have more pairs.\n    for (let i = 0; i < nodes.length; i++) {\n      if (i === idxA || i === idxB) continue;\n      let v = Math.floor(Math.random() * 12) + 1; // 1..12\n      // avoid making any number exceed 20 or negative\n      v = Math.max(1, Math.min(12, v));\n      nodes[i].value = v;\n      nodes[i].lit = false;\n      nodes[i].used = false;\n    }\n    // Reset spark to central-ish position\n    spark.col = 2;\n    spark.row = 1;\n    const idx = nodeIndex(spark.col, spark.row);\n    spark.x = nodes[idx].x;\n    spark.y = nodes[idx].y;\n    selected = [];\n    message = `Round ${round}: Help Spark find two numbers that add to ${targetSum}.`;\n    announce(message);\n  }\n\n  // Input handling: Movement and selection\n  function moveSpark(dx, dy) {\n    if (locked) return;\n    const newCol = Math.max(0, Math.min(GRID_COLS - 1, spark.col + dx));\n    const newRow = Math.max(0, Math.min(GRID_ROWS - 1, spark.row + dy));\n    if (newCol === spark.col && newRow === spark.row) return;\n    spark.col = newCol;\n    spark.row = newRow;\n    const idx = nodeIndex(spark.col, spark.row);\n    // animate movement by setting target x,y; we'll ease in update loop\n    // play small move sound, limit rapid retriggering\n    const now = performance.now();\n    if (now - lastMoveSoundTime > 80) {\n      playBeep(880, 0.08, 'square');\n      lastMoveSoundTime = now;\n    }\n  }\n\n  function selectCurrentNode() {\n    if (locked) return;\n    const idx = nodeIndex(spark.col, spark.row);\n    if (selected.length === 1 && selected[0] === idx) {\n      // deselect if pressing same node again\n      selected = [];\n      message = 'Selection cleared.';\n      announce(message);\n      return;\n    }\n    if (selected.length === 2) {\n      // ignore until evaluation completes\n      return;\n    }\n    if (nodes[idx].used) {\n      message = 'This node already used. Try another.';\n      announce(message);\n      playBuzz();\n      return;\n    }\n    selected.push(idx);\n    playBeep(1100, 0.09, 'sine');\n    message = `Picked ${nodes[idx].value}.`;\n    announce(message);\n    if (selected.length === 2) {\n      evaluateSelection();\n    }\n  }\n\n  function evaluateSelection() {\n    locked = true;\n    const a = nodes[selected[0]].value;\n    const b = nodes[selected[1]].value;\n    if (a + b === targetSum) {\n      // success\n      nodes[selected[0]].lit = true;\n      nodes[selected[1]].lit = true;\n      nodes[selected[0]].used = true;\n      nodes[selected[1]].used = true;\n      score += 10;\n      playSuccess();\n      message = `Great! ${a} + ${b} = ${targetSum}. Bulb lit! Score: ${score}`;\n      announce(message);\n      // small celebration animation and next round after timeout\n      setTimeout(() => {\n        round++;\n        if (round > MAX_ROUNDS) {\n          message = `Amazing! You finished with ${score} points. Play again? Press R.`;\n          announce(message);\n          locked = false;\n        } else {\n          generateRound();\n        }\n      }, 900);\n    } else {\n      // incorrect\n      playBuzz();\n      message = `Oops! ${a} + ${b} = ${a + b} not ${targetSum}. Try again.`;\n      announce(message);\n      // flash nodes and reset selection\n      const bad = [...selected];\n      // animate flash by marking lit temporarily\n      bad.forEach(i => nodes[i].lit = true);\n      setTimeout(() => {\n        bad.forEach(i => (nodes[i].lit = false));\n        selected = [];\n        locked = false;\n      }, 700);\n    }\n  }\n\n  // Click handling: click on node to move spark there and/or select\n  canvas.addEventListener('pointerdown', (ev) => {\n    tryUnlockAudio();\n    const rect = canvas.getBoundingClientRect();\n    const px = (ev.clientX - rect.left) * (canvas.width / rect.width);\n    const py = (ev.clientY - rect.top) * (canvas.height / rect.height);\n    // check if clicked on speaker icon top-right\n    if (px > WIDTH - 64 && px < WIDTH - 12 && py > 12 && py < 48) {\n      audioEnabled = !audioEnabled;\n      message = audioEnabled ? 'Audio on.' : 'Audio off.';\n      announce(message);\n      if (audioEnabled && audioAllowed) tryUnlockAudio();\n      return;\n    }\n    // check clicked on help area toggle bottom-left\n    if (px < 160 && py > HEIGHT - 64) {\n      showHelp = !showHelp;\n      message = showHelp ? 'Help shown.' : 'Help hidden.';\n      announce(message);\n      return;\n    }\n    // find nearest node click\n    let clickedIndex = -1;\n    for (let i = 0; i < nodes.length; i++) {\n      const n = nodes[i];\n      const dx = px - n.x;\n      const dy = py - n.y;\n      if (dx * dx + dy * dy <= NODE_RADIUS * NODE_RADIUS * 1.4) {\n        clickedIndex = i;\n        break;\n      }\n    }\n    if (clickedIndex >= 0) {\n      // move spark to that node (instant) and select\n      spark.col = nodes[clickedIndex].col;\n      spark.row = nodes[clickedIndex].row;\n      const idx = nodeIndex(spark.col, spark.row);\n      // single click selects\n      selectCurrentNode();\n    } else {\n      // click elsewhere moves spark to nearest grid position\n      // find nearest col/row\n      let nearestCol = 0;\n      let nearestRow = 0;\n      let minDist = Infinity;\n      for (let r = 0; r < GRID_ROWS; r++) {\n        for (let c = 0; c < GRID_COLS; c++) {\n          const n = nodes[nodeIndex(c, r)];\n          const d = (px - n.x) ** 2 + (py - n.y) ** 2;\n          if (d < minDist) {\n            minDist = d;\n            nearestCol = c;\n            nearestRow = r;\n          }\n        }\n      }\n      spark.col = nearestCol;\n      spark.row = nearestRow;\n      playBeep(700, 0.08, 'triangle');\n    }\n  });\n\n  // Keyboard controls\n  window.addEventListener('keydown', (e) => {\n    if (!document.activeElement || document.activeElement !== canvas) {\n      // only respond if canvas focused to avoid interference\n      return;\n    }\n    tryUnlockAudio();\n    if (e.key === 'ArrowLeft') {\n      e.preventDefault();\n      moveSpark(-1, 0);\n    } else if (e.key === 'ArrowRight') {\n      e.preventDefault();\n      moveSpark(1, 0);\n    } else if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      moveSpark(0, -1);\n    } else if (e.key === 'ArrowDown') {\n      e.preventDefault();\n      moveSpark(0, 1);\n    } else if (e.key === ' ' || e.key === 'Enter') {\n      e.preventDefault();\n      selectCurrentNode();\n    } else if (e.key.toLowerCase() === 'r') {\n      e.preventDefault();\n      round = 1;\n      score = 0;\n      generateRound();\n    } else if (e.key.toLowerCase() === 'm') {\n      e.preventDefault();\n      audioEnabled = !audioEnabled;\n      message = audioEnabled ? 'Audio on.' : 'Audio off.';\n      announce(message);\n      if (audioEnabled && audioAllowed) tryUnlockAudio();\n    } else if (e.key.toLowerCase() === 'h') {\n      e.preventDefault();\n      showHelp = !showHelp;\n      message = showHelp ? 'Help shown.' : 'Help hidden.';\n      announce(message);\n    }\n  });\n\n  // Determine nearest node index from coordinates\n  function findNodeAt(x, y) {\n    for (let i = 0; i < nodes.length; i++) {\n      const dx = x - nodes[i].x;\n      const dy = y - nodes[i].y;\n      if (dx * dx + dy * dy <= NODE_RADIUS * NODE_RADIUS) return i;\n    }\n    return -1;\n  }\n\n  // Drawing routines\n  function drawBackground() {\n    // soft gradient background like soft circuit board\n    const g = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);\n    g.addColorStop(0, '#0f2b3d');\n    g.addColorStop(0.5, '#0d394a');\n    g.addColorStop(1, '#083a2e');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // wacky floating electric swirls (glow)\n    for (let i = 0; i < 6; i++) {\n      ctx.beginPath();\n      const x = (i / 6) * WIDTH + (Math.sin(animTick * 0.02 + i) * 30);\n      const y = 60 + (i % 2) * 120 + Math.cos(animTick * 0.03 + i) * 18;\n      ctx.fillStyle = `rgba(200,230,255,0.02)`;\n      ctx.arc(x, y, 120, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function drawBulb() {\n    // bulb sits at top center as the mission target. It lights when correct picks\n    const bulbX = WIDTH / 2;\n    const bulbY = 64;\n    // bulb glass\n    ctx.beginPath();\n    const glow = (selected.length === 2 && nodes[selected[0]].lit && nodes[selected[1]].lit) ? 0.9 : 0.15 + Math.sin(animTick * 0.12) * 0.05;\n    const bulbGrad = ctx.createRadialGradient(bulbX - 10, bulbY - 12, 12, bulbX, bulbY, 80);\n    bulbGrad.addColorStop(0, `rgba(255, 255, 160, ${0.9 * glow})`);\n    bulbGrad.addColorStop(1, `rgba(255, 220, 90, ${0.05 * glow})`);\n    ctx.fillStyle = bulbGrad;\n    ctx.ellipse(bulbX, bulbY, 60, 46, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // glass outline\n    ctx.beginPath();\n    ctx.strokeStyle = 'rgba(255,255,200,0.8)';\n    ctx.lineWidth = 2;\n    ctx.ellipse(bulbX, bulbY, 60, 46, 0, 0, Math.PI * 2);\n    ctx.stroke();\n\n    // filament (wavy)\n    ctx.beginPath();\n    ctx.strokeStyle = 'rgba(255, 230, 120, 0.9)';\n    ctx.lineWidth = 3;\n    const p1 = {x: bulbX - 14, y: bulbY + 2};\n    const p2 = {x: bulbX - 4, y: bulbY - 6 + Math.sin(animTick * 0.2) * 3};\n    const p3 = {x: bulbX + 6, y: bulbY + 2};\n    ctx.moveTo(p1.x, p1.y);\n    ctx.quadraticCurveTo(p2.x, p2.y, p3.x, p3.y);\n    ctx.stroke();\n\n    // base\n    ctx.fillStyle = '#666';\n    ctx.fillRect(bulbX - 28, bulbY + 28, 56, 18);\n    ctx.fillStyle = '#444';\n    ctx.fillRect(bulbX - 18, bulbY + 46, 36, 6);\n\n    // text: target\n    ctx.fillStyle = '#fff';\n    ctx.font = 'bold 20px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(`Target: ${targetSum}`, bulbX, bulbY - 56);\n\n    // fun bulb buddy character next to bulb\n    drawGlimmer(bulbX + 110, bulbY - 10);\n  }\n\n  function drawGlimmer(x, y) {\n    // Glimmer: a friendly bulb-bird that reacts when lit\n    const glow = (selected.length === 2 && nodes[selected[0]].lit && nodes[selected[1]].lit) ? 1 : 0.2;\n    // body\n    ctx.beginPath();\n    ctx.fillStyle = `rgba(255,240,120,${0.9 * glow + 0.1})`;\n    ctx.arc(x, y, 18, 0, Math.PI * 2);\n    ctx.fill();\n    // eye\n    ctx.beginPath();\n    ctx.fillStyle = '#222';\n    ctx.arc(x - 4, y - 4, 3, 0, Math.PI * 2);\n    ctx.fill();\n    // beak\n    ctx.beginPath();\n    ctx.fillStyle = '#ff9a3c';\n    ctx.moveTo(x + 6, y);\n    ctx.lineTo(x + 12, y - 4);\n    ctx.lineTo(x + 12, y + 4);\n    ctx.fill();\n    // tiny lightning halo\n    ctx.beginPath();\n    ctx.strokeStyle = `rgba(255,255,180,${0.5 + 0.5 * glow})`;\n    ctx.lineWidth = 2;\n    ctx.moveTo(x - 22, y - 18);\n    ctx.lineTo(x - 10, y - 6);\n    ctx.lineTo(x - 18, y - 6);\n    ctx.stroke();\n  }\n\n  function drawWires() {\n    ctx.lineWidth = 3;\n    for (let i = 0; i < nodes.length; i++) {\n      const n = nodes[i];\n      // connect to right neighbor\n      if (n.col < GRID_COLS - 1) {\n        const n2 = nodes[nodeIndex(n.col + 1, n.row)];\n        drawWireSegment(n, n2);\n      }\n      // connect to bottom neighbor\n      if (n.row < GRID_ROWS - 1) {\n        const n2 = nodes[nodeIndex(n.col, n.row + 1)];\n        drawWireSegment(n, n2);\n      }\n      // diagonal wacky connector to make it interesting\n      if (n.col < GRID_COLS - 1 && n.row < GRID_ROWS - 1) {\n        const n2 = nodes[nodeIndex(n.col + 1, n.row + 1)];\n        drawWireSegment(n, n2, true);\n      }\n    }\n  }\n\n  function drawWireSegment(a, b, diagonal = false) {\n    // wire color glows if connected to a lit node\n    const lit = a.lit || b.lit;\n    const base = lit ? 'rgba(255,220,120,0.9)' : 'rgba(200,240,255,0.18)';\n    // wacky line using quadratic curve with slight sine offset based on animTick\n    const midX = (a.x + b.x) / 2 + Math.sin((a.x + b.x + animTick) * 0.01) * 6;\n    const midY = (a.y + b.y) / 2 + Math.cos((a.y + b.y + animTick) * 0.01) * 6;\n    ctx.beginPath();\n    ctx.strokeStyle = base;\n    ctx.lineWidth = 4;\n    ctx.lineCap = 'round';\n    ctx.moveTo(a.x, a.y);\n    ctx.quadraticCurveTo(midX, midY, b.x, b.y);\n    ctx.stroke();\n\n    // tiny highlight line\n    ctx.beginPath();\n    ctx.strokeStyle = lit ? 'rgba(255,255,200,0.6)' : 'rgba(255,255,255,0.04)';\n    ctx.lineWidth = 1.2;\n    ctx.moveTo(a.x, a.y);\n    ctx.quadraticCurveTo(midX, midY, b.x, b.y);\n    ctx.stroke();\n  }\n\n  function drawNodes() {\n    for (let i = 0; i < nodes.length; i++) {\n      const n = nodes[i];\n      // base circle\n      ctx.beginPath();\n      // shadow\n      ctx.fillStyle = 'rgba(0,0,0,0.18)';\n      ctx.arc(n.x + 4, n.y + 6, NODE_RADIUS + 6, 0, Math.PI * 2);\n      ctx.fill();\n\n      // glow if lit\n      if (n.lit) {\n        const g = ctx.createRadialGradient(n.x - 6, n.y - 8, 6, n.x, n.y, NODE_RADIUS + 20);\n        g.addColorStop(0, 'rgba(255,250,180,0.9)');\n        g.addColorStop(1, 'rgba(255,200,80,0.06)');\n        ctx.fillStyle = g;\n        ctx.beginPath();\n        ctx.arc(n.x, n.y, NODE_RADIUS + 20, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // node body\n      ctx.beginPath();\n      ctx.fillStyle = n.used ? '#4a4a4a' : '#0f4c5e';\n      ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI * 2);\n      ctx.fill();\n\n      // rim\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = 'rgba(200,255,255,0.12)';\n      ctx.stroke();\n\n      // numeric label\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 20px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(n.value), n.x, n.y);\n\n      // if selected highlight\n      const idx = i;\n      if (selected.includes(idx)) {\n        ctx.beginPath();\n        ctx.lineWidth = 4;\n        ctx.strokeStyle = 'rgba(255,240,140,0.95)';\n        ctx.arc(n.x, n.y, NODE_RADIUS + 6, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n\n      // tiny spark sprite on nodes that are available and not used\n      if (!n.used) {\n        ctx.beginPath();\n        const littleX = n.x + Math.cos((i + animTick) * 0.12) * 6;\n        const littleY = n.y + Math.sin((i + animTick) * 0.11) * 4;\n        ctx.fillStyle = 'rgba(255,230,160,0.9)';\n        ctx.arc(littleX, littleY, 6, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  }\n\n  function drawSpark() {\n    // Ease spark position toward node center for smooth movement\n    const target = nodes[nodeIndex(spark.col, spark.row)];\n    if (!target) return;\n    spark.x += (target.x - spark.x) * 0.32;\n    spark.y += (target.y - spark.y) * 0.32;\n\n    ctx.save();\n    // animated electric trail\n    const grad = ctx.createRadialGradient(spark.x, spark.y, 2, spark.x, spark.y, 40);\n    grad.addColorStop(0, 'rgba(255,250,190,0.95)');\n    grad.addColorStop(1, 'rgba(255,200,90,0.03)');\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.arc(spark.x, spark.y, 18 + Math.sin(animTick * 0.1) * 3, 0, Math.PI * 2);\n    ctx.fill();\n\n    // main spark body\n    ctx.beginPath();\n    ctx.fillStyle = '#fffab0';\n    ctx.arc(spark.x, spark.y, 10, 0, Math.PI * 2);\n    ctx.fill();\n\n    // face\n    ctx.fillStyle = '#222';\n    ctx.beginPath();\n    ctx.arc(spark.x - 3, spark.y - 2, 1.7, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(spark.x + 4, spark.y - 2, 1.7, 0, Math.PI * 2);\n    ctx.fill();\n    // smile\n    ctx.beginPath();\n    ctx.strokeStyle = '#222';\n    ctx.lineWidth = 1.6;\n    ctx.arc(spark.x + 0, spark.y + 2, 4, 0.1 * Math.PI, 0.9 * Math.PI);\n    ctx.stroke();\n\n    // small electric flicker\n    ctx.restore();\n  }\n\n  function drawUI() {\n    // top-left score\n    ctx.fillStyle = 'rgba(0,0,0,0.25)';\n    ctx.fillRect(12, 12, 180, 42);\n    ctx.fillStyle = '#fff';\n    ctx.font = '16px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Score: ${score}`, 22, 34);\n    ctx.fillStyle = '#fff';\n    ctx.font = '13px Arial';\n    ctx.fillText(`Round: ${round}/${MAX_ROUNDS}`, 22, 50);\n\n    // speaker icon top-right\n    ctx.beginPath();\n    const spX = WIDTH - 48;\n    const spY = 28;\n    ctx.fillStyle = audioEnabled ? '#ffd56b' : '#777';\n    ctx.fillRect(spX - 18, spY - 12, 14, 24);\n    ctx.beginPath();\n    ctx.moveTo(spX - 4, spY - 14);\n    ctx.lineTo(spX + 10, spY - 6);\n    ctx.lineTo(spX + 10, spY + 6);\n    ctx.lineTo(spX - 4, spY + 14);\n    ctx.closePath();\n    ctx.fill();\n    // waves if enabled\n    if (audioEnabled) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 2;\n      ctx.arc(spX + 10, spY, 10, -0.5, 0.5);\n      ctx.stroke();\n    } else {\n      ctx.beginPath();\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = 3;\n      ctx.moveTo(spX + 6, spY - 9);\n      ctx.lineTo(spX + 14, spY + 9);\n      ctx.stroke();\n    }\n    // small accessible hint text\n    ctx.fillStyle = '#fff';\n    ctx.font = '12px Arial';\n    ctx.textAlign = 'right';\n    ctx.fillText('Press M to mute', WIDTH - 22, 50);\n\n    // bottom-left help toggle\n    ctx.fillStyle = 'rgba(0,0,0,0.25)';\n    ctx.fillRect(12, HEIGHT - 64, 220, 52);\n    ctx.fillStyle = '#fff';\n    ctx.font = '12px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('H: Help  |  R: Restart', 22, HEIGHT - 36);\n    ctx.fillText('Arrows: Move  Space/Enter: Pick', 22, HEIGHT - 18);\n\n    // message box centered bottom\n    ctx.fillStyle = 'rgba(0,0,0,0.36)';\n    ctx.fillRect(WIDTH / 2 - 300, HEIGHT - 64, 600, 48);\n    ctx.fillStyle = '#fff';\n    ctx.font = 'bold 15px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(message, WIDTH / 2, HEIGHT - 36);\n\n    // visual cue for selected picks\n    ctx.fillStyle = '#fff';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'center';\n    if (selected.length > 0) {\n      const a = nodes[selected[0]].value;\n      ctx.fillText(`Picked: ${a}${selected.length === 2 ? '' : '  (pick another)'}`, WIDTH / 2, HEIGHT - 18);\n    } else {\n      ctx.fillText('No selection yet', WIDTH / 2, HEIGHT - 18);\n    }\n\n    // small characters description for narrative\n    ctx.fillStyle = 'rgba(255,255,255,0.06)';\n    ctx.font = 'bold 34px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Spark Circuit', 18, 110);\n  }\n\n  // Main render loop\n  function render() {\n    animTick++;\n    drawBackground();\n    drawBulb();\n    drawWires();\n    drawNodes();\n    drawSpark();\n    drawUI();\n\n    // update spark position smoothing already done in drawSpark\n    requestAnimationFrame(render);\n  }\n\n  // Initialization\n  function startGame() {\n    initAudio();\n    if (!audioAllowed) {\n      audioEnabled = false;\n      message = 'Audio not available. Using visual feedback.';\n      announce(message);\n    }\n    createNodes();\n    // set initial spark coords to center node\n    const idx = nodeIndex(spark.col, spark.row);\n    spark.x = nodes[idx].x;\n    spark.y = nodes[idx].y;\n\n    generateRound();\n    render();\n\n    // initial instruction announcement\n    const helpText = `Spark Circuit: Move Spark (arrow keys) to nodes and press Space to pick two numbers that add to the target.\n    Click nodes or use keyboard. Toggle audio with M. Toggle help with H. Restart with R.`;\n    announce(helpText);\n  }\n\n  // Make sure canvas receives focus on click for keyboard controls\n  canvas.addEventListener('click', () => {\n    canvas.focus();\n  });\n\n  // Focus outline for accessibility\n  canvas.addEventListener('focus', () => {\n    canvas.style.outline = '3px solid rgba(255,255,180,0.2)';\n  });\n  canvas.addEventListener('blur', () => {\n    canvas.style.outline = 'none';\n  });\n\n  // Start game when user interacts first time (to create audio on gesture)\n  function userGestureInit() {\n    tryUnlockAudio();\n    // remove listeners after first gesture\n    window.removeEventListener('pointerdown', userGestureInit);\n    window.removeEventListener('keydown', userGestureInit);\n  }\n  window.addEventListener('pointerdown', userGestureInit, {passive: true});\n  window.addEventListener('keydown', userGestureInit);\n\n  // Kick off\n  startGame();\n\n  // Expose a small debug function to container for testing (non-essential)\n  container.debug = {\n    getState: () => ({score, round, targetSum, nodes, selected})\n  };\n})();\n---\n",
  "improve_response_tokens": 17972,
  "formatted_code": true,
  "formatting_response_tokens": 18748,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}