{
  "generated_date": "2025-08-20",
  "generated_timestamp": "2025-08-20T00:20:53.094692",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8661,
  "game_filename": "2025-08-20.js",
  "game_size_bytes": 25416,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Electricity Math Game for ages 7-9\n  // Renders into element with ID \"game-of-the-day-stage\"\n  // Canvas size: 720x480\n  // All visuals drawn via Canvas API. Sounds via Web Audio API.\n  // Accessible: keyboard controls, aria-label, visual cues for audio.\n\n  // -----------------------\n  // Setup and safety checks\n  // -----------------------\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error('Element with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = \"\";\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = \"720px\";\n  canvas.style.height = \"480px\";\n  canvas.tabIndex = 0; // make keyboard-focusable\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\n    \"aria-label\",\n    \"Electric City Math Game. Use keyboard or mouse to place batteries to match lamp power targets. Press M to mute or unmute audio.\"\n  );\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n\n  // Handle high DPI\n  function setupHiDPI() {\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = 720 * dpr;\n    canvas.height = 480 * dpr;\n    canvas.style.width = \"720px\";\n    canvas.style.height = \"480px\";\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n  setupHiDPI();\n\n  // -----------------------\n  // Audio setup with error handling\n  // -----------------------\n  let audioCtx = null;\n  let globalGain = null;\n  let isMuted = false;\n  let backgroundNode = null;\n\n  try {\n    const AudioCtx = window.AudioContext || window.webkitAudioContext;\n    if (AudioCtx) {\n      audioCtx = new AudioCtx();\n      globalGain = audioCtx.createGain();\n      globalGain.gain.value = 0.25; // gentle overall volume\n      globalGain.connect(audioCtx.destination);\n\n      // Create gentle background hum using oscillator + subtle filter\n      const humOsc = audioCtx.createOscillator();\n      const humGain = audioCtx.createGain();\n      const humFilter = audioCtx.createBiquadFilter();\n      humOsc.type = \"sine\";\n      humOsc.frequency.value = 55; // low hum\n      humGain.gain.value = 0.06;\n      humFilter.type = \"lowpass\";\n      humFilter.frequency.value = 200;\n      humOsc.connect(humFilter);\n      humFilter.connect(humGain);\n      humGain.connect(globalGain);\n      humOsc.start();\n      backgroundNode = { osc: humOsc, gain: humGain, filter: humFilter };\n    } else {\n      console.warn(\"Web Audio API not supported in this browser.\");\n    }\n  } catch (e) {\n    console.error(\"Audio initialization failed:\", e);\n    audioCtx = null;\n  }\n\n  function resumeAudioContext() {\n    if (!audioCtx) return;\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"Audio resume failed:\", e);\n      });\n    }\n  }\n\n  // Sound helpers (oscillators with envelopes)\n  function playTone({ freq = 440, duration = 0.25, type = \"sine\", gain = 0.2 }) {\n    if (!audioCtx || isMuted) return;\n    try {\n      resumeAudioContext();\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.value = gain;\n      o.connect(g);\n      g.connect(globalGain);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(gain, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, now + duration);\n      o.start(now);\n      o.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn(\"playTone failed:\", e);\n    }\n  }\n\n  function playSuccess() {\n    // pleasant rising triad\n    if (!audioCtx || isMuted) return;\n    try {\n      resumeAudioContext();\n      const now = audioCtx.currentTime;\n      const freqs = [660, 880, 990];\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        const g = audioCtx.createGain();\n        o.type = i === 1 ? \"triangle\" : \"sine\";\n        o.frequency.value = f;\n        g.gain.value = 0.12;\n        o.connect(g);\n        g.connect(globalGain);\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.linearRampToValueAtTime(0.12, now + 0.02 + 0.02 * i);\n        g.gain.exponentialRampToValueAtTime(0.001, now + 0.35 + 0.05 * i);\n        o.start(now + 0.02 * i);\n        o.stop(now + 0.45 + 0.05 * i);\n      });\n    } catch (e) {\n      console.warn(\"playSuccess failed:\", e);\n    }\n  }\n\n  function playError() {\n    // short buzz\n    if (!audioCtx || isMuted) return;\n    try {\n      resumeAudioContext();\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const f = audioCtx.createBiquadFilter();\n      o.type = \"square\";\n      o.frequency.value = 140;\n      f.type = \"highpass\";\n      f.frequency.value = 100;\n      g.gain.value = 0.18;\n      o.connect(f);\n      f.connect(g);\n      g.connect(globalGain);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.001, now);\n      g.gain.linearRampToValueAtTime(0.18, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);\n      o.start(now);\n      o.stop(now + 0.26);\n    } catch (e) {\n      console.warn(\"playError failed:\", e);\n    }\n  }\n\n  function playClick() {\n    playTone({ freq: 880, duration: 0.08, type: \"square\", gain: 0.08 });\n  }\n\n  // -----------------------\n  // Game data and helpers\n  // -----------------------\n  const STATE = {\n    batteries: [], // battery objects\n    target: 10,\n    placed: [], // placed battery indices\n    round: 1,\n    score: 0,\n    message: \"Welcome! Charge the lamp to the exact power target.\",\n    focusedIndex: 0,\n    dragging: null, // { idx, offsetX, offsetY }\n    lastActionTime: 0,\n  };\n\n  const CHARACTERS = {\n    professor: { name: \"Professor Volt\", color: \"#4C4EFF\" },\n    sparky: { name: \"Sparky the Squirrel\", color: \"#FF9F4C\" },\n    bulby: { name: \"Bulby the Bulb\", color: \"#FFF374\" },\n  };\n\n  // Initialize a round\n  function newRound(round = 1) {\n    STATE.round = round;\n    STATE.placed = [];\n    STATE.batteries = [];\n    STATE.message = `${CHARACTERS.professor.name}: \"Let's power the lamp!\"`;\n    // target grows slowly\n    STATE.target = Math.max(5, Math.min(18, 6 + Math.floor(Math.random() * 10) + Math.floor(round / 2)));\n    // create 5 battery cards with values 1-9 but ensure solvability:\n    // We'll create 4 random and one guaranteed to allow reachability.\n    const values = [];\n    for (let i = 0; i < 4; i++) {\n      values.push(1 + Math.floor(Math.random() * 9));\n    }\n    // compute some sum of subset toward target\n    let needed = STATE.target - (values.reduce((a, b) => a + b, 0) % (STATE.target + 1));\n    // ensure needed in 1..9, else pick a random\n    if (needed < 1 || needed > 9) {\n      needed = 1 + Math.floor(Math.random() * 9);\n    }\n    values.push(needed);\n    // shuffle\n    for (let i = values.length - 1; i >= 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [values[i], values[j]] = [values[j], values[i]];\n    }\n    // create battery objects\n    const startX = 40;\n    const startY = 360;\n    const gap = 128;\n    for (let i = 0; i < values.length; i++) {\n      const x = startX + i * gap;\n      const y = startY;\n      STATE.batteries.push({\n        value: values[i],\n        x,\n        y,\n        w: 100,\n        h: 60,\n        picked: false,\n        placed: false,\n        id: \"b\" + Date.now() + \"-\" + i,\n      });\n    }\n    STATE.focusedIndex = 0;\n  }\n\n  newRound(1);\n\n  // Utility: check mouse inside rect\n  function pointInRect(px, py, r) {\n    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;\n  }\n\n  // -----------------------\n  // Input handling (mouse & touch & keyboard)\n  // -----------------------\n  canvas.addEventListener(\"mousedown\", (e) => {\n    resumeAudioContext();\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left);\n    const my = (e.clientY - rect.top);\n    // Check batteries (topmost first)\n    for (let i = STATE.batteries.length - 1; i >= 0; i--) {\n      const b = STATE.batteries[i];\n      if (!b.placed && pointInRect(mx, my, b)) {\n        STATE.dragging = {\n          idx: i,\n          offsetX: mx - b.x,\n          offsetY: my - b.y,\n        };\n        b.picked = true;\n        STATE.focusedIndex = i;\n        playClick();\n        return;\n      }\n    }\n    // check mute button area (top-right)\n    if (mx > 640 && my < 48) {\n      toggleMute();\n      draw();\n    }\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    if (!STATE.dragging) return;\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left);\n    const my = (e.clientY - rect.top);\n    const d = STATE.dragging;\n    const b = STATE.batteries[d.idx];\n    b.x = mx - d.offsetX;\n    b.y = my - d.offsetY;\n    draw();\n  });\n\n  function endDrag(e) {\n    if (!STATE.dragging) return;\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.changedTouches ? e.changedTouches[0].clientX - rect.left : e.clientX - rect.left);\n    const my = (e.changedTouches ? e.changedTouches[0].clientY - rect.top : e.clientY - rect.top);\n    const d = STATE.dragging;\n    const b = STATE.batteries[d.idx];\n    b.picked = false;\n    // If dropped in lamp area, attempt place\n    if (isInLampArea(mx, my)) {\n      attemptPlaceBattery(d.idx);\n    } else {\n      // snap back to bottom area\n      snapBatteryBack(d.idx);\n    }\n    STATE.dragging = null;\n    draw();\n  }\n\n  canvas.addEventListener(\"mouseup\", endDrag);\n  canvas.addEventListener(\"mouseleave\", endDrag);\n  canvas.addEventListener(\"touchstart\", (e) => {\n    e.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.touches[0].clientX - rect.left;\n    const my = e.touches[0].clientY - rect.top;\n    for (let i = STATE.batteries.length - 1; i >= 0; i--) {\n      const b = STATE.batteries[i];\n      if (!b.placed && pointInRect(mx, my, b)) {\n        STATE.dragging = {\n          idx: i,\n          offsetX: mx - b.x,\n          offsetY: my - b.y,\n        };\n        b.picked = true;\n        STATE.focusedIndex = i;\n        playClick();\n        return;\n      }\n    }\n    // mute area\n    if (mx > 640 && my < 48) {\n      toggleMute();\n      draw();\n    }\n  }, { passive: false });\n\n  canvas.addEventListener(\"touchmove\", (e) => {\n    e.preventDefault();\n    if (!STATE.dragging) return;\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.touches[0].clientX - rect.left;\n    const my = e.touches[0].clientY - rect.top;\n    const d = STATE.dragging;\n    const b = STATE.batteries[d.idx];\n    b.x = mx - d.offsetX;\n    b.y = my - d.offsetY;\n    draw();\n  }, { passive: false });\n\n  canvas.addEventListener(\"touchend\", (e) => {\n    e.preventDefault();\n    endDrag(e);\n  });\n\n  // Keyboard controls\n  canvas.addEventListener(\"keydown\", (e) => {\n    resumeAudioContext();\n    const key = e.key;\n    if (key === \"ArrowRight\") {\n      // move focus to next battery\n      focusNextBattery(1);\n      e.preventDefault();\n      draw();\n    } else if (key === \"ArrowLeft\") {\n      focusNextBattery(-1);\n      e.preventDefault();\n      draw();\n    } else if (key === \"Enter\" || key === \" \") {\n      // pick up or place focused battery\n      const b = STATE.batteries[STATE.focusedIndex];\n      if (!b) return;\n      if (!b.placed && !b.picked) {\n        // pick it up: mark as picked and simulate drag to lamp center\n        b.picked = true;\n        b.x = 300;\n        b.y = 180;\n        draw();\n      } else if (b.picked) {\n        // drop where it is: attempt place if near lamp\n        if (isInLampArea(b.x + b.w / 2, b.y + b.h / 2)) {\n          attemptPlaceBattery(STATE.focusedIndex);\n        } else {\n          snapBatteryBack(STATE.focusedIndex);\n        }\n        b.picked = false;\n      }\n      e.preventDefault();\n    } else if (key === \"Backspace\") {\n      // remove last placed battery back to deck\n      e.preventDefault();\n      removeLastPlaced();\n      draw();\n    } else if (key.toLowerCase() === \"m\") {\n      // toggle mute\n      toggleMute();\n      draw();\n    } else if (key === \"n\") {\n      // new round (for testing)\n      newRound(STATE.round + 1);\n      playClick();\n      draw();\n    }\n  });\n\n  function focusNextBattery(dir) {\n    const len = STATE.batteries.length;\n    if (len === 0) return;\n    STATE.focusedIndex = (STATE.focusedIndex + dir + len) % len;\n    // skip placed ones\n    let attempts = 0;\n    while (STATE.batteries[STATE.focusedIndex].placed && attempts < len) {\n      STATE.focusedIndex = (STATE.focusedIndex + dir + len) % len;\n      attempts++;\n    }\n  }\n\n  // -----------------------\n  // Game logic: placement and checks\n  // -----------------------\n  function isInLampArea(x, y) {\n    // lamp center area at center of canvas\n    const lamp = { x: 280, y: 60, w: 160, h: 160 };\n    return x >= lamp.x && x <= lamp.x + lamp.w && y >= lamp.y && y <= lamp.y + lamp.h;\n  }\n\n  function attemptPlaceBattery(idx) {\n    const b = STATE.batteries[idx];\n    if (b.placed) return;\n    // Place battery into lamp\n    b.placed = true;\n    b.picked = false;\n    STATE.placed.push(idx);\n    playClick();\n    evaluateSum();\n  }\n\n  function removeLastPlaced() {\n    if (STATE.placed.length === 0) {\n      STATE.message = `${CHARACTERS.sparky.name}: \"No batteries in the lamp yet!\"`;\n      playError();\n      return;\n    }\n    const idx = STATE.placed.pop();\n    const b = STATE.batteries[idx];\n    b.placed = false;\n    // move it back to bottom area (snap)\n    snapBatteryBack(idx);\n    STATE.message = `${CHARACTERS.professor.name}: \"You removed a battery.\"`;\n    playClick();\n  }\n\n  function snapBatteryBack(idx) {\n    // find an available bottom slot near initial placement index\n    const baseX = 40 + idx * 128;\n    const baseY = 360;\n    const b = STATE.batteries[idx];\n    b.x = baseX;\n    b.y = baseY;\n  }\n\n  function currentPlacedSum() {\n    return STATE.placed.reduce((s, idx) => s + (STATE.batteries[idx]?.value || 0), 0);\n  }\n\n  function evaluateSum() {\n    const sum = currentPlacedSum();\n    if (sum === STATE.target) {\n      // success\n      STATE.score += 1;\n      STATE.message = `${CHARACTERS.bulby.name}: \"Bright! You matched the power!\"`;\n      playSuccess();\n      // animate bulb glow briefly (handled in drawCount)\n      setTimeout(() => {\n        // start next round after a short delay\n        newRound(STATE.round + 1);\n        draw();\n      }, 1200);\n    } else if (sum > STATE.target) {\n      STATE.message = `${CHARACTERS.sparky.name}: \"Uh-oh, that's too much power. Remove a battery.\"`;\n      playError();\n    } else {\n      STATE.message = `${CHARACTERS.professor.name}: \"Good! Keep adding. Current power: ${sum}.\"`;\n      playTone({ freq: 660, duration: 0.12, type: \"sine\", gain: 0.06 });\n    }\n  }\n\n  // -----------------------\n  // Drawing functions\n  // -----------------------\n  let bulbGlow = 0; // for glow animation when success\n\n  function drawBackground() {\n    // Soft gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, 480);\n    g.addColorStop(0, \"#eef6ff\");\n    g.addColorStop(1, \"#f3f9f9\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, 720, 480);\n\n    // Wacky floating electrons (calming)\n    for (let i = 0; i < 8; i++) {\n      ctx.beginPath();\n      ctx.globalAlpha = 0.05 + (i % 3) * 0.03;\n      ctx.fillStyle = [\"#FFEDDD\", \"#E8FFF8\", \"#FFF6E8\"][i % 3];\n      const rx = (i * 137.5) % 720;\n      const ry = (i * 79.3 + (Date.now() / 800) * (i % 5 + 1)) % 480;\n      ctx.arc(rx, ry, 48 - (i % 4) * 6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.globalAlpha = 1;\n  }\n\n  function drawLampArea() {\n    // Draw central lamp and circuit\n    const lampX = 280;\n    const lampY = 60;\n    const lampW = 160;\n    const lampH = 160;\n\n    // wires\n    ctx.strokeStyle = \"#9ec9ff\";\n    ctx.lineWidth = 8;\n    ctx.beginPath();\n    ctx.moveTo(160, 140);\n    ctx.lineTo(240, 140);\n    ctx.lineTo(lampX, lampY + lampH / 2);\n    ctx.lineTo(lampX + lampW, lampY + lampH / 2);\n    ctx.lineTo(560, 140);\n    ctx.stroke();\n\n    // bulb background\n    ctx.save();\n    ctx.translate(lampX + lampW / 2, lampY + lampH / 2);\n    const glow = Math.min(1, bulbGlow);\n    // glow layers\n    for (let i = 0; i < 4; i++) {\n      ctx.beginPath();\n      ctx.fillStyle = `rgba(255, 244, 116, ${0.06 * (4 - i) * (0.4 + 0.6 * glow)})`;\n      ctx.arc(0, 0, 52 + i * 12 * glow, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    // bulb glass\n    ctx.beginPath();\n    ctx.fillStyle = \"#fffef7\";\n    ctx.strokeStyle = \"#ffd965\";\n    ctx.lineWidth = 2;\n    ctx.ellipse(0, 0, 46, 58, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // filament (visual tie to numbers)\n    ctx.beginPath();\n    ctx.strokeStyle = \"#ffb84d\";\n    ctx.lineWidth = 3;\n    ctx.moveTo(-14, -6);\n    ctx.quadraticCurveTo(0, 6 + 12 * glow, 14, -6);\n    ctx.stroke();\n\n    ctx.restore();\n\n    // lamp plate text\n    ctx.fillStyle = \"#2b2b2b\";\n    ctx.font = \"bold 14px sans-serif\";\n    ctx.fillText(\"Power Lamp\", lampX + lampW / 2 - 36, lampY - 8);\n\n    // target info box\n    ctx.fillStyle = \"#d7f6ff\";\n    ctx.fillRect(lampX + lampW + 12, lampY + lampH / 2 - 28, 140, 56);\n    ctx.strokeStyle = \"#9fd6ff\";\n    ctx.strokeRect(lampX + lampW + 12, lampY + lampH / 2 - 28, 140, 56);\n    ctx.fillStyle = \"#005b8a\";\n    ctx.font = \"bold 18px sans-serif\";\n    ctx.fillText(\"Target Power:\", lampX + lampW + 20, lampY + lampH / 2 - 2);\n    ctx.fillStyle = \"#ff6b6b\";\n    ctx.font = \"bold 28px sans-serif\";\n    ctx.fillText(STATE.target.toString(), lampX + lampW + 78, lampY + lampH / 2 + 26);\n\n    // placed battery icons inside lamp arranged\n    const placed = STATE.placed;\n    const slotStartX = lampX + 20;\n    const slotY = lampY + lampH - 46;\n    for (let i = 0; i < placed.length; i++) {\n      const idx = placed[i];\n      const b = STATE.batteries[idx];\n      const tx = slotStartX + i * 36;\n      const ty = slotY;\n      // draw small battery\n      drawSmallBattery(tx, ty, b.value);\n    }\n  }\n\n  function drawSmallBattery(x, y, value) {\n    ctx.save();\n    ctx.translate(x, y);\n    // body\n    ctx.fillStyle = \"#ffe9b8\";\n    ctx.strokeStyle = \"#b88a3a\";\n    ctx.lineWidth = 1.5;\n    roundRect(ctx, 0, 0, 34, 22, 4, true, true);\n    // positive tip\n    ctx.fillStyle = \"#ffd76f\";\n    ctx.fillRect(28, 6, 6, 10);\n    // number\n    ctx.fillStyle = \"#6b3b00\";\n    ctx.font = \"bold 12px sans-serif\";\n    ctx.fillText(value.toString(), 8, 15);\n    ctx.restore();\n  }\n\n  function drawBatteries() {\n    // bottom area where batteries sit\n    ctx.font = \"bold 16px sans-serif\";\n    ctx.fillStyle = \"#005b8a\";\n    ctx.fillText(\"Battery Pack (drag to lamp)\", 40, 340);\n\n    for (let i = 0; i < STATE.batteries.length; i++) {\n      const b = STATE.batteries[i];\n      // skip if placed, draw semi-transparent small indicator at top-right stack\n      if (b.placed) {\n        // draw small icon near right side for placed ones\n        ctx.save();\n        ctx.globalAlpha = 0.6;\n        drawSmallBattery(560 + (i % 2) * 38, 320 + Math.floor(i / 2) * 28, b.value);\n        ctx.restore();\n        continue;\n      }\n\n      // battery card rectangle\n      ctx.save();\n      // highlight if focused\n      if (i === STATE.focusedIndex) {\n        ctx.shadowColor = \"rgba(0,0,0,0.15)\";\n        ctx.shadowBlur = 10;\n      } else {\n        ctx.shadowBlur = 0;\n      }\n\n      // body\n      ctx.fillStyle = \"#fff9f0\";\n      ctx.strokeStyle = \"#f0c27b\";\n      ctx.lineWidth = 2;\n      roundRect(ctx, b.x, b.y, b.w, b.h, 10, true, true);\n\n      // top stripe to look like battery\n      ctx.fillStyle = \"#ffd86b\";\n      ctx.fillRect(b.x + 6, b.y + 6, b.w - 12, 14);\n\n      // battery tip\n      ctx.fillStyle = \"#ffdb9f\";\n      ctx.fillRect(b.x + b.w - 10, b.y + b.h / 2 - 8, 8, 16);\n\n      // number\n      ctx.fillStyle = \"#4c2e00\";\n      ctx.font = \"bold 26px sans-serif\";\n      ctx.fillText(b.value.toString(), b.x + 16, b.y + 40);\n\n      // focus outline\n      if (i === STATE.focusedIndex) {\n        ctx.strokeStyle = \"#668cff\";\n        ctx.lineWidth = 3;\n        roundRect(ctx, b.x - 4, b.y - 4, b.w + 8, b.h + 8, 12, false, true);\n        // keyboard hint\n        ctx.fillStyle = \"#005b8a\";\n        ctx.font = \"12px sans-serif\";\n        ctx.fillText(\"Press Enter to place\", b.x + 6, b.y - 8);\n      }\n\n      // if picked, make it follow top layer (we handled via position)\n      if (b.picked) {\n        ctx.globalAlpha = 1;\n        // little shadow\n        ctx.fillStyle = \"rgba(0,0,0,0.06)\";\n        ctx.fillRect(b.x + 6, b.y + b.h + 6, b.w - 12, 8);\n      }\n      ctx.restore();\n    }\n  }\n\n  function drawCharactersAndUI() {\n    // Right side characters\n    const rightX = 560;\n    // Professor Volt (squares with goggles)\n    ctx.save();\n    ctx.fillStyle = CHARACTERS.professor.color;\n    ctx.fillRect(rightX, 40, 120, 72);\n    ctx.fillStyle = \"#ffffff\";\n    ctx.font = \"bold 14px sans-serif\";\n    ctx.fillText(CHARACTERS.professor.name, rightX + 8, 68);\n    // speech bubble\n    ctx.fillStyle = \"#ffffff\";\n    roundRect(ctx, rightX - 40, 120, 200, 56, 10, true, true);\n    ctx.fillStyle = \"#333\";\n    ctx.font = \"12px sans-serif\";\n    ctx.fillText(STATE.message, rightX - 32, 145, 176);\n    ctx.restore();\n\n    // Squirky Sparky\n    ctx.save();\n    ctx.fillStyle = CHARACTERS.sparky.color;\n    ctx.beginPath();\n    ctx.ellipse(rightX + 60, 220, 50, 36, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#663300\";\n    ctx.font = \"bold 12px sans-serif\";\n    ctx.fillText(CHARACTERS.sparky.name, rightX + 22, 220);\n    ctx.restore();\n\n    // Bulby (the lamp friend)\n    ctx.save();\n    ctx.fillStyle = CHARACTERS.bulby.color;\n    ctx.beginPath();\n    ctx.arc(rightX + 60, 295, 34, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#663300\";\n    ctx.font = \"bold 12px sans-serif\";\n    ctx.fillText(CHARACTERS.bulby.name, rightX + 34, 295);\n    ctx.restore();\n\n    // Score box\n    ctx.fillStyle = \"#eaf9ff\";\n    ctx.fillRect(rightX, 340, 120, 80);\n    ctx.strokeStyle = \"#9fd6ff\";\n    ctx.strokeRect(rightX, 340, 120, 80);\n    ctx.fillStyle = \"#004a6b\";\n    ctx.font = \"bold 18px sans-serif\";\n    ctx.fillText(\"Score\", rightX + 12, 365);\n    ctx.font = \"bold 28px sans-serif\";\n    ctx.fillText(STATE.score.toString(), rightX + 40, 402);\n\n    // Mute icon (top-right)\n    ctx.save();\n    ctx.fillStyle = isMuted ? \"#ff6b6b\" : \"#7bd389\";\n    ctx.beginPath();\n    ctx.arc(690, 28, 18, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"bold 12px sans-serif\";\n    ctx.fillText(isMuted ? \"MUT\" : \"SND\", 678, 32);\n    ctx.restore();\n\n    // Keyboard & accessibility instructions\n    ctx.fillStyle = \"#2b2b2b\";\n    ctx.font = \"12px sans-serif\";\n    ctx.fillText(\"Controls: Mouse drag or use Arrow keys + Enter.\", 40, 430);\n    ctx.fillText(\"Press M to mute/unmute. Backspace to remove last battery.\", 40, 448);\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === \"undefined\") r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function draw() {\n    // clear\n    ctx.clearRect(0, 0, 720, 480);\n    drawBackground();\n    drawLampArea();\n    drawBatteries();\n    drawCharactersAndUI();\n\n    // if audio unavailable, show visual cue\n    if (!audioCtx) {\n      ctx.fillStyle = \"#ffdddd\";\n      ctx.fillRect(10, 10, 260, 32);\n      ctx.fillStyle = \"#660000\";\n      ctx.font = \"12px sans-serif\";\n      ctx.fillText(\"Audio not available in this browser. Sounds disabled.\", 18, 32);\n    }\n\n    // fading bulbGlow\n    bulbGlow *= 0.96;\n\n    // spoken current sum display (floating near lamp)\n    const sum = currentPlacedSum();\n    ctx.font = \"bold 20px sans-serif\";\n    ctx.fillStyle = sum === STATE.target ? \"#0099ff\" : \"#005b8a\";\n    ctx.fillText(\"Current: \" + sum, 300, 240);\n  }\n\n  // animate\n  let rafId = null;\n  function loop() {\n    draw();\n    rafId = requestAnimationFrame(loop);\n  }\n  loop();\n\n  // -----------------------\n  // Mute toggle\n  // -----------------------\n  function toggleMute() {\n    isMuted = !isMuted;\n    if (globalGain) {\n      globalGain.gain.value = isMuted ? 0 : 0.25;\n    }\n    // visual cue (bulb flash)\n    bulbGlow = isMuted ? 0 : 1;\n    // small tone if unmuting\n    if (!isMuted) playTone({ freq: 880, duration: 0.12, gain: 0.06 });\n  }\n\n  // -----------------------\n  // Accessibility: focus handling\n  // -----------------------\n  // When canvas gains focus, show thin outline\n  canvas.addEventListener(\"focus\", () => {\n    canvas.style.outline = \"3px solid rgba(102,140,255,0.45)\";\n  });\n  canvas.addEventListener(\"blur\", () => {\n    canvas.style.outline = \"none\";\n  });\n\n  // Ensure first click resumes audio (some browsers require user gesture)\n  canvas.addEventListener(\"pointerdown\", resumeAudioContext);\n\n  // -----------------------\n  // Resizing and cleanup\n  // -----------------------\n  window.addEventListener(\"resize\", () => {\n    // keep logical size constant; no changes required, but ensure HiDPI remains consistent\n    setupHiDPI();\n    draw();\n  });\n\n  // Expose a small debugging console if needed\n  // (not required but helpful for teachers)\n  try {\n    // nothing to export to global to avoid polluting environment\n  } catch (e) {\n    console.warn(\"Could not attach debug hooks\", e);\n  }\n\n  // -----------------------\n  // End of script\n  // -----------------------\n})();\n---\n",
  "improve_response_tokens": 17630,
  "formatted_code": true,
  "formatting_response_tokens": 19096,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}