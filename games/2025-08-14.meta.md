# Game of the Day - 2025-08-14

## Metadata
- **Generated Date:** 2025-08-14
- **Generated Time:** 2025-08-14T00:22:50.904965
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-14.js
- **File Size:** 25981 bytes
- **Tokens Used:** 9254

## Functionality Score
- **Score:** 7/8 (87.5%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- ⚠️  No game state management found

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-14.js` - The playable game
- `2025-08-14.meta.json` - Machine-readable metadata
- `2025-08-14.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19064

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21163

### Final Functionality Score After Improvement
- **Score:** 7/8 (87.5%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- ⚠️  No game state management found

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Electricity-themed Math Game for ages 7-9
  // Renders into the element with ID "game-of-the-day-stage"
  // All visuals drawn on canvas and sounds generated with Web Audio API.
  // Accessibility: keyboard controls, aria updates, visual audio toggle.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const BG_COLOR_TOP = '#eaf6ff';
  const BG_COLOR_BOTTOM = '#dff3ff';
  const MAX_MODULES = 6;

  // Get container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    // Graceful fallback: cannot proceed without the container
    console.error('Game container with id "game-of-the-day-stage" not found.');
    return;
  }

  // Set accessibility attributes on container
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Charge the Robot: an addition game. Use keyboard arrows to select or drag modules. Press Enter to place. Press space to toggle sound.');
  container.tabIndex = 0; // make container focusable

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.setAttribute('aria-hidden', 'false');
  container.innerHTML = '';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // ARIA live region for announcements
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '-9999px';
  live.style.width = '1px';
  live.style.height = '1px';
  live.style.overflow = 'hidden';
  container.appendChild(live);

  // Audio setup with error handling
  let audioCtx = null;
  let masterGain = null;
  let audioEnabled = false;
  let audioAvailable = true;

  function initAudio() {
    if (audioCtx) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error('Web Audio API not supported.');
      audioCtx = new AC();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.12; // gentle volume
      masterGain.connect(audioCtx.destination);

      // gentle ambient hum oscillator
      const hum = audioCtx.createOscillator();
      const humGain = audioCtx.createGain();
      hum.type = 'sine';
      hum.frequency.value = 110;
      humGain.gain.value = 0.02;
      hum.connect(humGain);
      humGain.connect(masterGain);
      hum.start();

      audioEnabled = true;
    } catch (e) {
      console.warn('Audio initialization failed:', e);
      audioAvailable = false;
      audioEnabled = false;
    }
  }

  function safePlayTone(freq, duration = 0.3, type = 'sine', volume = 1, when = 0) {
    if (!audioAvailable || !audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const now = audioCtx.currentTime;
      o.type = type;
      o.frequency.setValueAtTime(freq, now + when);
      g.gain.setValueAtTime(0, now + when);
      g.gain.linearRampToValueAtTime(volume, now + when + 0.01);
      g.gain.linearRampToValueAtTime(0.0001, now + when + duration);
      o.connect(g);
      g.connect(masterGain);
      o.start(now + when);
      o.stop(now + when + duration + 0.02);
    } catch (e) {
      console.warn('Failed to play tone:', e);
    }
  }

  function playCorrect() {
    if (!audioAvailable || !audioEnabled) return;
    // a bright chord
    safePlayTone(880, 0.12, 'sine', 0.8);
    safePlayTone(1320, 0.12, 'sine', 0.5, 0.02);
    safePlayTone(660, 0.12, 'sine', 0.4, 0.03);
  }
  function playWrong() {
    if (!audioAvailable || !audioEnabled) return;
    safePlayTone(220, 0.22, 'sawtooth', 0.8);
    safePlayTone(180, 0.18, 'sawtooth', 0.6, 0.05);
  }
  function playTap() {
    if (!audioAvailable || !audioEnabled) return;
    safePlayTone(520, 0.06, 'square', 0.6);
  }

  // Utility helpers
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Game state
  let target = 12;
  let modules = []; // energy orbs with numbers
  let usedModules = [];
  let sum = 0;
  let selectedIndex = 0; // keyboard selection
  let dragging = null; // {index, offsetX, offsetY}
  let robotLit = false;
  let feedbackMessage = '';
  let feedbackTimer = 0;
  let showConfetti = [];
  let soundToggleVisible = true;
  let mutedForContext = false; // if audio blocked until user gesture

  // Characters (drawn shapes)
  const characters = {
    professor: { x: 120, y: 120 }, // witty cat-like coil professor
    sparky: { x: 120, y: 300 }, // battery buddy
    robot: { x: 540, y: 240 } // robot to charge
  };

  // Initialize new challenge
  function newChallenge() {
    robotLit = false;
    sum = 0;
    usedModules = [];
    feedbackMessage = 'Click or drag energy orbs into the robot to match its required charge.';
    feedbackTimer = 200;
    generateTargetAndModules();
    selectedIndex = 0;
    showConfetti = [];
    announce(`New challenge. Target ${target}.`);
  }

  // Announce to aria-live
  function announce(text) {
    live.textContent = text;
  }

  // Generate a target and a set of modules that contains at least one exact combination
  function generateTargetAndModules() {
    // target between 6 and 18
    target = randInt(6, 18);

    // create between 2 and 4 pieces that sum exactly to target
    const piecesCount = randInt(2, 4);
    let remaining = target;
    const pieces = [];
    for (let i = 0; i < piecesCount; i++) {
      const remainingSlots = piecesCount - i;
      // ensure each piece at least 1 and not exceed 9
      let maxForSlot = Math.min(9, remaining - (remainingSlots - 1));
      let val = randInt(1, Math.max(1, maxForSlot));
      // if last slot, take remaining
      if (i === piecesCount - 1) val = remaining;
      pieces.push(val);
      remaining -= val;
    }

    // Add extra distractor modules
    const extras = MAX_MODULES - pieces.length;
    const modulesList = pieces.slice();
    for (let i = 0; i < extras; i++) {
      modulesList.push(randInt(1, 9));
    }

    shuffle(modulesList);

    // place modules visually on left side
    modules = modulesList.map((val, i) => {
      const col = i % 2;
      const row = Math.floor(i / 2);
      const x = 220 - col * 120 + randInt(-10, 10);
      const y = 120 + row * 90 + randInt(-12, 12);
      return {
        value: val,
        x,
        y,
        r: 34,
        used: false,
        jitter: Math.random() * Math.PI * 2,
        id: 'm' + i
      };
    });
  }

  // Check if a module dropped near robot inlet
  function isNearRobot(mx, my) {
    // robot inlet near robot.x - 40, robot.y
    const rx = characters.robot.x - 70;
    const ry = characters.robot.y;
    const dist = Math.hypot(mx - rx, my - ry);
    return dist < 60;
  }

  // Place module into robot (animate absorption)
  function acceptModule(index) {
    if (modules[index].used) return;
    modules[index].used = true;
    usedModules.push(index);
    sum += modules[index].value;
    announce(`Placed ${modules[index].value}. Sum is ${sum}. Target ${target}.`);
    // play tap
    playTap();

    // Evaluate
    if (sum === target) {
      robotLit = true;
      playCorrect();
      feedbackMessage = 'Perfect! Robot fully charged!';
      feedbackTimer = 280;
      spawnConfetti();
      announce('Perfect! Robot fully charged. Press N for next challenge.');
    } else if (sum > target) {
      // overcharge
      playWrong();
      feedbackMessage = 'Oh no! Overcharged! Try again.';
      feedbackTimer = 280;
      announce('Overcharged. Reset to try again.');
    } else {
      feedbackMessage = 'Nice! Keep going.';
      feedbackTimer = 160;
    }
  }

  function spawnConfetti() {
    showConfetti = [];
    for (let i = 0; i < 18; i++) {
      showConfetti.push({
        x: characters.robot.x + randInt(-30, 30),
        y: characters.robot.y - 30 + randInt(-10, 10),
        vx: randInt(-40, 40) / 60,
        vy: randInt(-180, -60) / 60,
        color: ['#ffd166', '#06d6a0', '#ef476f', '#118ab2'][randInt(0, 3)],
        life: randInt(50, 120)
      });
    }
  }

  function resetChallenge() {
    // return used modules to available and keep same target, or we can restart
    modules.forEach(m => (m.used = false));
    usedModules = [];
    sum = 0;
    robotLit = false;
    feedbackMessage = 'Reset. Try adding modules to reach the target exactly.';
    feedbackTimer = 160;
    announce('Reset. Target ' + target + '.');
  }

  // Input handling: mouse/touch/keyboard

  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    handlePointerDown(mx, my);
  });
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const t = e.touches[0];
    const mx = t.clientX - rect.left;
    const my = t.clientY - rect.top;
    handlePointerDown(mx, my);
  }, {passive:false});

  function handlePointerDown(mx, my) {
    // if clicked sound icon area (upper-right small)
    if (mx > WIDTH - 64 && my < 64) {
      // toggle audio
      if (!audioCtx) {
        initAudio();
      }
      if (audioAvailable) audioEnabled = !audioEnabled;
      announce(`Audio ${audioEnabled ? 'on' : 'off'}.`);
      playTap();
      return;
    }

    // Check clicking modules
    for (let i = modules.length - 1; i >= 0; i--) {
      const m = modules[i];
      if (m.used) continue;
      const d = Math.hypot(mx - m.x, my - m.y);
      if (d < m.r + 6) {
        // begin dragging
        dragging = { index: i, offsetX: mx - m.x, offsetY: my - m.y };
        selectedIndex = i;
        playTap();
        return;
      }
    }

    // If clicked near accept area (robot)
    if (isNearRobot(mx, my)) {
      // attempt to accept selected module
      const idx = selectedIndex;
      if (modules[idx] && !modules[idx].used) {
        acceptModule(idx);
      }
      return;
    }

    // check for reset button
    if (mx > 20 && mx < 120 && my > HEIGHT - 60 && my < HEIGHT - 20) {
      resetChallenge();
      playTap();
    }
  }

  window.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const m = modules[dragging.index];
    m.x = mx - dragging.offsetX;
    m.y = my - dragging.offsetY;
  });

  window.addEventListener('mouseup', (e) => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const index = dragging.index;
    dragging = null;
    // if near robot, accept
    if (isNearRobot(mx, my)) {
      acceptModule(index);
    } else {
      // snap back a little jitter to original area if not used
      const baseX = 220 + (index % 2 === 0 ? 0 : -120);
      const baseY = 120 + Math.floor(index / 2) * 90;
      modules[index].x = baseX + randInt(-8, 8);
      modules[index].y = baseY + randInt(-10, 10);
    }
  });

  window.addEventListener('touchmove', (e) => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const t = e.touches[0];
    const mx = t.clientX - rect.left;
    const my = t.clientY - rect.top;
    const m = modules[dragging.index];
    m.x = mx - dragging.offsetX;
    m.y = my - dragging.offsetY;
  }, {passive:false});

  window.addEventListener('touchend', (e) => {
    if (!dragging) return;
    // touchend gives no coords; check if last known position was near robot
    const m = modules[dragging.index];
    const mx = m.x, my = m.y;
    const idx = dragging.index;
    dragging = null;
    if (isNearRobot(mx, my)) {
      acceptModule(idx);
    } else {
      const baseX = 220 + (idx % 2 === 0 ? 0 : -120);
      const baseY = 120 + Math.floor(idx / 2) * 90;
      modules[idx].x = baseX + randInt(-8, 8);
      modules[idx].y = baseY + randInt(-10, 10);
    }
  });

  // Keyboard controls
  container.addEventListener('keydown', (e) => {
    // ensure audio can start on user gesture
    if (!audioCtx && (e.key === ' ' || e.key === 'Enter' || e.key === 's' || e.key === 'S')) {
      try {
        initAudio();
      } catch (err) {
        // ignore
      }
    }

    if (e.key === 'ArrowLeft') {
      // move selection left
      e.preventDefault();
      selectedIndex = (selectedIndex - 1 + modules.length) % modules.length;
      playTap();
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      selectedIndex = (selectedIndex + 1) % modules.length;
      playTap();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      // move selection up by 2
      selectedIndex = (selectedIndex - 2 + modules.length) % modules.length;
      playTap();
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      selectedIndex = (selectedIndex + 2) % modules.length;
      playTap();
    } else if (e.key === 'Enter') {
      e.preventDefault();
      // place selected module into robot if not used
      if (modules[selectedIndex] && !modules[selectedIndex].used) {
        acceptModule(selectedIndex);
      }
    } else if (e.key === 'r' || e.key === 'R') {
      e.preventDefault();
      resetChallenge();
    } else if (e.key === 'n' || e.key === 'N') {
      e.preventDefault();
      newChallenge();
    } else if (e.key === ' ') {
      e.preventDefault();
      // toggle audio
      if (!audioCtx) initAudio();
      if (audioAvailable) audioEnabled = !audioEnabled;
      announce(`Audio ${audioEnabled ? 'on' : 'off'}.`);
      playTap();
    } else if (e.key === 'd' || e.key === 'D') {
      // deselect used module or return last
      e.preventDefault();
      // undo last placed
      if (usedModules.length > 0) {
        const idx = usedModules.pop();
        modules[idx].used = false;
        sum -= modules[idx].value;
        robotLit = false;
        feedbackMessage = 'Removed a module.';
        feedbackTimer = 120;
        announce(`Removed ${modules[idx].value}. Sum is ${sum}.`);
        playTap();
      }
    }
  });

  // Drawing functions
  function drawBackground() {
    // pleasant gentle gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, BG_COLOR_TOP);
    g.addColorStop(1, BG_COLOR_BOTTOM);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // floating wacky sparkles
    for (let i = 0; i < 6; i++) {
      const ox = 60 + i * 110 + (Math.sin(perfNow / 1000 + i) * 6);
      const oy = 400 + Math.cos(perfNow / 1200 + i) * 8;
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,${0.06 + (i % 2) * 0.02})`;
      ctx.arc(ox, oy, 32, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawProfessor(x, y) {
    // Professor Volt - coil-cat scientist
    // body
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = '#ffd166';
    ctx.beginPath();
    ctx.ellipse(0, 6, 42, 34, 0, 0, Math.PI * 2);
    ctx.fill();
    // glasses
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(-18, -6, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(18, -6, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(-18, -6, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(18, -6, 5, 0, Math.PI * 2);
    ctx.fill();
    // whisker coils
    ctx.strokeStyle = '#ff9f1c';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-36, -2);
    ctx.quadraticCurveTo(-62, -10, -80, -10);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(36, -2);
    ctx.quadraticCurveTo(62, -10, 80, -10);
    ctx.stroke();
    // lab coat
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.rect(-28, 22, 56, 34);
    ctx.fill();
    // playful scribble
    ctx.restore();
  }

  function drawSparky(x, y) {
    // Sparky the battery buddy
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = '#06d6a0';
    ctx.fillRect(-22, -34, 44, 68);
    ctx.fillStyle = '#fff';
    ctx.fillRect(-22, -10, 44, 24);
    // plus terminal
    ctx.fillStyle = '#ffef99';
    ctx.fillRect(-8, -42, 16, 8);
    // face
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.arc(0, -2, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(-8, -2, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(8, -2, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawRobot(x, y) {
    // Main robot body
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = robotLit ? '#ffd166' : '#f8f9fa';
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.rect(-60, -80, 120, 140);
    ctx.fill();
    ctx.stroke();
    // eyes
    ctx.fillStyle = robotLit ? '#333' : '#88a';
    ctx.beginPath();
    ctx.arc(-24, -34, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(24, -34, 12, 0, Math.PI * 2);
    ctx.fill();
    // mouth
    ctx.fillStyle = robotLit ? '#ef476f' : '#666';
    ctx.beginPath();
    ctx.rect(-20, 6, 40, 8);
    ctx.fill();
    // inlet for energy on left
    ctx.fillStyle = '#dbeafe';
    ctx.beginPath();
    ctx.ellipse(-70, 12, 20, 28, 0, 0, Math.PI * 2);
    ctx.fill();
    // battery indicator
    ctx.fillStyle = '#fff';
    ctx.fillRect(-30, 60, 60, 10);
    const fillW = Math.min(60, Math.max(0, (sum / target) * 60));
    ctx.fillStyle = robotLit ? '#06d6a0' : '#ffb6c1';
    ctx.fillRect(-30, 60, fillW, 10);
    ctx.strokeStyle = '#aaa';
    ctx.strokeRect(-30, 60, 60, 10);

    ctx.restore();
  }

  function drawModule(m, i, highlight = false) {
    ctx.save();
    ctx.translate(m.x, m.y);
    // glow
    if (!m.used) {
      ctx.beginPath();
      ctx.fillStyle = `rgba(96,165,250,${0.08 + (highlight ? 0.12 : 0.03)})`;
      ctx.arc(0, 0, m.r + 10, 0, Math.PI * 2);
      ctx.fill();
    }
    // orb body
    ctx.beginPath();
    ctx.fillStyle = m.used ? '#d1d5db' : '#118ab2';
    ctx.arc(0, 0, m.r, 0, Math.PI * 2);
    ctx.fill();
    // inner ring
    ctx.beginPath();
    ctx.fillStyle = m.used ? '#f8fafc' : '#06d6a0';
    ctx.arc(0, 0, m.r - 8, 0, Math.PI * 2);
    ctx.fill();
    // number
    ctx.fillStyle = m.used ? '#94a3b8' : '#fff';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(m.value, 0, 0);
    // little conductive bolt icon
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-8, 8);
    ctx.lineTo(0, -3);
    ctx.lineTo(8, 8);
    ctx.stroke();
    ctx.restore();
  }

  // Performance timer
  let lastTime = 0;
  let perfNow = 0;

  // Main draw loop
  function draw(now) {
    perfNow = now;
    const dt = now - lastTime;
    lastTime = now;

    // Clear
    drawBackground();

    // Draw characters
    drawProfessor(characters.professor.x, characters.professor.y);
    drawSparky(characters.sparky.x, characters.sparky.y);
    drawRobot(characters.robot.x, characters.robot.y);

    // Draw wires connecting left modules to robot inlet (curvy)
    modules.forEach((m, i) => {
      if (m.used) return;
      const startX = m.x;
      const startY = m.y;
      const endX = characters.robot.x - 70;
      const endY = characters.robot.y;
      ctx.beginPath();
      ctx.strokeStyle = `rgba(10,80,120,${0.12 + (i === selectedIndex ? 0.2 : 0.0)})`;
      ctx.lineWidth = 6;
      ctx.moveTo(startX, startY);
      ctx.quadraticCurveTo((startX + endX) / 2 - 30, startY - 30, endX, endY);
      ctx.stroke();
    });

    // Draw modules
    modules.forEach((m, i) => {
      const highlight = (i === selectedIndex && !dragging);
      drawModule(m, i, highlight);
      // subtle bobbing:
      m.y += Math.sin(now / 1000 + m.jitter) * 0.0005 * dt;
    });

    // If selected and keyboard controls, show selection box
    if (!dragging && modules[selectedIndex]) {
      const m = modules[selectedIndex];
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(m.x, m.y, m.r + 8, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    // Draw UI panels: target information
    ctx.fillStyle = '#083344';
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Target Charge:', 20, 36);
    // target bubble
    ctx.fillStyle = '#ffd166';
    ctx.beginPath();
    ctx.arc(140, 26, 28, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#111827';
    ctx.font = 'bold 22px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(target, 140, 30);

    // sum progress text
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#023047';
    ctx.fillText(`Current Sum: ${sum}`, 20, 66);

    // instructions
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#065f46';
    ctx.fillText('Drag or select orbs and drop them in the robot inlet. Exact match wins.', 20, HEIGHT - 80);

    // Draw reset button
    ctx.fillStyle = '#fff';
    ctx.fillRect(20, HEIGHT - 60, 100, 36);
    ctx.strokeStyle = '#0ea5a4';
    ctx.strokeRect(20, HEIGHT - 60, 100, 36);
    ctx.fillStyle = '#0ea5a4';
    ctx.font = 'bold 16px sans-serif';
    ctx.fillText('Reset (R)', 28, HEIGHT - 34);

    // Draw next challenge tip
    ctx.font = '13px sans-serif';
    ctx.fillStyle = '#334155';
    ctx.fillText('Next (N) starts a new target.', 140, HEIGHT - 34);

    // draw feedback banner
    if (feedbackTimer > 0) {
      const alpha = Math.min(1, feedbackTimer / 160);
      ctx.fillStyle = `rgba(255,255,255,${0.6 * alpha})`;
      ctx.fillRect(WIDTH / 2 - 220, 16, 440, 36);
      ctx.strokeStyle = `rgba(0,0,0,${0.08 * alpha})`;
      ctx.strokeRect(WIDTH / 2 - 220, 16, 440, 36);
      ctx.fillStyle = '#023047';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(feedbackMessage, WIDTH / 2, 40);
      feedbackTimer -= dt;
      if (feedbackTimer < 0) feedbackTimer = 0;
    }

    // Draw list of used modules small icons
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#0b3d91';
    ctx.textAlign = 'left';
    ctx.fillText('Used Orbs:', 320, 36);
    let ux = 320;
    let uy = 48;
    usedModules.forEach((idx, k) => {
      const val = modules[idx].value;
      ctx.beginPath();
      ctx.fillStyle = '#94a3b8';
      ctx.arc(ux + k * 34, uy, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(val, ux + k * 34, uy + 1);
    });

    // draw audio toggle in top-right
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(WIDTH - 36, 36, 28, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#0ea5a4';
    ctx.stroke();
    ctx.fillStyle = audioAvailable ? (audioEnabled ? '#0ea5a4' : '#b91c1c') : '#a1a1aa';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(audioAvailable ? (audioEnabled ? '🔊' : '🔇') : '✖', WIDTH - 36, 40);

    // Draw friendly label for controls
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#073b4c';
    ctx.textAlign = 'right';
    ctx.fillText('Select: arrows • Place: Enter • Undo: D', WIDTH - 20, HEIGHT - 16);

    // draw confetti if success
    if (showConfetti.length > 0) {
      for (let i = showConfetti.length - 1; i >= 0; i--) {
        const c = showConfetti[i];
        ctx.fillStyle = c.color;
        ctx.fillRect(c.x, c.y, 6, 8);
        c.vy += 0.04;
        c.x += c.vx;
        c.y += c.vy;
        c.life -= 1;
        if (c.life <= 0 || c.y > HEIGHT) {
          showConfetti.splice(i, 1);
        }
      }
    }

    // overlay shading on used modules to indicate disabled state
    modules.forEach((m) => {
      if (m.used) {
        ctx.beginPath();
        ctx.fillStyle = 'rgba(0,0,0,0.08)';
        ctx.arc(m.x, m.y, m.r + 4, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    requestAnimationFrame(draw);
  }

  // Start the game
  newChallenge();
  lastTime = performance.now();
  requestAnimationFrame(draw);

  // Initialize audio only after a user gesture - show instruction overlay text inside canvas already; but also create a subtle on-screen note
  // Provide an unobtrusive clickable hint on the container
  function handleFirstGesture() {
    if (!audioCtx) {
      try {
        initAudio();
      } catch (e) {
        // nothing
      }
    }
    container.removeEventListener('pointerdown', handleFirstGesture);
    container.removeEventListener('keydown', handleFirstGesture);
  }
  container.addEventListener('pointerdown', handleFirstGesture);
  container.addEventListener('keydown', handleFirstGesture);

  // Make sure to tell user when audio is unavailable
  if (!('AudioContext' in window) && !('webkitAudioContext' in window)) {
    audioAvailable = false;
    announce('Audio is not available in this browser. The game will still work without sound.');
  }

  // Provide minimal resize handling: keep canvas fixed size but center in container
  container.style.position = 'relative';
  canvas.style.display = 'block';
  canvas.style.margin = '0 auto';

  // Accessibility: focus container for keyboard controls
  container.focus();

  // Expose a tiny debug API on the container for testing (non-intrusive)
  container.__gameDebug = {
    newChallenge,
    resetChallenge,
    getState: () => ({ target, sum, modules: modules.map(m => ({value: m.value, used: m.used})), robotLit })
  };

  // Inform page that game loaded
  announce(`Game ready. Target ${target}. Use arrows to select, Enter to place, Space to toggle audio.`);

})();
---

