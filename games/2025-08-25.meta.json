{
  "generated_date": "2025-08-25",
  "generated_timestamp": "2025-08-25T00:23:21.936946",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 11295,
  "game_filename": "2025-08-25.js",
  "game_size_bytes": 36850,
  "functionality": {
    "score": 7,
    "max_score": 8,
    "percentage": 87.5,
    "passing": true,
    "issues": [],
    "warnings": [
      "No game state management found"
    ]
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Electricity Math Game for ages 7-9\n  // Renders inside element with ID 'game-of-the-day-stage'\n  // Canvas 720x480, uses Web Audio API (oscillators), accessible keyboard controls, drag/touch support.\n  // All visuals drawn with canvas methods. No external resources.\n\n  // Ensure container exists\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container and set ARIA\n  container.innerHTML = '';\n  container.setAttribute('role', 'application');\n  container.setAttribute('aria-label', 'Electric math game. Solve addition puzzles to light bulbs.');\n  container.style.outline = 'none';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.setAttribute('tabindex', '0');\n  canvas.style.display = 'block';\n  canvas.style.background = '#0b1020'; // dark background for glow\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d', { alpha: false });\n\n  // Accessibility live region for announcements\n  const live = document.createElement('div');\n  live.setAttribute('aria-live', 'polite');\n  live.style.position = 'absolute';\n  live.style.left = '-9999px';\n  live.style.width = '1px';\n  live.style.height = '1px';\n  live.style.overflow = 'hidden';\n  live.textContent = '';\n  container.appendChild(live);\n\n  // Global variables\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  // Input state\n  let mouse = { x: 0, y: 0, down: false };\n  let touchId = null;\n\n  // Utility\n  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }\n  function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }\n\n  // Sound Manager using Web Audio API\n  class SoundManager {\n    constructor() {\n      this.enabled = true;\n      this.ctx = null;\n      this.master = null;\n      this.bgGain = null;\n      this.bgOsc = null;\n      this.available = false;\n      try {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        if (!AudioContext) throw new Error('Web Audio API not supported');\n        this.ctx = new AudioContext();\n        this.master = this.ctx.createGain();\n        this.master.gain.value = 0.9;\n        this.master.connect(this.ctx.destination);\n\n        // Background gentle hum\n        this.bgGain = this.ctx.createGain();\n        this.bgGain.gain.value = 0.02; // very subtle\n        this.bgOsc = this.ctx.createOscillator();\n        this.bgOsc.type = 'sine';\n        this.bgOsc.frequency.value = 110; // low hum\n        const bgFilter = this.ctx.createBiquadFilter();\n        bgFilter.type = 'lowpass';\n        bgFilter.frequency.value = 300;\n        this.bgOsc.connect(bgFilter);\n        bgFilter.connect(this.bgGain);\n        this.bgGain.connect(this.master);\n        this.bgOsc.start();\n\n        this.available = true;\n      } catch (e) {\n        console.warn('Audio unavailable:', e);\n        this.available = false;\n        this.ctx = null;\n      }\n    }\n\n    // Attempt to resume audio context on user gesture\n    async resume() {\n      if (!this.ctx) return;\n      try {\n        if (this.ctx.state === 'suspended') await this.ctx.resume();\n      } catch (e) {\n        console.warn('Error resuming audio context:', e);\n      }\n    }\n\n    // Toggle audio on/off\n    setEnabled(on) {\n      this.enabled = on;\n      if (!this.available) this.enabled = false;\n      if (this.master) this.master.gain.value = this.enabled ? 0.9 : 0.0;\n    }\n\n    // Simple click sound\n    click() {\n      if (!this.enabled || !this.available) return;\n      try {\n        const o = this.ctx.createOscillator();\n        const g = this.ctx.createGain();\n        o.type = 'square';\n        o.frequency.value = 880;\n        g.gain.value = 0.0001;\n        o.connect(g);\n        g.connect(this.master);\n        o.start();\n        g.gain.exponentialRampToValueAtTime(0.12, this.ctx.currentTime + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.18);\n        o.stop(this.ctx.currentTime + 0.19);\n      } catch (e) {\n        console.warn('Click sound error', e);\n      }\n    }\n\n    // Success chord\n    success() {\n      if (!this.enabled || !this.available) return;\n      try {\n        const now = this.ctx.currentTime;\n        const freqs = [660, 880, 990]; // pleasant triad-ish\n        freqs.forEach((f, i) => {\n          const o = this.ctx.createOscillator();\n          const g = this.ctx.createGain();\n          o.type = ['sine', 'sawtooth', 'triangle'][i % 3];\n          o.frequency.value = f;\n          g.gain.value = 0.0001;\n          o.connect(g);\n          g.connect(this.master);\n          o.start(now + i * 0.02);\n          g.gain.exponentialRampToValueAtTime(0.12 / (i + 1), now + 0.02 + i * 0.02);\n          g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5 + i * 0.02);\n          o.stop(now + 0.55 + i * 0.02);\n        });\n      } catch (e) {\n        console.warn('Success sound error', e);\n      }\n    }\n\n    // Error buzz\n    error() {\n      if (!this.enabled || !this.available) return;\n      try {\n        const now = this.ctx.currentTime;\n        const o = this.ctx.createOscillator();\n        const g = this.ctx.createGain();\n        const f = 220;\n        o.type = 'sawtooth';\n        o.frequency.value = f;\n        g.gain.value = 0.0001;\n        const filter = this.ctx.createBiquadFilter();\n        filter.type = 'highpass';\n        filter.frequency.value = 600;\n        o.connect(filter);\n        filter.connect(g);\n        g.connect(this.master);\n        o.start(now);\n        g.gain.exponentialRampToValueAtTime(0.12, now + 0.03);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);\n        o.frequency.exponentialRampToValueAtTime(f * 3, now + 0.25);\n        o.stop(now + 0.28);\n      } catch (e) {\n        console.warn('Error sound error', e);\n      }\n    }\n\n    // gentle tap\n    tap() {\n      if (!this.enabled || !this.available) return;\n      try {\n        const o = this.ctx.createOscillator();\n        const g = this.ctx.createGain();\n        o.type = 'sine';\n        o.frequency.value = 440;\n        g.gain.value = 0.0001;\n        o.connect(g);\n        g.connect(this.master);\n        o.start();\n        g.gain.exponentialRampToValueAtTime(0.07, this.ctx.currentTime + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.12);\n        o.stop(this.ctx.currentTime + 0.13);\n      } catch (e) {\n        console.warn('Tap sound error', e);\n      }\n    }\n  }\n\n  const sound = new SoundManager();\n\n  // Game Characters for fun: Sparky (squirrel electrician) and Volt (friendly robot)\n  class Character {\n    constructor(name, color, x, y) {\n      this.name = name;\n      this.color = color;\n      this.x = x;\n      this.y = y;\n      this.w = 120;\n      this.h = 120;\n      this.wave = 0;\n    }\n    update(dt) {\n      this.wave += dt * 2;\n    }\n    draw(ctx) {\n      // Simple whimsical character: circle head with tools\n      ctx.save();\n      ctx.translate(this.x, this.y);\n\n      // shadow\n      ctx.fillStyle = 'rgba(0,0,0,0.2)';\n      ctx.beginPath();\n      ctx.ellipse(0, 52, this.w * 0.6, 18, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // body\n      ctx.fillStyle = this.color;\n      roundRect(ctx, -50, -20, 100, 80, 18);\n      ctx.fill();\n\n      // head\n      ctx.fillStyle = '#fff';\n      ctx.beginPath();\n      ctx.arc(0, -40, 36, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = '#222';\n      // eyes\n      ctx.beginPath();\n      ctx.arc(-12, -44, 6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(12, -44, 6, 0, Math.PI * 2);\n      ctx.fill();\n\n      // smile\n      ctx.strokeStyle = '#222';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(0, -34, 10, 0, Math.PI);\n      ctx.stroke();\n\n      // wobbling tool (a tiny lightning wrench)\n      ctx.save();\n      ctx.translate(38, -2 + Math.sin(this.wave) * 3);\n      ctx.rotate(Math.sin(this.wave) * 0.3);\n      ctx.fillStyle = '#ffd54f';\n      roundRect(ctx, -6, -18, 12, 36, 4);\n      ctx.fillStyle = '#ff8a65';\n      ctx.beginPath();\n      ctx.moveTo(6, -18);\n      ctx.lineTo(14, -10);\n      ctx.lineTo(6, -2);\n      ctx.closePath();\n      ctx.fill();\n      ctx.restore();\n\n      // name banner\n      ctx.fillStyle = 'rgba(255,255,255,0.08)';\n      roundRect(ctx, -60, 40, 120, 18, 9);\n      ctx.fillStyle = '#fff';\n      ctx.font = '12px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(this.name, 0, 54);\n\n      ctx.restore();\n    }\n  }\n\n  // Round rect helper\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Battery and Bulb classes\n  class Battery {\n    constructor(id, val, x, y) {\n      this.id = id;\n      this.val = val;\n      this.x = x;\n      this.y = y;\n      this.r = 32;\n      this.drag = false;\n      this.offsetX = 0;\n      this.offsetY = 0;\n      this.attachedTo = null; // bulb id if attached\n      this.pulse = Math.random() * Math.PI * 2;\n      this.visible = true;\n      this.focused = false;\n    }\n\n    contains(px, py) {\n      return Math.hypot(px - this.x, py - this.y) <= this.r;\n    }\n\n    draw(ctx) {\n      if (!this.visible) return;\n      this.pulse += 0.06;\n      // battery body\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      // glow if focused or dragging\n      const glow = this.drag || this.focused ? 0.6 : 0.15;\n      const grd = ctx.createRadialGradient(-6, -6, 6, 6, 6, 40);\n      grd.addColorStop(0, `rgba(255,255,180,${0.9 * glow})`);\n      grd.addColorStop(1, `rgba(255,180,60,${0.0 + glow * 0.2})`);\n      ctx.fillStyle = '#ffecb3';\n      roundRect(ctx, -26, -40, 52, 80, 8);\n      ctx.fill();\n\n      // top terminal\n      ctx.fillStyle = '#bdbdbd';\n      roundRect(ctx, -10, -46, 20, 12, 3);\n      ctx.fill();\n\n      // lightning symbol\n      ctx.fillStyle = '#ff8a00';\n      ctx.beginPath();\n      ctx.moveTo(-6, -6);\n      ctx.lineTo(6, -6);\n      ctx.lineTo(0, 18);\n      ctx.lineTo(8, 4);\n      ctx.lineTo(-4, 4);\n      ctx.closePath();\n      ctx.fill();\n\n      // value\n      ctx.fillStyle = '#222';\n      ctx.font = 'bold 20px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(this.val, 0, 28);\n\n      // small focus ring\n      if (this.focused) {\n        ctx.strokeStyle = 'rgba(255,255,255,0.7)';\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n        ctx.arc(0, 0, this.r + 8, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  class Bulb {\n    constructor(id, target, x, y) {\n      this.id = id;\n      this.target = target;\n      this.x = x;\n      this.y = y;\n      this.r = 46;\n      this.attached = []; // battery ids\n      this.lit = false;\n      this.glow = 0;\n      this.focused = false;\n    }\n\n    contains(px, py) {\n      return Math.hypot(px - this.x, py - this.y) <= this.r;\n    }\n\n    currentSum(batteries) {\n      return this.attached.reduce((s, bid) => {\n        const b = batteries.find(bb => bb.id === bid);\n        return s + (b ? b.val : 0);\n      }, 0);\n    }\n\n    update(dt, batteries) {\n      const sum = this.currentSum(batteries);\n      if (sum === this.target) {\n        this.lit = true;\n        this.glow = Math.min(1, this.glow + dt * 4);\n      } else {\n        this.lit = false;\n        this.glow = Math.max(0, this.glow - dt * 2);\n      }\n    }\n\n    draw(ctx, batteries, time) {\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      // base bulb\n      const litAmt = this.glow;\n      // glass\n      const grd = ctx.createRadialGradient(-10, -18, 8, 10, 12, 80);\n      grd.addColorStop(0, `rgba(255,255,200,${0.6 * (0.5 + litAmt * 0.5)})`);\n      grd.addColorStop(1, `rgba(220,220,255,${0.05 + litAmt * 0.2})`);\n      ctx.fillStyle = grd;\n      ctx.beginPath();\n      ctx.ellipse(0, -6, this.r * 0.9, this.r, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // filament / bolt when lit\n      if (this.lit) {\n        ctx.strokeStyle = `rgba(255,230,120,${0.95})`;\n        ctx.lineWidth = 6;\n        ctx.lineCap = 'round';\n        ctx.beginPath();\n        ctx.moveTo(-10, -6);\n        ctx.lineTo(-2, 6 + Math.sin(time * 8) * 2);\n        ctx.lineTo(10, -10);\n        ctx.stroke();\n\n        // halo\n        ctx.shadowColor = 'rgba(255,230,120,0.8)';\n        ctx.shadowBlur = 24 * litAmt;\n        ctx.fillStyle = `rgba(255,220,120,${0.08 + 0.25 * litAmt})`;\n        ctx.beginPath();\n        ctx.ellipse(0, -6, this.r * 1.6, this.r * 1.2, 0, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.shadowBlur = 0;\n      } else {\n        // unlit filament\n        ctx.strokeStyle = '#6d6d6d';\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.moveTo(-10, -6);\n        ctx.lineTo(-2, 6);\n        ctx.lineTo(10, -10);\n        ctx.stroke();\n      }\n\n      // base metal\n      ctx.fillStyle = '#9e9e9e';\n      roundRect(ctx, -28, 20, 56, 18, 4);\n      ctx.fill();\n\n      // text: target and current sum\n      ctx.fillStyle = '#fff';\n      ctx.font = '12px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(`Need ${this.target}`, 0, 56);\n\n      const sum = this.currentSum(batteries);\n      ctx.fillStyle = sum > this.target ? '#ffcccc' : '#bfefff';\n      ctx.font = '16px bold sans-serif';\n      ctx.fillText(`${sum}/${this.target}`, 0, 40);\n\n      // focus ring\n      if (this.focused) {\n        ctx.strokeStyle = 'rgba(180,220,255,0.9)';\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n        ctx.arc(0, -6, this.r + 8, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  // Game logic\n  class Game {\n    constructor(ctx) {\n      this.ctx = ctx;\n      this.last = performance.now();\n      this.batteries = [];\n      this.bulbs = [];\n      this.characters = [\n        new Character('Sparky', '#ff8a80', 110, 110),\n        new Character('Volt', '#82b1ff', 610, 120)\n      ];\n      this.selectedBattery = null;\n      this.selectedBatteryIndex = -1;\n      this.focusList = []; // order: batteries then bulbs\n      this.focusIndex = 0;\n      this.mouseOver = null;\n      this.electrons = []; // for animation along wires\n      this.time = 0;\n      this.audioOn = sound.enabled && sound.available;\n      this.announced = '';\n      this.generatePuzzle();\n      this.bindEvents();\n      this.running = true;\n      this.frame = this.frame.bind(this);\n      requestAnimationFrame(this.frame);\n    }\n\n    generatePuzzle() {\n      this.batteries = [];\n      this.bulbs = [];\n      // choose 3 bulbs with targets between 5 and 15\n      const possibleTargets = [5, 6, 7, 8, 9, 10, 11, 12, 13];\n      for (let i = 0; i < 3; i++) {\n        const target = possibleTargets.splice(randInt(0, possibleTargets.length - 1), 1)[0];\n        const x = 180 + i * 180;\n        const y = 200;\n        this.bulbs.push(new Bulb(i, target, x, y));\n      }\n      // Create batteries: ensure solvability by creating for each bulb 2-3 numbers that sum to target\n      const usedVals = [];\n      let bid = 0;\n      this.bulbs.forEach((bulb) => {\n        // create 2 addends usually, sometimes 3\n        const parts = Math.random() < 0.3 ? 3 : 2;\n        let remaining = bulb.target;\n        for (let p = 0; p < parts; p++) {\n          const maxVal = Math.min(9, remaining - (parts - p - 1) * 1);\n          const minVal = Math.max(1, Math.floor(remaining / (parts - p)) - 2);\n          let v = randInt(minVal, maxVal);\n          // avoid duplicates too much\n          if (usedVals.includes(v)) v = Math.max(1, v - 1);\n          remaining -= v;\n          usedVals.push(v);\n          const bx = 80 + (usedVals.length - 1) * 90 + (Math.random() * 20 - 10);\n          const by = 360 + (Math.random() * 40 - 20);\n          this.batteries.push(new Battery(bid++, v, bx, by));\n          // attach logically? no, they start free\n        }\n      });\n      // Add a few extra batteries as distractors\n      const extras = 3;\n      for (let i = 0; i < extras; i++) {\n        const v = randInt(1, 9);\n        const bx = 80 + (this.batteries.length) * 82 + (Math.random() * 20 - 10);\n        const by = 360 + (Math.random() * 40 - 20);\n        this.batteries.push(new Battery(bid++, v, bx, by));\n      }\n\n      // Randomize battery positions a bit\n      this.batteries.forEach((b, i) => {\n        b.x = 70 + i * 90;\n        b.y = 350 + (i % 2 === 0 ? -8 : 8);\n        b.visible = true;\n        b.attachedTo = null;\n      });\n\n      // Build focus list\n      this.focusList = [...this.batteries.map(b => ({ type: 'battery', id: b.id })), ...this.bulbs.map(b => ({ type: 'bulb', id: b.id }))];\n      this.focusIndex = 0;\n      this.updateFocus();\n      this.electrons = [];\n      live.textContent = 'New puzzle. Drag number batteries to bulbs to make the sums match the needed values.';\n      this.announce('New puzzle ready. Drag batteries to bulbs to match the numbers.');\n    }\n\n    updateFocus() {\n      // clear all\n      this.batteries.forEach(b => b.focused = false);\n      this.bulbs.forEach(b => b.focused = false);\n      const focused = this.focusList[this.focusIndex];\n      if (!focused) return;\n      if (focused.type === 'battery') {\n        const b = this.batteries.find(bb => bb.id === focused.id);\n        if (b) b.focused = true;\n      } else {\n        const bl = this.bulbs.find(bb => bb.id === focused.id);\n        if (bl) bl.focused = true;\n      }\n    }\n\n    bindEvents() {\n      // Mouse\n      canvas.addEventListener('mousedown', (e) => {\n        const rect = canvas.getBoundingClientRect();\n        mouse.x = e.clientX - rect.left;\n        mouse.y = e.clientY - rect.top;\n        mouse.down = true;\n        this.onPointerDown(mouse.x, mouse.y);\n      });\n      window.addEventListener('mousemove', (e) => {\n        const rect = canvas.getBoundingClientRect();\n        mouse.x = e.clientX - rect.left;\n        mouse.y = e.clientY - rect.top;\n        if (mouse.down) this.onPointerMove(mouse.x, mouse.y);\n      });\n      window.addEventListener('mouseup', (e) => {\n        if (mouse.down) {\n          const rect = canvas.getBoundingClientRect();\n          mouse.x = e.clientX - rect.left;\n          mouse.y = e.clientY - rect.top;\n          this.onPointerUp(mouse.x, mouse.y);\n        }\n        mouse.down = false;\n      });\n\n      // Touch\n      canvas.addEventListener('touchstart', (e) => {\n        e.preventDefault();\n        if (touchId !== null) return;\n        const t = e.changedTouches[0];\n        touchId = t.identifier;\n        const rect = canvas.getBoundingClientRect();\n        const x = t.clientX - rect.left;\n        const y = t.clientY - rect.top;\n        mouse.x = x; mouse.y = y; mouse.down = true;\n        this.onPointerDown(x, y);\n      }, { passive: false });\n      canvas.addEventListener('touchmove', (e) => {\n        e.preventDefault();\n        for (let t of e.changedTouches) {\n          if (t.identifier === touchId) {\n            const rect = canvas.getBoundingClientRect();\n            const x = t.clientX - rect.left;\n            const y = t.clientY - rect.top;\n            mouse.x = x; mouse.y = y;\n            this.onPointerMove(x, y);\n            break;\n          }\n        }\n      }, { passive: false });\n      canvas.addEventListener('touchend', (e) => {\n        e.preventDefault();\n        for (let t of e.changedTouches) {\n          if (t.identifier === touchId) {\n            const rect = canvas.getBoundingClientRect();\n            const x = t.clientX - rect.left;\n            const y = t.clientY - rect.top;\n            this.onPointerUp(x, y);\n            touchId = null;\n            mouse.down = false;\n            break;\n          }\n        }\n      }, { passive: false });\n\n      // Keyboard controls\n      canvas.addEventListener('keydown', async (e) => {\n        // Ensure audio resumed on user gesture\n        if (sound.available) await sound.resume();\n\n        if (e.key === 'Tab') {\n          e.preventDefault();\n          // cycle focus\n          this.focusIndex = (this.focusIndex + 1) % this.focusList.length;\n          this.updateFocus();\n          sound.tap();\n          this.announce('Focus moved');\n        } else if (e.key === 'Enter' || e.key === ' ') {\n          e.preventDefault();\n          // pick up or drop depending on focus\n          const focused = this.focusList[this.focusIndex];\n          if (!focused) return;\n          if (focused.type === 'battery') {\n            const battery = this.batteries.find(b => b.id === focused.id);\n            if (!this.selectedBattery) {\n              // pick up\n              this.selectedBattery = battery;\n              this.selectedBattery.drag = true;\n              this.selectedBattery.offsetX = 0;\n              this.selectedBattery.offsetY = 0;\n              sound.click();\n              this.announce(`Picked up battery ${battery.val}`);\n            } else if (this.selectedBattery.id === battery.id) {\n              // drop where it is\n              this.selectedBattery.drag = false;\n              this.selectedBattery = null;\n              sound.tap();\n              this.announce('Placed battery down');\n            } else {\n              // pick another: drop previous, pick this\n              this.selectedBattery.drag = false;\n              this.selectedBattery = battery;\n              this.selectedBattery.drag = true;\n              sound.click();\n              this.announce(`Picked up battery ${battery.val}`);\n            }\n          } else if (focused.type === 'bulb') {\n            const bulb = this.bulbs.find(b => b.id === focused.id);\n            if (this.selectedBattery) {\n              // attempt attach\n              this.tryAttach(this.selectedBattery, bulb);\n            } else {\n              // give hint\n              const sum = bulb.currentSum(this.batteries);\n              this.announce(`Bulb needs ${bulb.target}. It currently has ${sum}.`);\n            }\n          }\n        } else if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {\n          // move selected battery if any\n          if (this.selectedBattery) {\n            switch (e.key) {\n              case 'ArrowLeft': this.selectedBattery.x -= 12; break;\n              case 'ArrowRight': this.selectedBattery.x += 12; break;\n              case 'ArrowUp': this.selectedBattery.y -= 12; break;\n              case 'ArrowDown': this.selectedBattery.y += 12; break;\n            }\n            sound.tap();\n          }\n        } else if (e.key === 'r' || e.key === 'R') {\n          // reset / new puzzle\n          this.generatePuzzle();\n          sound.tap();\n        } else if (e.key === 'm' || e.key === 'M') {\n          // toggle audio\n          this.audioOn = !this.audioOn;\n          sound.setEnabled(this.audioOn);\n          this.announce(`Audio ${this.audioOn ? 'on' : 'off'}`);\n        }\n      });\n\n      // For accessibility: focus canvas on click\n      canvas.addEventListener('focus', () => {\n        this.announce('Game focused. Tab to cycle through batteries and bulbs. Enter to pick up or attach. Arrow keys move picked battery. Press R for new puzzle. Press M to toggle audio.');\n      });\n    }\n\n    onPointerDown(x, y) {\n      // pick battery if clicked\n      const b = this.batteries.slice().reverse().find(bb => bb.visible && bb.contains(x, y));\n      if (b) {\n        this.selectedBattery = b;\n        b.drag = true;\n        b.offsetX = x - b.x;\n        b.offsetY = y - b.y;\n        // focus to this battery\n        this.focusIndex = this.focusList.findIndex(f => f.type === 'battery' && f.id === b.id);\n        this.updateFocus();\n        sound.click();\n        this.announce(`Picked up battery ${b.val}`);\n        return;\n      }\n      // if clicked on a bulb and carrying battery, attach\n      const bl = this.bulbs.find(bb => bb.contains(x, y));\n      if (bl && this.selectedBattery) {\n        this.tryAttach(this.selectedBattery, bl);\n        return;\n      }\n      // clicked empty: drop selected battery\n      if (this.selectedBattery) {\n        this.selectedBattery.drag = false;\n        this.announce('Placed battery');\n        this.selectedBattery = null;\n        sound.tap();\n      }\n    }\n\n    onPointerMove(x, y) {\n      if (this.selectedBattery && this.selectedBattery.drag) {\n        this.selectedBattery.x = x - this.selectedBattery.offsetX;\n        this.selectedBattery.y = y - this.selectedBattery.offsetY;\n      } else {\n        // highlight hovered battery or bulb\n        const overB = this.batteries.find(bb => bb.visible && bb.contains(x, y));\n        if (overB) {\n          this.mouseOver = { type: 'battery', id: overB.id };\n        } else {\n          const overBulb = this.bulbs.find(bb => bb.contains(x, y));\n          if (overBulb) this.mouseOver = { type: 'bulb', id: overBulb.id }; else this.mouseOver = null;\n        }\n      }\n    }\n\n    onPointerUp(x, y) {\n      if (this.selectedBattery && this.selectedBattery.drag) {\n        // check if over a bulb to attach\n        const overBulb = this.bulbs.find(bb => bb.contains(x, y));\n        if (overBulb) {\n          this.tryAttach(this.selectedBattery, overBulb);\n        } else {\n          // drop\n          this.selectedBattery.drag = false;\n          this.selectedBattery = null;\n          sound.tap();\n        }\n      }\n    }\n\n    tryAttach(battery, bulb) {\n      if (!battery || !bulb) return;\n      // If already attached to some bulb, detach first\n      if (battery.attachedTo !== null) {\n        const oldBulb = this.bulbs.find(b => b.id === battery.attachedTo);\n        if (oldBulb) {\n          oldBulb.attached = oldBulb.attached.filter(id => id !== battery.id);\n        }\n      }\n      // attach\n      battery.attachedTo = bulb.id;\n      bulb.attached.push(battery.id);\n      battery.visible = true;\n      battery.drag = false;\n      // Snap battery position near bulb\n      const angle = (bulb.attached.length - 1) * 0.6 - 0.6;\n      const dist = bulb.r + 30;\n      battery.x = bulb.x + Math.cos(angle) * dist;\n      battery.y = bulb.y + Math.sin(angle) * dist;\n      sound.click();\n      // Check correctness\n      const sum = bulb.currentSum(this.batteries);\n      if (sum === bulb.target) {\n        // success: play sound, animate electrons\n        sound.success();\n        this.spawnElectrons(bulb);\n        this.announce(`Bulb ${bulb.id + 1} lit! You matched ${bulb.target}.`);\n      } else if (sum > bulb.target) {\n        // too much\n        sound.error();\n        this.announce(`Too much! Bulb ${bulb.id + 1} needs ${bulb.target} but has ${sum}. Remove some batteries.`);\n      } else {\n        // partial\n        sound.tap();\n        this.announce(`Good. Bulb ${bulb.id + 1} now has ${sum} of ${bulb.target}.`);\n      }\n\n      // clear selected battery\n      if (this.selectedBattery && this.selectedBattery.id === battery.id) {\n        this.selectedBattery = null;\n      }\n    }\n\n    spawnElectrons(bulb) {\n      // Create animated electrons that flow from battery positions to bulb center\n      const attachedBats = bulb.attached.map(id => this.batteries.find(b => b.id === id)).filter(Boolean);\n      attachedBats.forEach((bat, i) => {\n        for (let k = 0; k < Math.min(4, bat.val); k++) {\n          this.electrons.push({\n            x: bat.x,\n            y: bat.y,\n            tx: bulb.x,\n            ty: bulb.y - 6,\n            life: 0,\n            speed: 0.02 + Math.random() * 0.02,\n            color: `hsl(${50 + Math.random() * 30}, 90%, 60%)`\n          });\n        }\n      });\n    }\n\n    update(dt) {\n      this.time += dt;\n      this.characters.forEach(c => c.update(dt));\n      // update bulbs\n      this.bulbs.forEach(b => b.update(dt, this.batteries));\n      // update electrons\n      this.electrons = this.electrons.filter(e => e.life < 1);\n      this.electrons.forEach(e => {\n        e.life = Math.min(1, e.life + e.speed);\n        // ease\n        const t = easeOutCubic(e.life);\n        e.x = lerp(e.x, e.tx, t);\n        e.y = lerp(e.y, e.ty, t);\n      });\n\n      // Check win: all bulbs lit\n      if (this.bulbs.every(b => b.lit)) {\n        // Celebrate: create more electrons across bulbs\n        if (!this.celebrated) {\n          this.celebrated = true;\n          sound.success();\n          this.announce('All bulbs lit! Great job! Press R to play again.');\n          // little fireworks of electrons\n          this.bulbs.forEach((bulb) => {\n            for (let i = 0; i < 12; i++) {\n              this.electrons.push({\n                x: bulb.x + (Math.random() * 160 - 80),\n                y: bulb.y + (Math.random() * 160 - 80),\n                tx: bulb.x,\n                ty: bulb.y - 6,\n                life: 0,\n                speed: 0.02 + Math.random() * 0.03,\n                color: `hsl(${40 + Math.random() * 40}, 90%, 60%)`\n              });\n            }\n          });\n        }\n      } else {\n        this.celebrated = false;\n      }\n    }\n\n    frame(now) {\n      if (!this.running) return;\n      const dt = Math.min(0.05, (now - this.last) / 1000);\n      this.last = now;\n      this.update(dt);\n      this.render(now / 1000);\n      requestAnimationFrame(this.frame);\n    }\n\n    render(time) {\n      // background grid and wires\n      const ctx = this.ctx;\n      ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n      // background gradient\n      const bg = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n      bg.addColorStop(0, '#071022');\n      bg.addColorStop(1, '#08162a');\n      ctx.fillStyle = bg;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n      // gentle circuit board pattern\n      this.drawCircuitBoard(ctx, time);\n\n      // draw characters\n      this.characters.forEach(c => c.draw(ctx));\n\n      // draw bulbs\n      this.bulbs.forEach(b => b.draw(ctx, this.batteries, time));\n\n      // draw wires from batteries to bulbs\n      this.drawWires(ctx, time);\n\n      // draw batteries\n      this.batteries.forEach(b => b.draw(ctx));\n\n      // draw electrons\n      this.electrons.forEach(e => {\n        ctx.save();\n        ctx.globalCompositeOperation = 'lighter';\n        ctx.fillStyle = e.color;\n        ctx.beginPath();\n        ctx.arc(e.x, e.y, 4, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n      });\n\n      // UI overlay: instructions and buttons\n      this.drawUI(ctx);\n\n      // If audio unavailable show icon\n      this.drawAudioIcon(ctx);\n\n      // Tooltip or focus info\n      if (this.mouseOver) {\n        ctx.fillStyle = 'rgba(0,0,0,0.6)';\n        ctx.fillRect(12, HEIGHT - 66, 260, 48);\n        ctx.fillStyle = '#fff';\n        ctx.font = '14px sans-serif';\n        ctx.textAlign = 'left';\n        if (this.mouseOver.type === 'battery') {\n          const b = this.batteries.find(bb => bb.id === this.mouseOver.id);\n          ctx.fillText(`Battery ${b.val}. Drag to a bulb to add.`, 22, HEIGHT - 40);\n        } else {\n          const bl = this.bulbs.find(bb => bb.id === this.mouseOver.id);\n          ctx.fillText(`Bulb needs ${bl.target}. Current ${bl.currentSum(this.batteries)}.`, 22, HEIGHT - 40);\n        }\n      }\n\n      // Draw focus instruction\n      ctx.fillStyle = '#fff';\n      ctx.font = '12px sans-serif';\n      ctx.textAlign = 'left';\n      ctx.fillText('Tab: change focus \u2022 Enter: pick/place \u2022 Arrows: move picked battery \u2022 R: reset \u2022 M: audio', 12, HEIGHT - 12);\n    }\n\n    drawCircuitBoard(ctx, time) {\n      // soft glowing grid lines\n      ctx.save();\n      ctx.globalAlpha = 0.12;\n      ctx.strokeStyle = '#49a6ff';\n      ctx.lineWidth = 1;\n      for (let x = 0; x < WIDTH; x += 40) {\n        ctx.beginPath();\n        ctx.moveTo(x + Math.sin(time + x * 0.01) * 2, 0);\n        ctx.lineTo(x + Math.sin(time + x * 0.01) * 2, HEIGHT);\n        ctx.stroke();\n      }\n      for (let y = 0; y < HEIGHT; y += 40) {\n        ctx.beginPath();\n        ctx.moveTo(0, y + Math.cos(time + y * 0.01) * 2);\n        ctx.lineTo(WIDTH, y + Math.cos(time + y * 0.01) * 2);\n        ctx.stroke();\n      }\n      ctx.globalAlpha = 1;\n      ctx.restore();\n    }\n\n    drawWires(ctx, time) {\n      ctx.save();\n      ctx.lineWidth = 6;\n      ctx.lineCap = 'round';\n      this.bulbs.forEach((bulb) => {\n        bulb.attached.forEach((bid, i) => {\n          const b = this.batteries.find(bb => bb.id === bid);\n          if (!b) return;\n          // color glows more if bulb lit\n          const litAmt = bulb.glow;\n          // compute bezier from battery to bulb\n          const sx = b.x, sy = b.y;\n          const tx = bulb.x, ty = bulb.y - 6;\n          const mx = (sx + tx) / 2;\n          ctx.beginPath();\n          const cp1x = mx + (sy - ty) * 0.12;\n          const cp1y = sy + (ty - sy) * 0.4;\n          const cp2x = mx - (sy - ty) * 0.12;\n          const cp2y = ty - (ty - sy) * 0.4;\n          // glowing stroke\n          const grad = ctx.createLinearGradient(sx, sy, tx, ty);\n          grad.addColorStop(0, `rgba(255,200,90,${0.5})`);\n          grad.addColorStop(1, `rgba(180,240,255,${0.6 + litAmt * 0.4})`);\n          ctx.strokeStyle = grad;\n          ctx.lineWidth = 6 + litAmt * 8;\n          ctx.beginPath();\n          ctx.moveTo(sx, sy);\n          ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tx, ty);\n          ctx.stroke();\n\n          // inner bright line\n          ctx.strokeStyle = `rgba(255,255,210,${0.9})`;\n          ctx.lineWidth = 2 + litAmt * 4;\n          ctx.beginPath();\n          ctx.moveTo(sx, sy);\n          ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tx, ty);\n          ctx.stroke();\n        });\n      });\n      ctx.restore();\n    }\n\n    drawUI(ctx) {\n      // left top: title\n      ctx.fillStyle = '#fff';\n      ctx.font = '24px sans-serif';\n      ctx.textAlign = 'left';\n      ctx.fillText('Charge the Bulbs!', 12, 36);\n\n      // subtitle\n      ctx.fillStyle = '#bfe8ff';\n      ctx.font = '14px sans-serif';\n      ctx.fillText('Help Sparky and Volt by adding number batteries to make each bulb reach its target.', 12, 58);\n\n      // Draw a Reset button (canvas-only)\n      const bx = WIDTH - 120, by = 18, bw = 104, bh = 36;\n      // button background\n      ctx.fillStyle = 'rgba(255,255,255,0.06)';\n      roundRect(ctx, bx, by, bw, bh, 8);\n      ctx.fill();\n\n      // button text\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 16px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('New Puzzle (R)', bx + bw / 2, by + 24);\n\n      // handle click on reset using pointer coordinates: we detect everywhere in pointerdown, but also offer keyboard R\n\n      // Draw audio toggle button\n      const ax = WIDTH - 260, ay = 18, aw = 120, ah = 36;\n      ctx.fillStyle = 'rgba(255,255,255,0.06)';\n      roundRect(ctx, ax, ay, aw, ah, 8);\n      ctx.fill();\n      ctx.fillStyle = '#fff';\n      ctx.font = '14px sans-serif';\n      ctx.fillText(`Audio: ${this.audioOn ? 'On (M)' : 'Off (M)'}`, ax + aw / 2, ay + 24);\n    }\n\n    drawAudioIcon(ctx) {\n      const x = WIDTH - 34, y = HEIGHT - 34;\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = this.audioOn ? '#ffd54f' : '#555';\n      ctx.arc(x, y, 14, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = this.audioOn ? '#222' : '#222';\n      ctx.font = '12px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(this.audioOn ? '\ud83d\udd0a' : '\ud83d\udd08', x, y + 4);\n      // If audio unavailable show cross\n      if (!sound.available) {\n        ctx.fillStyle = '#ff8a80';\n        ctx.font = '10px sans-serif';\n        ctx.fillText('Audio Unavailable', WIDTH - 160, HEIGHT - 14);\n      }\n      ctx.restore();\n    }\n\n    announce(text) {\n      if (text === this.announced) return;\n      this.announced = text;\n      live.textContent = text;\n    }\n  }\n\n  // Helpers\n  function lerp(a, b, t) { return a + (b - a) * t; }\n  function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }\n\n  // Start game\n  const game = new Game(ctx);\n\n  // Additional pointer handling for UI buttons: detect clicks on areas (Reset & Audio)\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left, y = e.clientY - rect.top;\n    // Reset button area\n    if (x >= WIDTH - 120 && x <= WIDTH - 16 && y >= 18 && y <= 54) {\n      game.generatePuzzle();\n      sound.tap();\n      return;\n    }\n    // Audio toggle\n    if (x >= WIDTH - 260 && x <= WIDTH - 140 && y >= 18 && y <= 54) {\n      game.audioOn = !game.audioOn;\n      sound.setEnabled(game.audioOn);\n      game.announce(`Audio ${game.audioOn ? 'on' : 'off'}`);\n      return;\n    }\n    // Speaker icon\n    if (x >= WIDTH - 52 && x <= WIDTH - 16 && y >= HEIGHT - 52 && y <= HEIGHT - 16) {\n      game.audioOn = !game.audioOn;\n      sound.setEnabled(game.audioOn);\n      game.announce(`Audio ${game.audioOn ? 'on' : 'off'}`);\n      return;\n    }\n  });\n\n  // Ensure audio resumes on first user interaction (polite)\n  window.addEventListener('click', async function resumeAudioOnce() {\n    await sound.resume();\n    window.removeEventListener('click', resumeAudioOnce);\n  });\n\n  // Make sure canvas is focusable and initially focused for keyboard\n  canvas.focus();\n\n})();\n---\n",
  "improve_response_tokens": 22322,
  "formatted_code": true,
  "formatting_response_tokens": 23475,
  "final_functionality": {
    "score": 7,
    "max_score": 8,
    "percentage": 87.5,
    "passing": true,
    "issues": [],
    "warnings": [
      "No game state management found"
    ]
  }
}