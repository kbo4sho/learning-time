# Game of the Day - 2025-08-19

## Metadata
- **Generated Date:** 2025-08-19
- **Generated Time:** 2025-08-19T00:22:03.584014
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-19.js
- **File Size:** 28220 bytes
- **Tokens Used:** 9752

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-19.js` - The playable game
- `2025-08-19.meta.json` - Machine-readable metadata
- `2025-08-19.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20223

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22377

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Electricity Math Game for ages 7-9
// Renders into existing element with id "game-of-the-day-stage"
// Game: "Spark Squad: Power-Up Puzzle"
// Concept: addition to reach a target voltage by selecting battery cells
// All graphics drawn via canvas, sounds generated by Web Audio API oscillators
// Accessible: keyboard controls, offscreen instructions for screen readers, aria labels, visual audio indicator

(function () {
  // Configuration
  const STAGE_ID = 'game-of-the-day-stage';
  const WIDTH = 720;
  const HEIGHT = 480;
  const BATTERY_COUNT = 6;
  const MIN_TARGET = 10;
  const MAX_TARGET = 30;
  const LEVEL_TIME = 45; // seconds per round optional (not enforced heavily)
  const ELECTRON_COLOR = '#ffee66';

  // Get container
  const container = document.getElementById(STAGE_ID);
  if (!container) {
    console.error('Game container not found: #' + STAGE_ID);
    return;
  }

  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative'; // ensure we can position things inside

  // Create offscreen text for screen readers (accessible instructions)
  const srText = document.createElement('div');
  srText.setAttribute('aria-hidden', 'false');
  srText.style.position = 'absolute';
  srText.style.left = '-9999px';
  srText.style.top = 'auto';
  srText.style.width = '1px';
  srText.style.height = '1px';
  srText.style.overflow = 'hidden';
  srText.id = 'spark-squad-instructions';
  srText.innerText =
    'Spark Squad: Power-Up Puzzle. Use arrow keys to move between batteries. Press Space or Enter to select a battery to add to the circuit. Press Backspace or C to clear selection. Press M to toggle sound. Choose batteries to add up to the target number shown. When you hit the correct number, the bulb lights!';
  container.appendChild(srText);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.style.display = 'block';
  canvas.style.background = '#10202b'; // calm background
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Spark Squad electricity math game canvas');
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Audio setup with error handling
  let audioCtx = null;
  let audioAllowed = true;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
  } catch (err) {
    console.warn('Web Audio API not supported or failed to create context:', err);
    audioAllowed = false;
    audioCtx = null;
  }

  // Create master gain node if audio context exists
  let masterGain = null;
  if (audioCtx) {
    try {
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.8;
      masterGain.connect(audioCtx.destination);
    } catch (err) {
      console.warn('Failed to create gain node:', err);
      audioAllowed = false;
      masterGain = null;
    }
  }

  // Helper to resume audio context on user gesture
  async function ensureAudioRunning() {
    if (!audioAllowed || !audioCtx) return false;
    try {
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }
      return true;
    } catch (err) {
      console.warn('Could not resume audio context:', err);
      return false;
    }
  }

  // Sound generators using Web Audio API
  function playClick() {
    if (!audioAllowed || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'square';
      o.frequency.setValueAtTime(880, audioCtx.currentTime);
      g.gain.setValueAtTime(0, audioCtx.currentTime);
      g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);
      o.connect(g);
      g.connect(masterGain);
      o.start();
      o.stop(audioCtx.currentTime + 0.2);
    } catch (err) {
      console.warn('Error playing click sound:', err);
    }
  }

  function playCorrect() {
    if (!audioAllowed || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const freqs = [440, 660, 880];
      freqs.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(f, now + i * 0.08);
        g.gain.setValueAtTime(0, now + i * 0.08);
        g.gain.linearRampToValueAtTime(0.12, now + i * 0.08 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.28);
        o.connect(g);
        g.connect(masterGain);
        o.start(now + i * 0.08);
        o.stop(now + i * 0.08 + 0.3);
      });
    } catch (err) {
      console.warn('Error playing correct sound:', err);
    }
  }

  function playIncorrect() {
    if (!audioAllowed || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const f = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(220, audioCtx.currentTime);
      f.type = 'lowpass';
      f.frequency.setValueAtTime(600, audioCtx.currentTime);
      g.gain.setValueAtTime(0.001, audioCtx.currentTime);
      g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
      o.connect(f);
      f.connect(g);
      g.connect(masterGain);
      o.start();
      o.stop(audioCtx.currentTime + 0.5);
    } catch (err) {
      console.warn('Error playing incorrect sound:', err);
    }
  }

  // Gentle background hum (subtle)
  let humOsc = null;
  function startBackgroundHum() {
    if (!audioAllowed || !audioCtx || !masterGain) return;
    try {
      if (humOsc) return;
      humOsc = audioCtx.createOscillator();
      const humGain = audioCtx.createGain();
      humOsc.type = 'sine';
      humOsc.frequency.setValueAtTime(55, audioCtx.currentTime);
      humGain.gain.value = 0.02;
      humOsc.connect(humGain);
      humGain.connect(masterGain);
      humOsc.start();
    } catch (err) {
      console.warn('Could not start background hum:', err);
    }
  }

  function stopBackgroundHum() {
    if (!humOsc) return;
    try {
      humOsc.stop();
    } catch (err) {
      // ignore
    }
    humOsc = null;
  }

  // Game state
  const state = {
    level: 1,
    target: randInt(MIN_TARGET, MAX_TARGET),
    batteries: [],
    selectedIndices: new Set(),
    batteriesSelectedSum: 0,
    selectedIndex: 0,
    solved: false,
    score: 0,
    timeLeft: LEVEL_TIME,
    showMessage: '',
    messageTimer: 0,
    soundOn: audioAllowed,
    electrons: [], // animated moving particles along wires
    lastTick: performance.now(),
  };

  // Initialize batteries for a new round
  function resetRound() {
    state.target = randInt(MIN_TARGET + state.level - 1, MAX_TARGET + state.level - 1);
    state.batteries = [];
    state.selectedIndices.clear();
    state.batteriesSelectedSum = 0;
    state.selectedIndex = 0;
    state.solved = false;
    state.timeLeft = LEVEL_TIME;
    state.showMessage = '';
    state.messageTimer = 0;
    // generate battery values ensuring solution exists (simple method: generate some random then add one that ensures solvable)
    // create some random small numbers and ensure some subset sums to target by constructing a subset
    // We'll create a subset sum by selecting some random addends that sum to target (split target)
    let remaining = state.target;
    const parts = [];
    // ensure between 2 and BATTERY_COUNT parts
    const partCount = randInt(2, Math.min(BATTERY_COUNT, Math.max(2, Math.floor(state.target / 4))));
    for (let i = 0; i < partCount - 1; i++) {
      const maxPart = Math.max(1, Math.floor(remaining / (partCount - i)));
      const val = randInt(1, Math.max(1, Math.min(maxPart, 9)));
      parts.push(val);
      remaining -= val;
    }
    parts.push(Math.max(1, remaining));
    // If parts length < battery count, fill with random distractors
    while (parts.length < BATTERY_COUNT) {
      parts.push(randInt(1, 9));
    }
    // Shuffle and assign to batteries
    shuffleArray(parts);
    for (let i = 0; i < BATTERY_COUNT; i++) {
      const value = parts[i] || randInt(1, 9);
      state.batteries.push({
        value,
        x: 80 + i * ((WIDTH - 160) / (BATTERY_COUNT - 1)),
        y: HEIGHT - 80,
        width: 64,
        height: 32,
        wobble: Math.random() * 1000,
      });
    }
    // create some electrons initially empty
    state.electrons = [];
  }

  // Utility functions
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Input handling
  let pointer = { x: 0, y: 0, down: false };

  canvas.addEventListener('mousemove', (e) => {
    const r = canvas.getBoundingClientRect();
    pointer.x = ((e.clientX - r.left) * (canvas.width / r.width)) || 0;
    pointer.y = ((e.clientY - r.top) * (canvas.height / r.height)) || 0;
  });

  canvas.addEventListener('mousedown', (e) => {
    pointer.down = true;
    handleUserGesture();
    handleClick(pointer.x, pointer.y);
  });

  window.addEventListener('mouseup', () => {
    pointer.down = false;
  });

  canvas.addEventListener('touchstart', (e) => {
    handleUserGesture();
    e.preventDefault();
    if (e.touches[0]) {
      const t = e.touches[0];
      const r = canvas.getBoundingClientRect();
      pointer.x = ((t.clientX - r.left) * (canvas.width / r.width)) || 0;
      pointer.y = ((t.clientY - r.top) * (canvas.height / r.height)) || 0;
      handleClick(pointer.x, pointer.y);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches[0]) {
      const t = e.touches[0];
      const r = canvas.getBoundingClientRect();
      pointer.x = ((t.clientX - r.left) * (canvas.width / r.width)) || 0;
      pointer.y = ((t.clientY - r.top) * (canvas.height / r.height)) || 0;
    }
  }, { passive: false });

  // Keyboard controls
  window.addEventListener('keydown', (e) => {
    // allow arrow keys, space/enter, backspace/C, M for sound toggle
    if (e.key === 'ArrowLeft') {
      state.selectedIndex = (state.selectedIndex - 1 + state.batteries.length) % state.batteries.length;
      e.preventDefault();
      handleUserGesture();
    } else if (e.key === 'ArrowRight') {
      state.selectedIndex = (state.selectedIndex + 1) % state.batteries.length;
      e.preventDefault();
      handleUserGesture();
    } else if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      toggleBatterySelection(state.selectedIndex);
      handleUserGesture();
    } else if (e.key === 'Backspace' || e.key.toLowerCase() === 'c') {
      e.preventDefault();
      clearSelection();
      handleUserGesture();
    } else if (e.key.toLowerCase() === 'm') {
      e.preventDefault();
      toggleSound();
      handleUserGesture();
    }
  });

  function handleClick(x, y) {
    // check if clicked on a battery
    for (let i = 0; i < state.batteries.length; i++) {
      const b = state.batteries[i];
      if (x >= b.x - b.width / 2 && x <= b.x + b.width / 2 && y >= b.y - b.height / 2 && y <= b.y + b.height / 2) {
        state.selectedIndex = i;
        toggleBatterySelection(i);
        return;
      }
    }
    // click on speaker icon to toggle sound
    if (x >= WIDTH - 48 && x <= WIDTH - 16 && y >= 16 && y <= 48) {
      toggleSound();
    }
  }

  function toggleBatterySelection(index) {
    if (state.solved) return;
    if (state.selectedIndices.has(index)) {
      state.selectedIndices.delete(index);
      state.batteriesSelectedSum -= state.batteries[index].value;
      state.showMessage = 'Removed ' + state.batteries[index].value;
      state.messageTimer = 120;
    } else {
      state.selectedIndices.add(index);
      state.batteriesSelectedSum += state.batteries[index].value;
      state.showMessage = 'Added ' + state.batteries[index].value;
      state.messageTimer = 120;
      // spawn electrons moving from battery to bulb
      spawnElectronsForBattery(index);
      playClick();
    }
    checkSolution();
  }

  function clearSelection() {
    if (state.solved) return;
    state.selectedIndices.clear();
    state.batteriesSelectedSum = 0;
    state.showMessage = 'Cleared';
    state.messageTimer = 120;
    playClick();
  }

  function toggleSound() {
    state.soundOn = !state.soundOn;
    if (state.soundOn) {
      // try to resume audio context
      ensureAudioRunning();
      startBackgroundHum();
    } else {
      stopBackgroundHum();
    }
    state.showMessage = state.soundOn ? 'Sound On' : 'Sound Off';
    state.messageTimer = 90;
  }

  // Check whether current selected sum matches target
  function checkSolution() {
    if (state.batteriesSelectedSum === state.target) {
      // success
      state.solved = true;
      state.score += 1;
      state.showMessage = 'Perfect! Bulb lit!';
      state.messageTimer = 180;
      spawnVictoryElectrons();
      if (state.soundOn) playCorrect();
      // schedule next round after a delay
      setTimeout(() => {
        state.level += 1;
        resetRound();
      }, 1500);
    } else if (state.batteriesSelectedSum > state.target) {
      // over target
      state.showMessage = 'Too high!';
      state.messageTimer = 90;
      if (state.soundOn) playIncorrect();
      // small shake or twinkle handled in draw
    } else {
      // still below
      state.showMessage = 'Sum ' + state.batteriesSelectedSum;
      state.messageTimer = 60;
    }
  }

  // Electrons: moving particles along wire from battery to bulb
  function spawnElectronsForBattery(index) {
    const b = state.batteries[index];
    for (let i = 0; i < 6; i++) {
      state.electrons.push({
        fromX: b.x,
        fromY: b.y - 18,
        toX: WIDTH / 2,
        toY: HEIGHT / 2 - 40,
        t: Math.random(), // position along path [0..1]
        speed: 0.008 + Math.random() * 0.008,
        size: 3 + Math.random() * 3,
        hue: 50 + Math.random() * 40,
      });
    }
  }

  function spawnVictoryElectrons() {
    for (let i = 0; i < 60; i++) {
      state.electrons.push({
        fromX: WIDTH / 2,
        fromY: HEIGHT / 2 - 40,
        toX: WIDTH / 2 + (Math.random() - 0.5) * 300,
        toY: HEIGHT / 2 - 40 + (Math.random() - 0.5) * 200,
        t: Math.random(),
        speed: 0.004 + Math.random() * 0.02,
        size: 2 + Math.random() * 4,
        hue: 40 + Math.random() * 200,
      });
    }
  }

  // Main loop
  let rafId = null;
  function startGameLoop() {
    state.lastTick = performance.now();
    if (state.soundOn) startBackgroundHum();
    function tick(now) {
      const dt = Math.min(100, now - state.lastTick);
      update(dt / 1000);
      draw();
      state.lastTick = now;
      rafId = requestAnimationFrame(tick);
    }
    rafId = requestAnimationFrame(tick);
  }

  function stopGameLoop() {
    if (rafId) cancelAnimationFrame(rafId);
  }

  // Update game state
  function update(dt) {
    // update electrons
    for (let i = state.electrons.length - 1; i >= 0; i--) {
      const e = state.electrons[i];
      e.t += e.speed * dt * 60;
      if (e.t > 1.1) {
        state.electrons.splice(i, 1);
      }
    }
    // message timer
    if (state.messageTimer > 0) state.messageTimer--;
  }

  // Drawing helpers
  function drawRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function draw() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background gradient and wacky elements
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#08202a');
    g.addColorStop(1, '#0f3040');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft glowing grid to suggest circuit board
    drawCircuitBackground();

    // Top HUD: title, target, lamp
    drawHUD();

    // Draw "circuit board" center: bulb + wires
    drawBulbAndWires();

    // Draw batteries bottom
    drawBatteries();

    // Draw floating electrons
    drawElectrons();

    // Draw characters - Amp robot and Blinky bulb sidekick
    drawCharacters();

    // Draw message box
    drawMessage();

    // Draw instructions at bottom area
    drawInstructions();

    // Draw sound indicator
    drawSoundIcon();
  }

  // Background: calm circuit-like patterns
  function drawCircuitBackground() {
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = '#0ef';
    ctx.lineWidth = 1;
    for (let i = 0; i < 12; i++) {
      ctx.beginPath();
      const y = 40 + (i * 32) + Math.sin((performance.now() / 700) + i) * 6;
      ctx.moveTo(20, y);
      ctx.bezierCurveTo(200, y + (i % 3) * 6, 520, y - (i % 4) * 8, WIDTH - 20, y + (i % 2) * 4);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawHUD() {
    // Title
    ctx.save();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Spark Squad: Power-Up Puzzle', 18, 28);

    // Level and score
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#bfe';
    ctx.fillText('Level: ' + state.level + '   Score: ' + state.score, 18, 48);

    // Target display with wacky meter
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.font = '28px "Segoe UI", Roboto, sans-serif';
    ctx.fillText('Target Voltage', WIDTH / 2, 40);
    // meter box
    const boxW = 220;
    ctx.fillStyle = '#0b3a3e';
    drawRoundedRect(WIDTH / 2 - boxW / 2, 48, boxW, 46, 10);
    ctx.fillStyle = '#0ff';
    ctx.font = 'bold 36px sans-serif';
    ctx.fillText(state.target + ' V', WIDTH / 2, 82);
    ctx.restore();
  }

  function drawBulbAndWires() {
    const cx = WIDTH / 2;
    const cy = HEIGHT / 2 - 40;

    // wires from each battery to bulb center
    for (let i = 0; i < state.batteries.length; i++) {
      const b = state.batteries[i];
      ctx.beginPath();
      const startX = b.x;
      const startY = b.y - 18;
      const cp1x = startX;
      const cp1y = startY - 60 - (i - state.batteries.length / 2) * 6;
      const cp2x = cx - 40 + (i - state.batteries.length / 2) * 8;
      const cp2y = cy + 10;
      ctx.moveTo(startX, startY);
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, cx, cy);
      // style depending on whether selected
      if (state.selectedIndices.has(i)) {
        const grad = ctx.createLinearGradient(startX, startY, cx, cy);
        grad.addColorStop(0, '#ffd966');
        grad.addColorStop(1, '#ff9900');
        ctx.strokeStyle = grad;
        ctx.lineWidth = 6;
        ctx.shadowBlur = 14;
        ctx.shadowColor = '#ffd966';
      } else {
        ctx.strokeStyle = '#204a4f';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 0;
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // Bulb base and glass
    ctx.save();
    // base
    ctx.fillStyle = '#333';
    ctx.fillRect(cx - 22, cy + 26, 44, 18);
    ctx.fillStyle = '#232';
    ctx.fillRect(cx - 18, cy + 28, 36, 14);

    // glass
    const lit = state.solved;
    const g = ctx.createRadialGradient(cx, cy - 10, 6, cx, cy - 10, 80);
    if (lit) {
      g.addColorStop(0, '#ffffaa');
      g.addColorStop(0.5, '#ffdd66');
      g.addColorStop(1, 'rgba(255,200,100,0.06)');
    } else {
      g.addColorStop(0, '#dfefff');
      g.addColorStop(1, 'rgba(255,255,255,0.02)');
    }
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(cx, cy - 18, 48, 60, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    // filament or sparkle
    ctx.save();
    if (lit) {
      // filament glowing crown
      for (let i = 0; i < 10; i++) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,220,120,${0.08 + Math.random() * 0.12})`;
        ctx.lineWidth = 1.2;
        ctx.moveTo(cx - 20 + Math.random() * 40, cy - 40 + Math.random() * 12);
        ctx.lineTo(cx + (Math.random() - 0.5) * 30, cy - 10 + Math.random() * 15);
        ctx.stroke();
      }
    } else {
      // filament shape
      ctx.beginPath();
      ctx.strokeStyle = '#553300';
      ctx.lineWidth = 2.5;
      ctx.moveTo(cx - 12, cy - 6);
      ctx.quadraticCurveTo(cx, cy - 28, cx + 12, cy - 6);
      ctx.stroke();
    }
    ctx.restore();

    // label near bulb showing current sum
    ctx.save();
    ctx.fillStyle = '#fff';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Current Sum: ' + state.batteriesSelectedSum + ' V', cx, cy + 80);
    ctx.restore();
  }

  function drawBatteries() {
    for (let i = 0; i < state.batteries.length; i++) {
      const b = state.batteries[i];
      const x = b.x;
      const y = b.y;
      const w = b.width;
      const h = b.height;

      // wobble for life
      const wob = Math.sin((performance.now() + b.wobble) / 300) * 3;

      ctx.save();
      ctx.translate(x, y + wob);

      // battery body
      ctx.fillStyle = '#112';
      ctx.fillRect(-w / 2, -h / 2, w, h);
      // positive cap
      ctx.fillStyle = '#ffd966';
      ctx.fillRect(w / 2 - 6, -h / 4, 6, h / 2);
      // decorative stripes
      ctx.fillStyle = '#223';
      ctx.fillRect(-w / 2 + 6, -h / 2 + 4, w - 12, h - 8);
      // value panel
      ctx.fillStyle = state.selectedIndices.has(i) ? '#ffdd66' : '#9ee';
      drawRoundedRect(-w / 2 + 8, -h / 2 + 6, w - 16, h - 12, 4);

      // battery value text
      ctx.fillStyle = '#033';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.value + 'V', 0, 0);

      // highlight selected rectangle
      if (state.selectedIndex === i) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(-w / 2 - 6, -h / 2 - 6, w + 12, h + 12);
      }

      ctx.restore();
    }
  }

  function drawElectrons() {
    for (const e of state.electrons) {
      const t = Math.min(1, e.t);
      // simple linear interpolation with slight curve
      const cx1 = e.fromX;
      const cy1 = e.fromY;
      const cx2 = (e.fromX + e.toX) / 2;
      const cy2 = Math.min(e.fromY, e.toY) - 80;
      const cx3 = e.toX;
      const cy3 = e.toY;

      // quadratic bezier interpolation
      const x = (1 - t) * (1 - t) * cx1 + 2 * (1 - t) * t * cx2 + t * t * cx3;
      const y = (1 - t) * (1 - t) * cy1 + 2 * (1 - t) * t * cy2 + t * t * cy3;

      ctx.beginPath();
      ctx.fillStyle = `hsl(${e.hue}, 95%, 60%)`;
      ctx.shadowBlur = 8;
      ctx.shadowColor = `hsl(${e.hue}, 100%, 60%)`;
      ctx.arc(x, y, e.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  function drawCharacters() {
    // Amp the cute robot near left
    const ax = 70;
    const ay = HEIGHT / 2 + 30;
    drawAmp(ax, ay);

    // Blinky the bulb sidekick near right
    const bx = WIDTH - 120;
    const by = HEIGHT / 2 - 20;
    drawBlinky(bx, by);
  }

  function drawAmp(x, y) {
    ctx.save();
    ctx.translate(x, y);
    // body
    ctx.fillStyle = '#cde';
    ctx.fillRect(-28, -36, 56, 68);
    ctx.fillStyle = '#89a';
    ctx.fillRect(-34, -44, 68, 12); // headband
    // face
    ctx.fillStyle = '#113';
    ctx.fillRect(-16, -26, 32, 20);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Amp', 0, -14);
    // eyes as LEDs
    ctx.beginPath();
    ctx.fillStyle = '#ffd966';
    ctx.arc(-8, -6, 4, 0, Math.PI * 2);
    ctx.arc(8, -6, 4, 0, Math.PI * 2);
    ctx.fill();
    // antenna
    ctx.strokeStyle = '#ffd966';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(18, -44);
    ctx.lineTo(26, -60);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(26, -62, 4, 0, Math.PI * 2);
    ctx.fill();
    // arms
    ctx.fillStyle = '#bcd';
    ctx.fillRect(-56, -6, 20, 8);
    ctx.fillRect(36, -6, 20, 8);
    ctx.restore();
  }

  function drawBlinky(x, y) {
    ctx.save();
    ctx.translate(x, y);
    // bulb body
    const lit = state.solved;
    const rad = ctx.createRadialGradient(0, -18, 6, 0, -18, 48);
    rad.addColorStop(0, lit ? '#fff9aa' : '#fff');
    rad.addColorStop(0.6, lit ? '#ffd966' : '#dfefff');
    rad.addColorStop(1, 'rgba(255,255,255,0.03)');
    ctx.fillStyle = rad;
    ctx.beginPath();
    ctx.ellipse(0, -18, 34, 46, 0, 0, Math.PI * 2);
    ctx.fill();
    // face
    ctx.fillStyle = '#133';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Blinky', 0, -8);
    // cheeks
    ctx.beginPath();
    ctx.fillStyle = lit ? '#ffcc88' : '#ffd';
    ctx.arc(-10, -16, 3, 0, Math.PI * 2);
    ctx.arc(10, -16, 3, 0, Math.PI * 2);
    ctx.fill();
    // little sparks around when lit
    if (lit) {
      for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,230,170,${0.2 + Math.random() * 0.6})`;
        ctx.lineWidth = 1.2;
        const rx = (Math.random() - 0.5) * 80;
        const ry = -18 + (Math.random() - 0.5) * 40;
        ctx.moveTo(rx, ry);
        ctx.lineTo(rx + (Math.random() - 0.5) * 12, ry + (Math.random() - 0.5) * 12);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function drawMessage() {
    if (!state.showMessage) return;
    ctx.save();
    ctx.textAlign = 'center';
    ctx.font = '18px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = Math.min(1, state.messageTimer / 120);
    ctx.fillText(state.showMessage, WIDTH / 2, HEIGHT - 18);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawInstructions() {
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Controls: ← → to move, Space/Enter to pick, Backspace or C to clear, M to toggle sound', 16, HEIGHT - 6);
    ctx.restore();
  }

  function drawSoundIcon() {
    ctx.save();
    ctx.translate(WIDTH - 36, 24);
    // speaker shape
    ctx.beginPath();
    ctx.fillStyle = state.soundOn ? '#ffd966' : '#556';
    ctx.moveTo(-12, -8);
    ctx.lineTo(-2, -8);
    ctx.lineTo(6, -16);
    ctx.lineTo(6, 16);
    ctx.lineTo(-2, 8);
    ctx.lineTo(-12, 8);
    ctx.closePath();
    ctx.fill();

    // waves or muted cross
    if (state.soundOn) {
      ctx.strokeStyle = '#ffd966';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(8, 0, 8, -0.6, 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(10, 0, 12, -0.6, 0.6);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-2, -6);
      ctx.lineTo(12, 10);
      ctx.moveTo(12, -6);
      ctx.lineTo(-2, 10);
      ctx.stroke();
    }
    ctx.restore();
  }

  // User gesture to enable audio safely
  function handleUserGesture() {
    if (audioCtx && audioCtx.state === 'suspended') {
      ensureAudioRunning().then((ok) => {
        if (ok && state.soundOn) startBackgroundHum();
      });
    } else if (state.soundOn && audioCtx) {
      startBackgroundHum();
    }
  }

  // Initialize first round and start game
  resetRound();
  startGameLoop();

  // Start audio if allowed and requested
  if (audioAllowed && state.soundOn) {
    ensureAudioRunning().then((ok) => {
      if (ok) startBackgroundHum();
    });
  }

  // Expose some debug on container
  container.addEventListener('keydown', (e) => {
    // container focus friendly
  });

  // Clean up when unloading
  window.addEventListener('unload', () => {
    stopGameLoop();
    if (humOsc) {
      try { humOsc.stop(); } catch (e) {}
    }
    if (audioCtx) {
      try { audioCtx.close(); } catch (e) {}
    }
  });

  // Prevent errors from unhandled promise rejections from audio resume
  window.addEventListener('unhandledrejection', (evt) => {
    console.warn('Unhandled promise rejection:', evt.reason);
  });
})();
---

