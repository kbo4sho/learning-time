{
  "generated_date": "2025-08-27",
  "generated_timestamp": "2025-08-27T00:22:14.035164",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9592,
  "game_filename": "2025-08-27.js",
  "game_size_bytes": 29105,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Educational Math Game: \"Zap the Sum\"\n  // Ages 7-9. Theme: Electricity. Math focus: addition (subset-sum to target).\n  // Renders inside element with id \"game-of-the-day-stage\".\n  // Canvas 720x480. All graphics drawn with canvas methods.\n  // Sounds synthesized with Web Audio API. Accessible live text via aria-live region.\n\n  // ---------- Basic setup ----------\n  const STAGE_ID = \"game-of-the-day-stage\";\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  const stageEl = document.getElementById(STAGE_ID);\n  if (!stageEl) {\n    console.error(`Element with id \"${STAGE_ID}\" not found.`);\n    return;\n  }\n\n  // Clear stage element\n  stageEl.innerHTML = \"\";\n  stageEl.style.position = \"relative\";\n  stageEl.style.userSelect = \"none\";\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make focusable for keyboard\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Zap the Sum math game. Use mouse or keyboard to play.\");\n  canvas.style.outline = \"none\";\n  canvas.style.display = \"block\";\n  canvas.style.margin = \"0\";\n  canvas.style.background = \"#091827\"; // dark blue background for contrast\n  stageEl.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n\n  // Accessible live region for screen readers and text alternatives\n  const liveRegion = document.createElement(\"div\");\n  liveRegion.setAttribute(\"aria-live\", \"polite\");\n  liveRegion.setAttribute(\"role\", \"status\");\n  liveRegion.style.position = \"absolute\";\n  liveRegion.style.left = \"-9999px\";\n  liveRegion.style.width = \"1px\";\n  liveRegion.style.height = \"1px\";\n  liveRegion.style.overflow = \"hidden\";\n  stageEl.appendChild(liveRegion);\n\n  // Size and layout constants\n  const HUD_HEIGHT = 120;\n  const GAME_Y = HUD_HEIGHT;\n  const GAME_HEIGHT = HEIGHT - HUD_HEIGHT;\n\n  // ---------- Utility ----------\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n  function arraySum(arr) {\n    return arr.reduce((s, v) => s + v, 0);\n  }\n\n  // ---------- Accessibility text updates ----------\n  function announce(text) {\n    liveRegion.textContent = text;\n  }\n\n  // ---------- Audio Manager ----------\n  class AudioManager {\n    constructor() {\n      this.ctx = null;\n      this.backgroundGain = null;\n      this.backgroundOsc = null;\n      this.enabled = false;\n      this.available = true;\n      try {\n        const AudioCtx = window.AudioContext || window.webkitAudioContext;\n        if (!AudioCtx) {\n          this.available = false;\n          console.warn(\"Web Audio API is not supported in this browser.\");\n          return;\n        }\n        // Do not instantiate context until user gesture; created on first enable.\n      } catch (e) {\n        this.available = false;\n        console.error(\"Error checking Web Audio API:\", e);\n      }\n    }\n\n    async init() {\n      if (!this.available) return;\n      if (this.ctx) return;\n      try {\n        const AudioCtx = window.AudioContext || window.webkitAudioContext;\n        this.ctx = new AudioCtx();\n        // Start a gentle background hum but paused until enabled\n        this.backgroundGain = this.ctx.createGain();\n        this.backgroundGain.gain.value = 0.0;\n        this.backgroundGain.connect(this.ctx.destination);\n\n        this.backgroundOsc = this.ctx.createOscillator();\n        this.backgroundOsc.type = \"sine\";\n        this.backgroundOsc.frequency.value = 55; // low hum\n        // Add a subtle filter\n        const filter = this.ctx.createBiquadFilter();\n        filter.type = \"lowpass\";\n        filter.frequency.value = 600;\n        this.backgroundOsc.connect(filter);\n        filter.connect(this.backgroundGain);\n        this.backgroundOsc.start();\n\n      } catch (err) {\n        this.available = false;\n        console.error(\"Failed creating AudioContext:\", err);\n      }\n    }\n\n    async enable() {\n      if (!this.available) return false;\n      try {\n        await this.init();\n        // Some browsers require resume() on gesture\n        if (this.ctx.state === \"suspended\") {\n          await this.ctx.resume();\n        }\n        this.enabled = true;\n        if (this.backgroundGain) {\n          // gently raise hum\n          this.backgroundGain.gain.cancelScheduledValues(this.ctx.currentTime);\n          this.backgroundGain.gain.setValueAtTime(0.0, this.ctx.currentTime);\n          this.backgroundGain.gain.linearRampToValueAtTime(0.03, this.ctx.currentTime + 1.0);\n        }\n        return true;\n      } catch (err) {\n        console.error(\"Audio enable error:\", err);\n        this.enabled = false;\n        return false;\n      }\n    }\n\n    disable() {\n      if (!this.available || !this.ctx) return;\n      this.enabled = false;\n      if (this.backgroundGain) {\n        this.backgroundGain.gain.cancelScheduledValues(this.ctx.currentTime);\n        this.backgroundGain.gain.setValueAtTime(this.backgroundGain.gain.value, this.ctx.currentTime);\n        this.backgroundGain.gain.linearRampToValueAtTime(0.0, this.ctx.currentTime + 0.3);\n      }\n    }\n\n    // Short success melody: ascending notes\n    playSuccess() {\n      if (!this.available || !this.enabled || !this.ctx) return;\n      try {\n        const now = this.ctx.currentTime;\n        const g = this.ctx.createGain();\n        g.connect(this.ctx.destination);\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.exponentialRampToValueAtTime(0.12, now + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);\n\n        const osc = this.ctx.createOscillator();\n        osc.type = \"sine\";\n        osc.frequency.setValueAtTime(440, now);\n        osc.frequency.linearRampToValueAtTime(660, now + 0.25);\n        osc.connect(g);\n        osc.start(now);\n        osc.stop(now + 0.5);\n\n      } catch (err) {\n        console.warn(\"playSuccess error\", err);\n      }\n    }\n\n    // Short incorrect buzz\n    playFail() {\n      if (!this.available || !this.enabled || !this.ctx) return;\n      try {\n        const now = this.ctx.currentTime;\n        const g = this.ctx.createGain();\n        g.connect(this.ctx.destination);\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.exponentialRampToValueAtTime(0.09, now + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n\n        const osc = this.ctx.createOscillator();\n        osc.type = \"square\";\n        osc.frequency.setValueAtTime(120, now);\n        const filt = this.ctx.createBiquadFilter();\n        filt.type = \"lowpass\";\n        filt.frequency.setValueAtTime(600, now);\n        osc.connect(filt);\n        filt.connect(g);\n        // little pitch wobble\n        osc.frequency.setValueAtTime(120, now);\n        osc.frequency.linearRampToValueAtTime(90, now + 0.15);\n\n        osc.start(now);\n        osc.stop(now + 0.35);\n      } catch (err) {\n        console.warn(\"playFail error\", err);\n      }\n    }\n\n    // gentle click for selection\n    playClick() {\n      if (!this.available || !this.enabled || !this.ctx) return;\n      try {\n        const now = this.ctx.currentTime;\n        const g = this.ctx.createGain();\n        g.connect(this.ctx.destination);\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.exponentialRampToValueAtTime(0.06, now + 0.005);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);\n\n        const osc = this.ctx.createOscillator();\n        osc.type = \"triangle\";\n        osc.frequency.setValueAtTime(880, now);\n        osc.connect(g);\n        osc.start(now);\n        osc.stop(now + 0.15);\n      } catch (err) {\n        console.warn(\"playClick error\", err);\n      }\n    }\n  }\n\n  const audio = new AudioManager();\n\n  // ---------- Game Entities ----------\n  class Battery {\n    constructor(x, y, value, id) {\n      this.x = x;\n      this.y = y;\n      this.w = 120;\n      this.h = 64;\n      this.value = value;\n      this.id = id;\n      this.selected = false;\n      this.hover = false;\n      this.pulse = 0; // for animation\n    }\n\n    contains(px, py) {\n      return px >= this.x && px <= this.x + this.w && py >= this.y && py <= this.y + this.h;\n    }\n\n    toggleSelected() {\n      this.selected = !this.selected;\n      this.pulse = 1.0;\n    }\n\n    draw(ctx) {\n      // Battery body\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      // Outer rounded rect\n      ctx.beginPath();\n      roundRectPath(ctx, 0, 0, this.w, this.h, 12);\n      ctx.fillStyle = this.selected ? \"#FFD166\" : this.hover ? \"#8FD3FF\" : \"#FFFFFF\";\n      ctx.fill();\n      // Outline\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = \"#072A40\";\n      ctx.stroke();\n\n      // Terminals: little prongs\n      ctx.fillStyle = \"#072A40\";\n      ctx.fillRect(this.w - 10, this.h / 2 - 6, 8, 12);\n\n      // Number big\n      ctx.fillStyle = \"#072A40\";\n      ctx.font = \"bold 32px 'Arial'\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(this.value.toString(), this.w / 2, this.h / 2);\n\n      // tiny label\n      ctx.font = \"12px 'Arial'\";\n      ctx.textAlign = \"left\";\n      ctx.fillStyle = \"#072A40\";\n      ctx.fillText(\"mAh\", 8, this.h - 8);\n\n      // glow pulse if selected\n      if (this.selected || this.pulse > 0) {\n        ctx.beginPath();\n        ctx.arc(this.w / 2, -8, 28 + this.pulse * 6, 0, Math.PI * 2);\n        ctx.fillStyle = `rgba(255,210,100,${0.08 + this.pulse * 0.15})`;\n        ctx.fill();\n      }\n\n      ctx.restore();\n    }\n\n    update(dt) {\n      if (this.pulse > 0) {\n        this.pulse = Math.max(0, this.pulse - dt * 2);\n      }\n    }\n  }\n\n  // RoundRect helper\n  function roundRectPath(ctx, x, y, w, h, r) {\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Characters (drawn each frame). A friendly bulb \"Dr. Amp\" and a spark \"Sparkle\".\n  function drawDrAmp(ctx, x, y, mood = \"happy\") {\n    ctx.save();\n    ctx.translate(x, y);\n    // Bulb glass\n    ctx.beginPath();\n    ctx.ellipse(0, -28, 34, 38, 0, 0, Math.PI * 2);\n    const g = ctx.createRadialGradient(-10, -34, 6, 0, -28, 60);\n    g.addColorStop(0, \"#FFF7C2\");\n    g.addColorStop(1, \"#FFD166\");\n    ctx.fillStyle = g;\n    ctx.fill();\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = \"#8A5A00\";\n    ctx.stroke();\n\n    // Filament\n    ctx.beginPath();\n    ctx.moveTo(-12, -20);\n    ctx.quadraticCurveTo(0, -10 + (mood === \"sad\" ? 4 : 0), 12, -20);\n    ctx.strokeStyle = \"#FFD166\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // Base\n    ctx.fillStyle = \"#6C7A89\";\n    ctx.fillRect(-22, 4, 44, 18);\n    ctx.strokeRect(-22, 4, 44, 18);\n\n    // Face\n    ctx.fillStyle = \"#072A40\";\n    ctx.beginPath();\n    ctx.arc(-8, -30, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(8, -30, 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    // mouth\n    ctx.beginPath();\n    if (mood === \"happy\") ctx.arc(0, -14, 8, 0, Math.PI, false);\n    else if (mood === \"surprised\") {\n      ctx.arc(0, -14, 5, 0, Math.PI * 2);\n    } else {\n      ctx.arc(0, -12, 8, 0, Math.PI, true);\n    }\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  function drawSpark(ctx, x, y, t) {\n    ctx.save();\n    ctx.translate(x, y);\n    // wacky star shape\n    ctx.beginPath();\n    for (let i = 0; i < 8; i++) {\n      const angle = (i / 8) * Math.PI * 2;\n      const r = i % 2 === 0 ? 12 : 6;\n      const px = Math.cos(angle) * r;\n      const py = Math.sin(angle) * r;\n      if (i === 0) ctx.moveTo(px, py);\n      else ctx.lineTo(px, py);\n    }\n    ctx.closePath();\n    const hue = 50 + Math.sin(t * 6) * 10;\n    ctx.fillStyle = `hsl(${hue} 90% 60%)`;\n    ctx.shadowColor = \"rgba(255,215,90,0.6)\";\n    ctx.shadowBlur = 12;\n    ctx.fill();\n    ctx.shadowBlur = 0;\n\n    // eyes\n    ctx.fillStyle = \"#072A40\";\n    ctx.fillRect(-4, -2, 3, 3);\n    ctx.fillRect(2, -2, 3, 3);\n\n    ctx.restore();\n  }\n\n  // ---------- Game Logic ----------\n  class Game {\n    constructor(ctx) {\n      this.ctx = ctx;\n      this.batteries = [];\n      this.target = 0;\n      this.level = 1;\n      this.score = 0;\n      this.lives = 3;\n      this.selectionIndex = 0;\n      this.lastTick = performance.now();\n      this.running = true;\n      this.hintTimer = 0;\n      this.feedbackText = \"\";\n      this.feedbackTimer = 0;\n      this.audioOn = false;\n      this.mouse = { x: 0, y: 0, down: false };\n      this.time = 0;\n      this.generateRound();\n\n      // Input\n      canvas.addEventListener(\"keydown\", (e) => this.onKeyDown(e));\n      canvas.addEventListener(\"mousemove\", (e) => this.onMouseMove(e));\n      canvas.addEventListener(\"mousedown\", (e) => this.onMouseDown(e));\n      canvas.addEventListener(\"mouseup\", (e) => this.onMouseUp(e));\n      canvas.addEventListener(\"mouseleave\", (e) => this.onMouseLeave(e));\n      canvas.addEventListener(\"click\", (e) => {\n        // On first click, try to enable audio (gesture)\n        if (!audio.enabled && audio.available) {\n          audio.enable().then((ok) => {\n            this.audioOn = ok;\n            this.updateAnnounce();\n          });\n        }\n      });\n\n      // Touch also maps to mouse (basic)\n      canvas.addEventListener(\"touchstart\", (e) => {\n        e.preventDefault();\n        const t = e.touches[0];\n        const rect = canvas.getBoundingClientRect();\n        this.onMouseMove({ clientX: t.clientX, clientY: t.clientY });\n        this.onMouseDown({ clientX: t.clientX, clientY: t.clientY });\n      }, { passive: false });\n      canvas.addEventListener(\"touchend\", (e) => {\n        e.preventDefault();\n        this.onMouseUp({});\n      });\n\n      // Initial announcement\n      announce(\"Welcome! Help Dr. Amp light the lamp by selecting batteries that add up to the target. Use mouse or keyboard. Press A to toggle audio.\");\n      this.updateAnnounce();\n    }\n\n    generateRound() {\n      // create a solvable set of 4 batteries by first selecting 2-3 random numbers to sum to target\n      const nPick = randInt(2, 3);\n      const chosen = [];\n      while (chosen.length < nPick) {\n        const v = randInt(1, 9);\n        if (!chosen.includes(v)) chosen.push(v);\n      }\n      const targetSum = arraySum(chosen);\n      // add distractors to total 4 batteries\n      const batteries = [...chosen];\n      while (batteries.length < 4) {\n        const cand = randInt(1, 9);\n        // allow duplicates sometimes but try not to have exact duplicates of chosen unless needed\n        if (batteries.length < 3 || Math.random() > 0.3) {\n          batteries.push(cand);\n        }\n      }\n      // Shuffle and create Battery objects\n      batteries.sort(() => Math.random() - 0.5);\n      this.batteries = [];\n      const startX = 48;\n      const gap = 28;\n      for (let i = 0; i < 4; i++) {\n        const bx = startX + i * (120 + gap);\n        const by = GAME_Y + 28;\n        this.batteries.push(new Battery(bx, by, batteries[i], i));\n      }\n      this.target = targetSum;\n      this.selectionIndex = 0;\n      this.feedbackText = \"\";\n      this.feedbackTimer = 0;\n      this.hintTimer = 5.0;\n      this.time = 0;\n\n      announce(`Level ${this.level}. Target ${this.target} volts. Select batteries to add to ${this.target}.`);\n      this.updateAnnounce();\n    }\n\n    updateAnnounce() {\n      const selectedVals = this.batteries.filter(b => b.selected).map(b => b.value);\n      const sum = arraySum(selectedVals);\n      const audioText = audio.available ? (this.audioOn ? \"Audio on.\" : \"Audio off. Press A to enable.\") : \"Audio not available.\";\n      announce(`Target ${this.target}. Selected ${selectedVals.join(\", \") || \"none\"}. Sum ${sum}. ${audioText} Score ${this.score}. Lives ${this.lives}.`);\n    }\n\n    onKeyDown(e) {\n      if (!this.running) return;\n      if (e.key === \"ArrowRight\") {\n        this.selectionIndex = (this.selectionIndex + 1) % this.batteries.length;\n        audio.playClick();\n        this.updateAnnounce();\n      } else if (e.key === \"ArrowLeft\") {\n        this.selectionIndex = (this.selectionIndex - 1 + this.batteries.length) % this.batteries.length;\n        audio.playClick();\n        this.updateAnnounce();\n      } else if (e.key === \" \" || e.key === \"Enter\") {\n        // toggle selected\n        this.toggleBattery(this.selectionIndex);\n      } else if (e.key >= \"1\" && e.key <= \"4\") {\n        const idx = Number(e.key) - 1;\n        if (idx >= 0 && idx < this.batteries.length) this.toggleBattery(idx);\n      } else if (e.key.toLowerCase() === \"a\") {\n        // toggle audio\n        if (!audio.available) {\n          announce(\"Audio is not supported in this browser.\");\n        } else {\n          if (!audio.enabled) {\n            audio.enable().then(ok => {\n              this.audioOn = ok;\n              announce(ok ? \"Audio enabled.\" : \"Audio could not be enabled.\");\n              this.updateAnnounce();\n            });\n          } else {\n            audio.disable();\n            this.audioOn = false;\n            announce(\"Audio disabled.\");\n            this.updateAnnounce();\n          }\n        }\n      }\n    }\n\n    toggleBattery(idx) {\n      const b = this.batteries[idx];\n      if (!b) return;\n      b.toggleSelected();\n      audio.playClick();\n      this.updateAnnounce();\n      // Check sum\n      const selectedVals = this.batteries.filter(b => b.selected).map(b => b.value);\n      const sum = arraySum(selectedVals);\n      if (sum === this.target) {\n        // success\n        this.onSuccess();\n      } else if (sum > this.target) {\n        // immediate negative feedback\n        this.onOver();\n      }\n    }\n\n    onSuccess() {\n      audio.playSuccess();\n      this.feedbackText = \"Zap! Perfect match!\";\n      this.feedbackTimer = 2.0;\n      this.score += 10 * this.level;\n      this.level += 1;\n      // small celebration; regenerate after short delay\n      setTimeout(() => {\n        this.generateRound();\n      }, 900);\n      this.updateAnnounce();\n    }\n\n    onOver() {\n      audio.playFail();\n      this.feedbackText = \"Too much! Try again or unselect a battery.\";\n      this.feedbackTimer = 2.0;\n      this.lives -= 1;\n      if (this.lives <= 0) {\n        this.onGameOver();\n      } else {\n        this.updateAnnounce();\n      }\n    }\n\n    onGameOver() {\n      this.running = false;\n      this.feedbackText = \"Oh no \u2014 the circuit fizzled out! Game over. Press R to restart.\";\n      this.feedbackTimer = 6.0;\n      announce(`Game over. Your score ${this.score}. Press R to restart.`);\n      // Listen for restart\n      const restartHandler = (e) => {\n        if (e.key.toLowerCase() === \"r\") {\n          window.removeEventListener(\"keydown\", restartHandler);\n          this.reset();\n        }\n      };\n      window.addEventListener(\"keydown\", restartHandler);\n    }\n\n    reset() {\n      this.level = 1;\n      this.score = 0;\n      this.lives = 3;\n      this.running = true;\n      this.generateRound();\n    }\n\n    onMouseMove(e) {\n      const rect = canvas.getBoundingClientRect();\n      const mx = (e.clientX || 0) - rect.left;\n      const my = (e.clientY || 0) - rect.top;\n      this.mouse.x = mx;\n      this.mouse.y = my;\n      // update hover states\n      for (const b of this.batteries) {\n        b.hover = b.contains(mx, my);\n      }\n      // check if hovering audio icon or speaker etc (we'll use click)\n    }\n\n    onMouseDown(e) {\n      this.mouse.down = true;\n      const rect = canvas.getBoundingClientRect();\n      const mx = (e.clientX || 0) - rect.left;\n      const my = (e.clientY || 0) - rect.top;\n      // check battery clicked\n      for (let i = 0; i < this.batteries.length; i++) {\n        const b = this.batteries[i];\n        if (b.contains(mx, my)) {\n          this.selectionIndex = i;\n          this.toggleBattery(i);\n          return;\n        }\n      }\n      // check speaker icon area top-right 44x44\n      if (mx > WIDTH - 54 && my < 54) {\n        // toggle audio\n        if (!audio.available) {\n          announce(\"Audio not available on this device.\");\n        } else {\n          if (!audio.enabled) {\n            audio.enable().then(ok => {\n              this.audioOn = ok;\n              announce(ok ? \"Audio enabled.\" : \"Audio could not be enabled.\");\n              this.updateAnnounce();\n            });\n          } else {\n            audio.disable();\n            this.audioOn = false;\n            announce(\"Audio disabled.\");\n            this.updateAnnounce();\n          }\n        }\n      }\n    }\n\n    onMouseUp(e) {\n      this.mouse.down = false;\n    }\n\n    onMouseLeave(e) {\n      this.mouse.down = false;\n      for (const b of this.batteries) b.hover = false;\n    }\n\n    update(dt) {\n      this.time += dt;\n      for (const b of this.batteries) b.update(dt);\n      if (this.feedbackTimer > 0) this.feedbackTimer = Math.max(0, this.feedbackTimer - dt);\n      if (this.hintTimer > 0) this.hintTimer = Math.max(0, this.hintTimer - dt);\n\n      // subtle animated spark near lamp if partially correct\n      // no additional logic needed here for now\n    }\n\n    draw() {\n      // Clear with calming gradient background\n      const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n      g.addColorStop(0, \"#091827\");\n      g.addColorStop(1, \"#0f2540\");\n      ctx.fillStyle = g;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n      // Draw top HUD area with target and characters\n      ctx.save();\n      ctx.fillStyle = \"rgba(255,255,255,0.02)\";\n      ctx.fillRect(0, 0, WIDTH, HUD_HEIGHT);\n      ctx.restore();\n\n      // Draw Dr. Amp on left\n      drawDrAmp(ctx, 72, HUD_HEIGHT / 2 + 8, this.feedbackText.includes(\"Too\") ? \"sad\" : \"happy\");\n\n      // Draw lamp and wire in center HUD\n      const lampX = WIDTH / 2;\n      const lampY = HUD_HEIGHT / 2 + 8;\n      // Wire\n      ctx.beginPath();\n      ctx.moveTo(160, lampY + 40);\n      ctx.quadraticCurveTo(lampX, lampY + 120, WIDTH - 160, lampY + 40);\n      ctx.lineWidth = 6;\n      ctx.strokeStyle = \"#3ddc84\";\n      ctx.stroke();\n\n      // Target lamp\n      ctx.save();\n      ctx.translate(lampX, lampY);\n      // lamp stand\n      ctx.fillStyle = \"#30475e\";\n      ctx.fillRect(-30, 36, 60, 10);\n\n      // bulb\n      ctx.beginPath();\n      ctx.ellipse(0, 0, 48, 60, 0, 0, Math.PI * 2);\n      const lit = arraySum(this.batteries.filter(b => b.selected).map(b => b.value)) === this.target;\n      const bulbGradient = ctx.createRadialGradient(-12, -10, 6, 0, 0, 90);\n      bulbGradient.addColorStop(0, lit ? \"#FFFAD1\" : \"#C9E6FF\");\n      bulbGradient.addColorStop(1, lit ? \"#FFD166\" : \"#6FA8DC\");\n      ctx.fillStyle = bulbGradient;\n      ctx.fill();\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = \"#072A40\";\n      ctx.stroke();\n\n      // Lamp face\n      ctx.fillStyle = \"#072A40\";\n      ctx.beginPath();\n      ctx.arc(-12, -8, 4, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(12, -8, 4, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      if (lit) ctx.arc(0, 8, 8, 0, Math.PI, false);\n      else ctx.arc(0, 12, 8, 0, Math.PI, true);\n      ctx.stroke();\n\n      // Target text on lamp\n      ctx.fillStyle = \"#072A40\";\n      ctx.font = \"bold 18px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${this.target} V`, 0, 28);\n\n      ctx.restore();\n\n      // Draw batteries\n      for (let i = 0; i < this.batteries.length; i++) {\n        const b = this.batteries[i];\n        // Slight hover bounce\n        const hoverOffset = b.hover ? -4 : 0;\n        b.y = GAME_Y + 28 + hoverOffset;\n        b.draw(ctx);\n        // Draw selection outline if current keyboard selection\n        if (i === this.selectionIndex) {\n          ctx.save();\n          ctx.strokeStyle = \"#FFD166\";\n          ctx.lineWidth = 3;\n          ctx.beginPath();\n          roundRectPath(ctx, b.x - 6, b.y - 6, b.w + 12, b.h + 12, 14);\n          ctx.stroke();\n          ctx.restore();\n        }\n      }\n\n      // HUD right-side: score, lives, audio icon\n      ctx.save();\n      ctx.fillStyle = \"#FFFFFF\";\n      ctx.font = \"bold 18px Arial\";\n      ctx.textAlign = \"right\";\n      ctx.fillText(`Score: ${this.score}`, WIDTH - 12, 26);\n      ctx.fillText(`Lives: ${this.lives}`, WIDTH - 12, 52);\n      ctx.restore();\n\n      // Audio icon top-right\n      ctx.save();\n      const spX = WIDTH - 32;\n      const spY = 32;\n      ctx.translate(spX, spY);\n      // speaker shape\n      ctx.fillStyle = audio.available ? (audio.enabled && this.audioOn ? \"#3ddc84\" : \"#FFFFFF\") : \"#888888\";\n      ctx.beginPath();\n      ctx.moveTo(-12, -10);\n      ctx.lineTo(-2, -10);\n      ctx.lineTo(6, -16);\n      ctx.lineTo(6, 16);\n      ctx.lineTo(-2, 10);\n      ctx.lineTo(-12, 10);\n      ctx.closePath();\n      ctx.fill();\n\n      if (!audio.available) {\n        // X overlay\n        ctx.strokeStyle = \"#ff7b7b\";\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.moveTo(-18, -18);\n        ctx.lineTo(18, 18);\n        ctx.moveTo(18, -18);\n        ctx.lineTo(-18, 18);\n        ctx.stroke();\n      } else if (!audio.enabled) {\n        // small mute slash\n        ctx.strokeStyle = \"#072A40\";\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.moveTo(12, -12);\n        ctx.lineTo(18, -18);\n        ctx.stroke();\n      } else {\n        // sound waves\n        ctx.strokeStyle = \"#3ddc84\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(12, 0, 6, -0.6, 0.6);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.arc(12, 0, 10, -0.6, 0.6);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n\n      // Draw live instruction text on HUD bottom-left\n      ctx.save();\n      ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n      ctx.font = \"14px Arial\";\n      ctx.textAlign = \"left\";\n      const instr = \"Click batteries or use \u2190 \u2192 and Enter to select. Reach the target voltage.\";\n      ctx.fillText(instr, 12, HUD_HEIGHT - 8);\n      ctx.restore();\n\n      // Feedback bubble near Dr. Amp\n      if (this.feedbackTimer > 0) {\n        ctx.save();\n        const bx = 160;\n        const by = 44;\n        // bubble\n        ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n        roundRectDraw(ctx, bx, by, 320, 40, 10, \"#072A40\");\n        ctx.fillStyle = \"#072A40\";\n        ctx.font = \"bold 15px Arial\";\n        ctx.textAlign = \"left\";\n        ctx.fillText(this.feedbackText, bx + 10, by + 24);\n        ctx.restore();\n      }\n\n      // small spark characters across HUD\n      drawSpark(ctx, WIDTH - 120, HUD_HEIGHT / 2 - 6, this.time);\n      drawSpark(ctx, 120, HUD_HEIGHT / 2 - 14, this.time + 0.6);\n\n      // Draw subtle grid and decorative wacky elements in game area\n      ctx.save();\n      ctx.translate(0, GAME_Y);\n      // floating dashed lines (wires)\n      ctx.strokeStyle = \"rgba(255,255,255,0.03)\";\n      ctx.lineWidth = 1;\n      for (let i = 20; i < WIDTH; i += 60) {\n        ctx.setLineDash([6, 8]);\n        ctx.beginPath();\n        ctx.moveTo(i, 0);\n        ctx.lineTo(i - 20, GAME_HEIGHT);\n        ctx.stroke();\n      }\n      ctx.setLineDash([]);\n      ctx.restore();\n\n      // bottom-right hint box (if needed)\n      if (this.hintTimer < 4.0) {\n        ctx.save();\n        const hx = WIDTH - 260;\n        const hy = HEIGHT - 88;\n        roundRectDraw(ctx, hx, hy, 240, 72, 12, \"rgba(255,255,255,0.06)\");\n        ctx.fillStyle = \"#FFFFFF\";\n        ctx.font = \"13px Arial\";\n        ctx.textAlign = \"left\";\n        ctx.fillText(\"Hint: Try combining batteries to make the target!\", hx + 12, hy + 28);\n        ctx.fillStyle = \"rgba(255,255,255,0.7)\";\n        ctx.font = \"12px Arial\";\n        ctx.fillText(\"Select/unselect to change the sum.\", hx + 12, hy + 48);\n        ctx.restore();\n      }\n\n      // If game over draw overlay\n      if (!this.running) {\n        ctx.save();\n        ctx.fillStyle = \"rgba(0,0,0,0.6)\";\n        ctx.fillRect(0, 0, WIDTH, HEIGHT);\n        ctx.fillStyle = \"#FFD166\";\n        ctx.font = \"bold 36px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"Circuit Fizzled!\", WIDTH / 2, HEIGHT / 2 - 6);\n        ctx.fillStyle = \"#FFFFFF\";\n        ctx.font = \"20px Arial\";\n        ctx.fillText(`Score: ${this.score}`, WIDTH / 2, HEIGHT / 2 + 28);\n        ctx.restore();\n      }\n    }\n  }\n\n  function roundRectDraw(ctx, x, y, w, h, r, fillStyle) {\n    ctx.beginPath();\n    roundRectPath(ctx, x, y, w, h, r);\n    ctx.fillStyle = fillStyle;\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n    ctx.stroke();\n  }\n\n  // ---------- Main Loop ----------\n  const game = new Game(ctx);\n\n  function loop(now) {\n    const dt = Math.min(0.05, (now - game.lastTick) / 1000);\n    game.lastTick = now;\n    if (game.running) game.update(dt);\n    game.draw();\n    requestAnimationFrame(loop);\n  }\n  requestAnimationFrame((t) => {\n    game.lastTick = t;\n    requestAnimationFrame(loop);\n  });\n\n  // Focus canvas for keyboard events\n  canvas.addEventListener(\"focus\", () => {\n    // draw focus ring visually as well\n  });\n  canvas.addEventListener(\"blur\", () => {});\n\n  // Expose a few helpful console actions for debugging (non-essential)\n  window.__zapTheSum = {\n    audio,\n    game,\n  };\n\n  // Error handling: ensure audio context creation errors are shown gently\n  if (!audio.available) {\n    announce(\"Audio unavailable \u2014 sounds are disabled. Use keyboard or mouse to play.\");\n  }\n\n  // Provide clear instructions visually (redraw will keep them)\n  // End of script\n})();\n---\n",
  "improve_response_tokens": 18823,
  "formatted_code": true,
  "formatting_response_tokens": 20295,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}