# Game of the Day - 2025-08-23

## Metadata
- **Generated Date:** 2025-08-23
- **Generated Time:** 2025-08-23T00:21:08.651108
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-23.js
- **File Size:** 25561 bytes
- **Tokens Used:** 9329

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-23.js` - The playable game
- `2025-08-23.meta.json` - Machine-readable metadata
- `2025-08-23.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19308

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20757

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Electricity Math Game for ages 7-9
// Renders inside element with id "game-of-the-day-stage"
// Canvas 720x480, all visuals drawn with canvas, sounds generated with Web Audio API
// Keyboard & mouse/touch accessible, audio initialization with error handling

(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container #game-of-the-day-stage not found.');
    return;
  }

  // Clear and prepare container
  container.innerHTML = '';
  container.style.position = 'relative';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Electric addition game. Use left and right arrow keys to move Spark and catch the correct falling number to power the bulb. Press S to toggle sound.');
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.style.display = 'block';
  canvas.style.margin = '0 auto';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Audio variables
  let audioCtx = null;
  let masterGain = null;
  let bgOsc = null;
  let soundEnabled = false;
  let audioAllowed = false;
  let audioError = null;

  function initAudio() {
    if (audioCtx) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        throw new Error('Web Audio API not supported.');
      }
      audioCtx = new AC();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.18;
      masterGain.connect(audioCtx.destination);

      // Gentle hum background
      bgOsc = audioCtx.createOscillator();
      const bgGain = audioCtx.createGain();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 60; // low hum
      bgGain.gain.value = 0.03;
      bgOsc.connect(bgGain);
      bgGain.connect(masterGain);
      bgOsc.start();

      audioAllowed = true;
      soundEnabled = true;
    } catch (err) {
      console.warn('Audio initialization failed:', err);
      audioError = err;
      audioCtx = null;
      soundEnabled = false;
      audioAllowed = false;
    }
  }

  // Play short sound effects using WebAudio
  function playCorrect() {
    if (!audioAllowed || !soundEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'triangle';
      o.frequency.setValueAtTime(880, audioCtx.currentTime);
      o.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.12);
      g.gain.value = 0.001;
      g.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.35);
      o.connect(g);
      g.connect(masterGain);
      o.start();
      o.stop(audioCtx.currentTime + 0.4);
    } catch (err) {
      console.warn('playCorrect error', err);
    }
  }

  function playIncorrect() {
    if (!audioAllowed || !soundEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const f = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      o.type = 'square';
      o.frequency.value = 160;
      f.type = 'highpass';
      f.frequency.value = 600;
      g.gain.value = 0.0001;
      g.gain.exponentialRampToValueAtTime(0.08, audioCtx.currentTime + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.25);
      o.connect(f);
      f.connect(g);
      g.connect(masterGain);
      o.start();
      o.stop(audioCtx.currentTime + 0.28);
    } catch (err) {
      console.warn('playIncorrect error', err);
    }
  }

  function playZap() {
    if (!audioAllowed || !soundEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(1200, audioCtx.currentTime);
      o.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.07);
      g.gain.value = 0.001;
      g.gain.exponentialRampToValueAtTime(0.14, audioCtx.currentTime + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.12);
      o.connect(g);
      g.connect(masterGain);
      o.start();
      o.stop(audioCtx.currentTime + 0.12);
    } catch (err) {
      console.warn('playZap error', err);
    }
  }

  // Accessibility visuals: show when sound is off/on via icon
  function drawSoundIcon(x, y) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(-20, -16, 40, 32);
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.fillStyle = '#FFDD57';
    // Speaker
    ctx.beginPath();
    ctx.moveTo(-14, -8);
    ctx.lineTo(-6, -8);
    ctx.lineTo(-2, -12);
    ctx.lineTo(-2, 12);
    ctx.lineTo(-6, 8);
    ctx.lineTo(-14, 8);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Waves or X
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    if (soundEnabled) {
      ctx.beginPath();
      ctx.arc(6, 0, 8, -0.6, 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(6, 0, 12, -0.6, 0.6);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.moveTo(6, -8);
      ctx.lineTo(14, 8);
      ctx.moveTo(14, -8);
      ctx.lineTo(6, 8);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Game state
  const player = {
    x: WIDTH / 2,
    y: HEIGHT - 90,
    w: 60,
    h: 50,
    vx: 0,
    speed: 3.8,
    color: '#FF7BAC',
    bob: 0,
    name: 'Spark the Squirrel'
  };

  let problemsSolved = 0;
  let score = 0;
  let lives = 3;
  let level = 1;
  let timeElapsed = 0;
  let lastSpawn = 0;
  let spawnInterval = 1400; // ms
  let electrons = []; // falling numbers
  let particles = []; // visual sparks

  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Current math problem (addition or subtraction)
  let currentProblem = generateProblem(level);

  function generateProblem(lvl) {
    // For ages 7-9, primarily add/sub within 20. Level increases size.
    const op = Math.random() < 0.6 ? '+' : '-';
    const max = Math.min(20 + lvl * 3, 40);
    let a = randomInt(1, Math.max(1, Math.floor(max * 0.6)));
    let b = randomInt(1, Math.max(1, Math.floor(max * 0.6)));
    if (op === '-' && a < b) [a, b] = [b, a];
    const solution = op === '+' ? a + b : a - b;
    return { a, b, op, solution };
  }

  // Spawn electrons with numbers around current solution
  function spawnElectron() {
    // Determine number of spawned per wave depends on level
    const variantCount = Math.min(5 + level, 8);
    // Create one correct and several wrong ones
    const correctIndex = randomInt(0, variantCount - 1);
    const startX = 60;
    const endX = WIDTH - 60;
    for (let i = 0; i < variantCount; i++) {
      const x = startX + ((endX - startX) * i) / (variantCount - 1);
      const jitter = randomInt(-30, 30);
      const value =
        i === correctIndex
          ? currentProblem.solution
          : currentProblem.solution + randomInt(-6 - level, 6 + level);
      const e = {
        id: Math.random().toString(36).slice(2),
        x: Math.max(32, Math.min(WIDTH - 32, x + jitter)),
        y: -randomInt(10, 90),
        vy: 1.1 + Math.random() * 0.6 + level * 0.12,
        value,
        radius: 24 + (Math.random() * 8 - 4),
        wobble: Math.random() * Math.PI * 2,
        color: value === currentProblem.solution ? '#6EE7B7' : '#FFD19A'
      };
      electrons.push(e);
    }
  }

  // Keyboard controls
  const keys = {};
  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    keys[e.key] = true;
    if (!audioAllowed && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ' || e.key === 's' || e.key === 'S')) {
      // Try to initialize audio on first gesture
      try {
        initAudio();
      } catch (err) {
        // ignore
      }
    }
    if ((e.key === 's' || e.key === 'S')) {
      // Toggle sound
      if (!audioAllowed) {
        initAudio();
      } else {
        soundEnabled = !soundEnabled;
      }
    }
  });
  window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
  });

  // Mouse / touch controls: tap left/right half to move
  canvas.addEventListener('mousedown', (e) => {
    const r = canvas.getBoundingClientRect();
    const cx = e.clientX - r.left;
    if (!audioAllowed) {
      initAudio();
    }
    if (cx < WIDTH / 2) {
      keys.ArrowLeft = true;
      setTimeout(() => (keys.ArrowLeft = false), 180);
    } else {
      keys.ArrowRight = true;
      setTimeout(() => (keys.ArrowRight = false), 180);
    }
  });

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const r = canvas.getBoundingClientRect();
    const cx = touch.clientX - r.left;
    if (!audioAllowed) {
      initAudio();
    }
    if (cx < WIDTH / 2) {
      keys.ArrowLeft = true;
      setTimeout(() => (keys.ArrowLeft = false), 180);
    } else {
      keys.ArrowRight = true;
      setTimeout(() => (keys.ArrowRight = false), 180);
    }
  }, { passive: false });

  // Collision detection
  function checkCollisions() {
    for (let i = electrons.length - 1; i >= 0; i--) {
      const e = electrons[i];
      const dx = e.x - player.x;
      const dy = e.y - player.y + 6;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < e.radius + 16) {
        // Collected
        if (e.value === currentProblem.solution) {
          score += 10;
          problemsSolved += 1;
          spawnParticles(e.x, e.y, '#6EE7B7', 12);
          playCorrect();
          // Power lightbulb visual quick flash
          flashBulb();
          // Increase difficulty a bit
          if (problemsSolved % 3 === 0) {
            level += 1;
            spawnInterval = Math.max(650, spawnInterval - 120);
          }
          // New problem after a short delay
          setTimeout(() => {
            currentProblem = generateProblem(level);
          }, 220);
        } else {
          // Wrong
          lives -= 1;
          spawnParticles(e.x, e.y, '#FF6B6B', 10);
          playIncorrect();
          // Slight knockback
          player.vx = dx > 0 ? -2.5 : 2.5;
          if (lives <= 0) {
            // game over
            gameOver();
          }
        }
        // Remove the electron
        electrons.splice(i, 1);
      }
    }
  }

  // Particles for visual feedback
  function spawnParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 3,
        vy: (Math.random() - 0.9) * 3,
        life: 30 + Math.random() * 30,
        color,
        size: Math.random() * 4 + 2
      });
    }
  }

  function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.08;
      p.life -= 1;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  // Bulb flash state
  let bulbFlash = 0;
  function flashBulb() {
    bulbFlash = 28;
    if (audioAllowed && soundEnabled) playZap();
  }

  // Game over state
  let isGameOver = false;
  function gameOver() {
    isGameOver = true;
    // Stop background oscillation nicely
    if (bgOsc && audioAllowed) {
      try {
        const now = audioCtx.currentTime;
        masterGain.gain.exponentialRampToValueAtTime(0.02, now + 0.6);
      } catch (err) {
        // ignore
      }
    }
  }

  function restartGame() {
    // Reset state
    problemsSolved = 0;
    score = 0;
    lives = 3;
    level = 1;
    timeElapsed = 0;
    lastSpawn = 0;
    spawnInterval = 1400;
    electrons = [];
    particles = [];
    currentProblem = generateProblem(level);
    isGameOver = false;
    if (audioAllowed) {
      try {
        masterGain.gain.setValueAtTime(0.18, audioCtx.currentTime);
      } catch (err) {}
    }
  }

  // Draw utilities
  function drawBackground() {
    // Sky gradient with whimsical swirls
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#E8F3FF');
    g.addColorStop(0.5, '#FDF6F2');
    g.addColorStop(1, '#F7FFF6');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft wavy hills
    ctx.fillStyle = '#D7FFEE';
    ctx.beginPath();
    ctx.moveTo(0, HEIGHT * 0.6);
    for (let x = 0; x <= WIDTH; x += 20) {
      const y = HEIGHT * 0.6 + Math.sin(x * 0.02 + timeElapsed * 0.007) * 16;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(WIDTH, HEIGHT);
    ctx.lineTo(0, HEIGHT);
    ctx.closePath();
    ctx.fill();

    // Floating capacitor clouds (wacky)
    for (let i = 0; i < 4; i++) {
      ctx.save();
      const cx = 100 + i * 160 + Math.sin(timeElapsed * 0.002 + i) * 18;
      const cy = 70 + Math.cos(timeElapsed * 0.0012 + i) * 10;
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = '#FFF8EA';
      ctx.beginPath();
      ctx.ellipse(cx, cy, 48, 26, Math.sin(i) * 0.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#F1ECD8';
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawWire() {
    // central wavy wire
    ctx.save();
    ctx.lineWidth = 8;
    ctx.strokeStyle = '#444058';
    ctx.lineCap = 'round';
    ctx.beginPath();
    const y = HEIGHT - 120;
    for (let x = 0; x <= WIDTH; x += 8) {
      const yy = y + Math.sin((x + timeElapsed * 0.2) * 0.03) * 6;
      if (x === 0) ctx.moveTo(x, yy);
      else ctx.lineTo(x, yy);
    }
    ctx.stroke();

    // small glowing sparks along the wire
    for (let i = 0; i < 8; i++) {
      const tx = (i / 7) * WIDTH;
      const ty = y + Math.sin((tx + timeElapsed * 0.4) * 0.03) * 6;
      ctx.beginPath();
      const rk = (Math.sin(timeElapsed * 0.03 + i) + 1) / 2;
      ctx.fillStyle = `rgba(255,${180 + rk * 60},${80},${0.6})`;
      ctx.arc(tx, ty - 6, 5 + rk * 3, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawPlayer() {
    // Cute "Spark the Squirrel" made from shapes
    ctx.save();
    player.bob += 0.08;
    const bobY = Math.sin(player.bob) * 4;
    const x = player.x;
    const y = player.y + bobY;
    // shadow
    ctx.beginPath();
    ctx.ellipse(x, y + 30, 28, 8, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fill();

    // body
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.ellipse(x, y, 28, 20, 0, 0, Math.PI * 2);
    ctx.fill();

    // cheeks and belly
    ctx.fillStyle = '#FFD1E6';
    ctx.beginPath();
    ctx.ellipse(x - 6, y + 4, 12, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // ears
    ctx.fillStyle = '#FFB7D8';
    ctx.beginPath();
    ctx.ellipse(x - 14, y - 18, 8, 10, -0.3, 0, Math.PI * 2);
    ctx.ellipse(x + 6, y - 20, 8, 10, 0.2, 0, Math.PI * 2);
    ctx.fill();

    // tail
    ctx.save();
    ctx.translate(x + 22, y - 2);
    ctx.rotate(Math.sin(timeElapsed * 0.01) * 0.25);
    const tailGrad = ctx.createLinearGradient(-20, -10, 20, 10);
    tailGrad.addColorStop(0, '#FFB7D8');
    tailGrad.addColorStop(1, '#FF7BAC');
    ctx.fillStyle = tailGrad;
    ctx.beginPath();
    ctx.ellipse(0, 0, 14, 26, 0.6, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // eyes
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.arc(x - 6, y - 2, 3.5, 0, Math.PI * 2);
    ctx.arc(x + 6, y - 2, 3.5, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.strokeStyle = '#441';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x - 0, y + 6, 8, 0.2, Math.PI - 0.2);
    ctx.stroke();

    // name banner
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    ctx.fillRect(x - 42, y + 36, 84, 18);
    ctx.strokeRect(x - 42, y + 36, 84, 18);
    ctx.fillStyle = '#555';
    ctx.font = '12px Verdana';
    ctx.textAlign = 'center';
    ctx.fillText(player.name, x, y + 50);
    ctx.restore();
  }

  function drawElectrons() {
    for (const e of electrons) {
      ctx.save();
      ctx.translate(e.x, e.y);
      const wob = Math.sin(e.wobble + timeElapsed * 0.02) * 6;
      // glow
      ctx.beginPath();
      ctx.arc(0, wob, e.radius + 8, 0, Math.PI * 2);
      ctx.fillStyle = e.value === currentProblem.solution ? 'rgba(110,231,183,0.12)' : 'rgba(255,209,154,0.08)';
      ctx.fill();

      // orb
      const orbGrad = ctx.createRadialGradient(-e.radius*0.3, -e.radius*0.3, 2, 0, 0, e.radius);
      orbGrad.addColorStop(0, '#FFFFFF');
      orbGrad.addColorStop(0.3, e.color);
      orbGrad.addColorStop(1, '#C7B6FF');
      ctx.fillStyle = orbGrad;
      ctx.beginPath();
      ctx.arc(0, wob, e.radius, 0, Math.PI * 2);
      ctx.fill();

      // label
      ctx.fillStyle = '#222';
      ctx.font = 'bold 16px Verdana';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(e.value), 0, wob);
      ctx.restore();
    }
  }

  // Bulb and panel showing problem
  function drawPanel() {
    // Left: battery and professor ohm
    ctx.save();
    // Battery
    ctx.fillStyle = '#6C8EFF';
    ctx.fillRect(32, HEIGHT - 190, 60, 120);
    ctx.fillStyle = '#EDF0FF';
    ctx.fillRect(44, HEIGHT - 170, 36, 80);
    // Professor Ohm
    ctx.beginPath();
    ctx.fillStyle = '#F0D68B';
    ctx.arc(120, HEIGHT - 130, 28, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#3C2F2F';
    ctx.fillRect(106, HEIGHT - 124, 28, 6); // glasses bar
    ctx.fillStyle = '#E3A1A1';
    ctx.fillRect(100, HEIGHT - 100, 40, 36);
    ctx.fillStyle = '#553';
    ctx.fillText('Prof. Ohm', 120, HEIGHT - 58);

    // Central problem card
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.strokeStyle = '#CCDAFF';
    ctx.lineWidth = 3;
    ctx.fillRect(WIDTH / 2 - 160, 24, 320, 84);
    ctx.strokeRect(WIDTH / 2 - 160, 24, 320, 84);
    ctx.fillStyle = '#123';
    ctx.font = '20px Verdana';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const problemText = `${currentProblem.a} ${currentProblem.op} ${currentProblem.b} = ?`;
    ctx.fillText('Help Spark! Catch the right answer', WIDTH / 2, 36);
    ctx.font = '34px Verdana';
    ctx.fillText(problemText, WIDTH / 2, 36 + 42);
    ctx.restore();

    // Right: Glowy the Lightbulb
    ctx.save();
    const bx = WIDTH - 100;
    const by = HEIGHT - 160;
    // bulb light
    const bulbGlow = 0.5 + (bulbFlash > 0 ? 0.7 : 0) * (bulbFlash / 28);
    const radial = ctx.createRadialGradient(bx, by - 40, 6, bx, by - 40, 70);
    radial.addColorStop(0, `rgba(255,238,130,${0.9 * bulbGlow})`);
    radial.addColorStop(1, `rgba(255,238,130,${0.02 * bulbGlow})`);
    ctx.fillStyle = radial;
    ctx.beginPath();
    ctx.ellipse(bx, by - 40, 70, 90, 0, 0, Math.PI * 2);
    ctx.fill();

    // bulb glass
    ctx.fillStyle = '#fff8d6';
    ctx.beginPath();
    ctx.ellipse(bx, by - 40, 28, 36, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#C7B47A';
    ctx.stroke();

    // filament
    ctx.beginPath();
    ctx.moveTo(bx - 6, by - 48);
    ctx.quadraticCurveTo(bx, by - 36, bx + 6, by - 48);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#FFAA00';
    ctx.stroke();

    // base
    ctx.fillStyle = '#B3B3B3';
    ctx.fillRect(bx - 12, by - 16, 24, 20);
    ctx.strokeRect(bx - 12, by - 16, 24, 20);
    ctx.restore();

    // Draw HUD: score & lives
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(14, 12, 140, 56);
    ctx.strokeStyle = '#E2EAF9';
    ctx.strokeRect(14, 12, 140, 56);
    ctx.fillStyle = '#333';
    ctx.font = '14px Verdana';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 24, 34);
    ctx.fillText(`Level: ${level}`, 24, 54);
    // Lives hearts
    for (let i = 0; i < 3; i++) {
      const hx = 120 + i * 18;
      const hy = 34;
      ctx.beginPath();
      ctx.fillStyle = i < lives ? '#FF5D5D' : '#EEE';
      ctx.moveTo(hx, hy);
      ctx.arc(hx - 6, hy - 2, 6, 0, Math.PI * 2);
      ctx.arc(hx + 6, hy - 2, 6, 0, Math.PI * 2);
      ctx.lineTo(hx, hy + 10);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#C84D4D';
      ctx.stroke();
    }
    ctx.restore();

    // Sound icon
    drawSoundIcon(WIDTH - 36, 36);
  }

  function drawParticles() {
    for (const p of particles) {
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.globalAlpha = Math.max(0, p.life / 60);
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Update function
  let lastTime = performance.now();
  function update(now) {
    const dt = now - lastTime;
    lastTime = now;
    timeElapsed += dt;

    if (!isGameOver) {
      // Player movement
      if (keys.ArrowLeft || keys.a || keys.A) {
        player.vx = -player.speed;
      } else if (keys.ArrowRight || keys.d || keys.D) {
        player.vx = player.speed;
      } else {
        // slow down
        player.vx *= 0.86;
        if (Math.abs(player.vx) < 0.06) player.vx = 0;
      }
      player.x += player.vx;
      // Boundary
      player.x = Math.max(44, Math.min(WIDTH - 44, player.x));

      // Spawn electrons over time
      lastSpawn += dt;
      if (lastSpawn > spawnInterval) {
        spawnElectron();
        lastSpawn = 0;
      }

      // Move electrons
      for (let i = electrons.length - 1; i >= 0; i--) {
        const e = electrons[i];
        e.y += e.vy;
        e.wobble += 0.04;
        if (e.y > HEIGHT + 60) {
          // Missed: if the correct one is missed, penalize slightly
          if (e.value === currentProblem.solution) {
            lives -= 1;
            spawnParticles(e.x, HEIGHT - 80, '#FFB0B0', 10);
            playIncorrect();
            if (lives <= 0) {
              gameOver();
            }
            // New problem
            currentProblem = generateProblem(level);
          }
          electrons.splice(i, 1);
        }
      }

      // Particles update
      updateParticles();

      // Collisions
      checkCollisions();

      if (bulbFlash > 0) bulbFlash -= 1;

      // Slight background hum frequency drift for calming effect
      if (audioAllowed && bgOsc) {
        try {
          bgOsc.frequency.setValueAtTime(60 + Math.sin(timeElapsed * 0.0019) * 4, audioCtx.currentTime);
        } catch (err) {}
      }
    }
    draw();
    requestAnimationFrame(update);
  }

  // Draw everything
  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawWire();
    drawElectrons();
    drawPlayer();
    drawPanel();
    drawParticles();

    // On-screen instructions & visual accessibility cues
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillRect(12, HEIGHT - 48, 260, 36);
    ctx.strokeStyle = '#E3E3E3';
    ctx.strokeRect(12, HEIGHT - 48, 260, 36);
    ctx.fillStyle = '#333';
    ctx.font = '13px Verdana';
    ctx.textAlign = 'left';
    ctx.fillText('Use ← → keys or tap sides to move. Press S to toggle sound. Catch the correct number!', 20, HEIGHT - 24);
    ctx.restore();

    // If audio error, show textual indicator
    if (audioError) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,200,200,0.95)';
      ctx.fillRect(WIDTH - 280, HEIGHT - 60, 268, 44);
      ctx.fillStyle = '#650000';
      ctx.font = '12px Verdana';
      ctx.textAlign = 'left';
      ctx.fillText('Audio unavailable in this browser. Sound disabled.', WIDTH - 268, HEIGHT - 36);
      ctx.restore();
    }

    // If game over, overlay
    if (isGameOver) {
      ctx.save();
      ctx.fillStyle = 'rgba(12, 12, 20, 0.6)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = '36px Verdana';
      ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 40);
      ctx.font = '20px Verdana';
      ctx.fillText(`Score: ${score}`, WIDTH / 2, HEIGHT / 2 - 8);
      ctx.fillText('Tap or press R to restart', WIDTH / 2, HEIGHT / 2 + 26);
      ctx.restore();
    }
  }

  // Input for restart
  window.addEventListener('keydown', (e) => {
    if ((e.key === 'r' || e.key === 'R') && isGameOver) {
      restartGame();
    }
    // space to try to collect nearest electron (optional)
    if (e.key === ' ' && !isGameOver) {
      // move player quickly upward to "reach" slightly earlier
      player.vx *= 1.2;
    }
  });

  // Also allow clicking overlay to restart
  canvas.addEventListener('click', (e) => {
    if (isGameOver) {
      restartGame();
    }
  });

  // Kick off animation
  requestAnimationFrame(update);

  // Small friendly console message
  console.info('Electric Math Game loaded. Use arrow keys to move Spark and S to toggle sound.');

  // Safety: attempt to init audio on first user gesture on canvas
  function gestureInit() {
    if (!audioAllowed) {
      initAudio();
    }
    canvas.removeEventListener('pointerdown', gestureInit);
  }
  canvas.addEventListener('pointerdown', gestureInit);

  // Expose some state for testing (non-intrusive)
  window.__electricMathGame = {
    restart: restartGame,
    toggleSound: () => {
      if (!audioAllowed) initAudio();
      soundEnabled = !soundEnabled;
    },
    status: () => ({ score, lives, level, problemsSolved, soundEnabled, audioAllowed, audioError })
  };

  // Ensure size and focusability for accessibility
  canvas.tabIndex = 0;
  canvas.addEventListener('focus', () => {
    // Draw a subtle focus ring
    ctx.save();
    ctx.strokeStyle = '#6EA6FF';
    ctx.lineWidth = 4;
    ctx.strokeRect(4, 4, WIDTH - 8, HEIGHT - 8);
    ctx.restore();
  });

})();
---

