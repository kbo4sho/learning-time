# Game of the Day - 2025-08-17

## Metadata
- **Generated Date:** 2025-08-17
- **Generated Time:** 2025-08-17T00:24:48.981109
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-17.js
- **File Size:** 34693 bytes
- **Tokens Used:** 11122

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-17.js` - The playable game
- `2025-08-17.meta.json` - Machine-readable metadata
- `2025-08-17.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22186

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23489

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Electricity Math Game for ages 7-9
  // Renders inside element with ID 'game-of-the-day-stage'
  // Canvas is 720x480. All graphics drawn with canvas APIs. Sounds with Web Audio API.
  // Keyboard accessible, touch/mouse drag supported, error handling for audio.

  // Find stage element
  const stage = document.getElementById('game-of-the-day-stage');
  if (!stage) {
    console.error('Element with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear stage and create canvas
  stage.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.setAttribute('tabindex', '0'); // focusable for keyboard
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label',
    'Electric Math Lab. Drag numbered charge-orbs into device sockets to match target numbers. ' +
    'Use mouse or touch to drag. Use number keys 1-9 to pick an orb and Enter to place into a selected socket. ' +
    'Press M to mute/unmute sound. Correct matches light up devices.');
  stage.appendChild(canvas);

  const ctx = canvas.getContext('2d', { alpha: false });

  // Accessibility readout element (hidden visually but readable for screen readers)
  const ariaStatus = document.createElement('div');
  ariaStatus.setAttribute('aria-live', 'polite');
  ariaStatus.style.position = 'absolute';
  ariaStatus.style.left = '-9999px';
  ariaStatus.style.width = '1px';
  ariaStatus.style.height = '1px';
  ariaStatus.style.overflow = 'hidden';
  ariaStatus.id = 'electric-math-aria';
  stage.appendChild(ariaStatus);

  // Game constants
  const WIDTH = 720;
  const HEIGHT = 480;

  // Audio setup with error handling
  let audioCtx = null;
  let masterGain = null;
  let backgroundNode = null;
  let audioEnabled = true;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.6; // default volume
    masterGain.connect(audioCtx.destination);
    // gentle background hum (low volume, subtle filter)
    backgroundNode = audioCtx.createOscillator();
    const bgGain = audioCtx.createGain();
    const bgFilter = audioCtx.createBiquadFilter();
    backgroundNode.type = 'sine';
    backgroundNode.frequency.value = 80;
    bgFilter.type = 'lowpass';
    bgFilter.frequency.value = 400;
    bgGain.gain.value = 0.02;
    backgroundNode.connect(bgFilter);
    bgFilter.connect(bgGain);
    bgGain.connect(masterGain);
    backgroundNode.start();
  } catch (e) {
    console.warn('Web Audio API not available or could not be started:', e);
    audioEnabled = false;
    audioCtx = null;
  }

  // Helper to create short chime for success
  function playSuccess() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc1.type = 'sine';
      osc2.type = 'triangle';
      osc1.frequency.setValueAtTime(880, now);
      osc2.frequency.setValueAtTime(1320, now);
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(1200, now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);
      osc1.connect(filter);
      osc2.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc1.start(now);
      osc2.start(now);
      osc1.stop(now + 0.95);
      osc2.stop(now + 0.95);
    } catch (e) {
      console.warn('Error playing success sound:', e);
    }
  }

  // Helper to play buzzer for incorrect
  function playBuzzer() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc.type = 'square';
      osc.frequency.setValueAtTime(160, now);
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(700, now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start(now);
      osc.stop(now + 0.6);
    } catch (e) {
      console.warn('Error playing buzzer:', e);
    }
  }

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioCtx) {
      audioEnabled = false;
      return;
    }
    audioEnabled = !audioEnabled;
    if (!audioEnabled) {
      masterGain.gain.value = 0.0;
    } else {
      masterGain.gain.value = 0.6;
    }
  }

  // Game state
  let level = 1;
  const maxLevels = 6;
  let score = 0;
  let roundSolved = false;
  let timeSinceSolve = 0;

  // Orbs (chargers) bank attached to left side. Each orb has a number 1-9.
  const orbBank = [];
  // Targets: devices placed across the right/top area with sockets.
  const devices = [];

  // Dragging state
  let draggingOrb = null;
  let dragOffset = { x: 0, y: 0 };

  // Selection for keyboard control
  let selectedOrbIndex = 0; // index in orbBank for keyboard pick
  let selectedDeviceIndex = 0;
  let carryOrb = null; // orb currently held by keyboard

  // Random helpers
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Initialize round: create orbs and devices according to level
  function initRound() {
    roundSolved = false;
    timeSinceSolve = 0;
    orbBank.length = 0;
    devices.length = 0;
    // Difficulty scaling: as level increases, increase orb count and socket counts, target range
    const orbCount = Math.min(9, 4 + level); // 5..9
    const deviceCount = Math.min(4, 1 + Math.floor(level / 2)); // 1..3
    const maxTarget = 6 + level * 2; // 8..18
    // Generate orbs with numbers so that a solution exists
    // Approach: create a target list first, then generate orbs including exact sums
    const targets = [];
    for (let i = 0; i < deviceCount; i++) {
      const target = randInt(4, Math.min(12 + level, maxTarget));
      const sockets = Math.min(3, 1 + Math.floor(level / 3)); // 1..3 sockets
      targets.push({ target, sockets });
    }
    // Fill orb bank by starting with numbers that can sum to targets
    const created = [];
    // For each target, create numbers that sum to it using 1..3 addends
    targets.forEach(t => {
      let remain = t.target;
      const parts = [];
      for (let s = 0; s < t.sockets - 1; s++) {
        const part = randInt(1, Math.max(1, Math.floor(remain / 2)));
        parts.push(part);
        remain -= part;
      }
      parts.push(remain);
      parts.forEach(p => created.push(Math.max(1, Math.min(9, p))));
    });
    // Fill the rest with random numbers
    while (created.length < orbCount) {
      created.push(randInt(1, 9));
    }
    // Shuffle created
    for (let i = created.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [created[i], created[j]] = [created[j], created[i]];
    }
    // Place orbs visually
    const baseX = 20;
    const baseY = 80;
    const spacingY = 60;
    created.forEach((num, i) => {
      orbBank.push({
        id: `o${i}_${Date.now()}`,
        value: num,
        x: baseX,
        y: baseY + i * spacingY,
        radius: 22,
        placed: false
      });
    });
    // Create devices positioned on right
    const devBaseX = 400;
    const devBaseY = 80;
    const devSpacingX = 300 / Math.max(1, deviceCount);
    for (let i = 0; i < deviceCount; i++) {
      const d = {
        id: 'd' + i,
        x: devBaseX + i * devSpacingX,
        y: devBaseY + i * 80,
        width: 240,
        height: 120,
        target: targets[i].target,
        sockets: targets[i].sockets,
        socketOrbs: new Array(targets[i].sockets).fill(null),
        lit: false,
        wobble: 0
      };
      devices.push(d);
    }
    // Reset selection
    selectedOrbIndex = 0;
    selectedDeviceIndex = 0;
    carryOrb = null;
    updateAria('New round started. Level ' + level + '. Place orbs to match device targets.');
  }

  // Check devices for correct sums
  function checkDevices() {
    let allGood = true;
    devices.forEach(dev => {
      const sum = dev.socketOrbs.reduce((acc, o) => acc + (o ? o.value : 0), 0);
      if (sum === dev.target) {
        if (!dev.lit) {
          dev.lit = true;
          sparkAnimation(dev);
          playSuccess();
          updateAria(`Device target ${dev.target} solved!`);
          score += 10;
        }
      } else {
        if (dev.lit) {
          // previously lit, now changed (shouldn't happen), but reset
          dev.lit = false;
        }
        allGood = false;
      }
    });
    if (allGood && devices.length > 0) {
      roundSolved = true;
      timeSinceSolve = 0;
      updateAria('All devices powered! Level completed.');
    }
  }

  // Spark animation state store
  const sparks = [];

  function sparkAnimation(dev) {
    // spawn several sparks around device
    for (let i = 0; i < 12; i++) {
      sparks.push({
        x: dev.x + dev.width * (Math.random() * 0.8 + 0.1),
        y: dev.y + dev.height * (Math.random() * 0.8 + 0.1),
        vx: Math.random() * 4 - 2,
        vy: Math.random() * -3 - 1,
        life: 60 + Math.random() * 30,
        color: 'rgba(255, 255, 120, 1)'
      });
    }
  }

  // Draw helpers for cute characters and wacky electricity
  function drawBackground() {
    // Gentle gradient background
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#edf6ff');
    g.addColorStop(1, '#eafbee');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Wacky clouds with smiley faces
    drawCloud(120, 40, 60, 30, '#ffffff', '#bfefff', true);
    drawCloud(540, 60, 70, 34, '#fff7f2', '#ffd9c8', true);

    // Lab table
    ctx.fillStyle = '#f3f0ff';
    ctx.fillRect(0, 360, WIDTH, 120);
    ctx.strokeStyle = '#d0c9ff';
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 360, WIDTH, 120);

    // Title
    ctx.fillStyle = '#0b3d91';
    ctx.font = '20px "Segoe UI", Roboto, Arial';
    ctx.fillText('Sparky\'s Electric Math Lab — Level ' + level + '  Score: ' + score, 20, 28);
  }

  function drawCloud(cx, cy, rx, ry, color, edgeColor, smile) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(-rx * 0.4, 0, rx * 0.6, ry, 0, 0, Math.PI * 2);
    ctx.ellipse(rx * 0.2, -ry * 0.2, rx * 0.76, ry * 0.9, 0, 0, Math.PI * 2);
    ctx.ellipse(rx * 0.7, ry * 0.1, rx * 0.5, ry * 0.8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = edgeColor;
    ctx.lineWidth = 2;
    ctx.stroke();
    if (smile) {
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(0 - rx * 0.1, -2, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(rx * 0.35, -4, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      ctx.arc(rx * 0.1, 4, 8, 0, Math.PI);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawOrb(o, highlight = false) {
    // body
    ctx.save();
    ctx.translate(o.x, o.y);
    const grd = ctx.createRadialGradient(-6, -6, 6, 6, 6, o.radius);
    grd.addColorStop(0, highlight ? '#fff7b6' : '#fffef0');
    grd.addColorStop(1, '#ffdd4a');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, o.radius, 0, Math.PI * 2);
    ctx.fill();
    // glossy
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.ellipse(-6, -8, o.radius * 0.5, o.radius * 0.35, -0.5, 0, Math.PI * 2);
    ctx.fill();
    // number
    ctx.fillStyle = '#2b2b2b';
    ctx.font = 'bold 16px "Segoe UI", Roboto, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(o.value, 0, 0);
    ctx.restore();
  }

  function drawDevice(dev) {
    ctx.save();
    // body
    ctx.fillStyle = dev.lit ? 'rgba(255,245,200,0.95)' : '#f6f8ff';
    ctx.strokeStyle = '#b9c7ff';
    ctx.lineWidth = 2;
    const x = dev.x;
    const y = dev.y;
    ctx.beginPath();
    roundRect(ctx, x, y, dev.width, dev.height, 10);
    ctx.fill();
    ctx.stroke();

    // cute character: Sparky lightbulb face top-left of device area
    drawSparky(x + 18, y + 18, dev.lit);

    // Target text
    ctx.fillStyle = '#0a2d5a';
    ctx.font = '16px "Segoe UI", Roboto, Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Target: ' + dev.target, x + 60, y + 28);

    // sockets
    const spacing = (dev.width - 40) / Math.max(1, dev.sockets);
    for (let i = 0; i < dev.sockets; i++) {
      const sx = x + 20 + i * spacing + spacing / 2;
      const sy = y + dev.height - 34;
      ctx.beginPath();
      ctx.fillStyle = '#eef3ff';
      ctx.strokeStyle = '#a8bdfa';
      ctx.lineWidth = 2;
      ctx.arc(sx, sy, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // value if present
      const placed = dev.socketOrbs[i];
      if (placed) {
        // draw smaller orb inside
        ctx.save();
        ctx.translate(sx, sy);
        ctx.beginPath();
        ctx.fillStyle = '#fff7b6';
        ctx.arc(0, 0, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#f1c542';
        ctx.stroke();
        ctx.fillStyle = '#17292b';
        ctx.font = 'bold 14px "Segoe UI", Roboto, Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(placed.value, 0, 0);
        ctx.restore();
      } else {
        // hint small plus sign
        ctx.fillStyle = '#93a8ff';
        ctx.fillRect(sx - 1, sy - 8, 2, 16);
        ctx.fillRect(sx - 8, sy - 1, 16, 2);
      }

      // highlight selection
      if (selectedDeviceIndex === devices.indexOf(dev) && selectedOrbIndex === -1) {
        // show a subtle pulsing ring
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(20,120,200,0.25)';
        ctx.lineWidth = 4;
        ctx.arc(sx, sy, 26 + Math.sin(Date.now() / 250) * 2, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    // wires from left battery to this device - wacky zigzags
    drawWire(180, y + dev.height / 2, x + 10, y + dev.height / 2, dev.lit);

    ctx.restore();
  }

  function drawSparky(cx, cy, lit) {
    ctx.save();
    ctx.translate(cx, cy);
    // bulb body
    ctx.beginPath();
    ctx.fillStyle = lit ? '#fff8b8' : '#fff';
    ctx.arc(0, 0, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#d1caa3';
    ctx.lineWidth = 2;
    ctx.stroke();
    // eyes
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(-6, -2, 2.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(2, -2, 2.5, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.beginPath();
    ctx.strokeStyle = '#373737';
    ctx.lineWidth = 1;
    ctx.arc(-1, 2, 6, 0.15 * Math.PI, 0.85 * Math.PI);
    ctx.stroke();
    // filament lines if lit
    if (lit) {
      ctx.strokeStyle = '#ffbb20';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-4, -2);
      ctx.lineTo(0, -6);
      ctx.lineTo(4, -2);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawWire(x1, y1, x2, y2, energized) {
    ctx.save();
    ctx.strokeStyle = energized ? 'rgba(255,200,80,1)' : '#9aaee8';
    ctx.lineWidth = 4;
    ctx.beginPath();
    // zigzag path
    const dx = x2 - x1;
    const dy = y2 - y1;
    const steps = 6;
    ctx.moveTo(x1, y1);
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const px = x1 + dx * t + Math.sin((t + Date.now() / 600) * Math.PI * 4) * 6;
      const py = y1 + dy * t + Math.cos((t + Date.now() / 600) * Math.PI * 3) * 2;
      ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.restore();
  }

  // Rounded rectangle helper
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // UI draw (orb bank, buttons)
  function drawUI() {
    // Orb bank title
    ctx.fillStyle = '#0a2d5a';
    ctx.font = '16px "Segoe UI", Roboto, Arial';
    ctx.fillText('Charge Orbs', 20, 60);

    // Draw orbs not placed
    orbBank.forEach((o, idx) => {
      if (!o.placed && o !== draggingOrb && o !== carryOrb) {
        const highlight = selectedOrbIndex === idx && carryOrb === null;
        drawOrb(o, highlight);
        // keyboard selection rectangle
        if (highlight) {
          ctx.save();
          ctx.strokeStyle = 'rgba(20,120,200,0.2)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(o.x, o.y, o.radius + 8, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
      }
    });

    // Draw battery character near left center
    drawBattery(180, 200);

    // Draw devices
    devices.forEach((d, idx) => {
      drawDevice(d);
    });

    // Draw dragging orb above everything
    if (draggingOrb) {
      drawOrb(draggingOrb, true);
    }
    if (carryOrb) {
      // draw carrier orb near top center for keyboard carry
      const px = 360;
      const py = 40;
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.translate(px, py);
      drawOrb({ x: 0, y: 0, radius: 22, value: carryOrb.value }, true);
      ctx.restore();
    }

    // Speaker icon
    drawSpeakerIcon(WIDTH - 44, 12, audioEnabled);

    // Instructions
    ctx.fillStyle = '#184580';
    ctx.font = '13px "Segoe UI", Roboto, Arial';
    ctx.fillText('Instructions: Drag number orbs into device sockets to match the target sum.', 20, HEIGHT - 28);
    ctx.fillText('Keyboard: 1-9 pick orb, Tab switches focus, Arrow keys select socket, Enter places, Delete removes, M mute.', 20, HEIGHT - 10);
  }

  function drawBattery(cx, cy) {
    ctx.save();
    ctx.translate(cx, cy);
    // battery body
    ctx.fillStyle = '#f7f7fb';
    ctx.strokeStyle = '#b6bde6';
    ctx.lineWidth = 2;
    roundRect(ctx, -60, -40, 120, 80, 8);
    ctx.fill();
    ctx.stroke();
    // terminals
    ctx.fillStyle = '#d3d7ff';
    ctx.fillRect(64, -12, 16, 24);
    // character face on battery
    ctx.fillStyle = '#1a2b4a';
    ctx.beginPath();
    ctx.arc(-30, -8, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(-10, -8, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#1a2b4a';
    ctx.beginPath();
    ctx.arc(-20, 2, 10, 0.15 * Math.PI, 0.85 * Math.PI);
    ctx.stroke();
    // bolt logo
    ctx.fillStyle = '#ffd84a';
    ctx.beginPath();
    ctx.moveTo(10, -20);
    ctx.lineTo(2, 0);
    ctx.lineTo(16, 0);
    ctx.lineTo(4, 20);
    ctx.lineTo(18, -2);
    ctx.lineTo(6, -2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawSpeakerIcon(x, y, on) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = on ? '#ffcf33' : '#cccccc';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.lineTo(12, -6);
    ctx.lineTo(12, 26);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    if (on) {
      ctx.beginPath();
      ctx.arc(22, 6, 10, -0.6, 0.6);
      ctx.strokeStyle = 'rgba(255,150,0,0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(30, 6, 14, -0.6, 0.6);
      ctx.strokeStyle = 'rgba(255,200,80,0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();
    } else {
      // draw small cross to indicate off
      ctx.strokeStyle = '#7a7a7a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(22, -6);
      ctx.lineTo(34, 18);
      ctx.moveTo(34, -6);
      ctx.lineTo(22, 18);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Mouse and touch handling
  function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);
    const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);
    return {
      x: (clientX - rect.left) * (canvas.width / rect.width),
      y: (clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  function onPointerDown(e) {
    e.preventDefault();
    const pos = getMousePos(e);
    // first check orbs
    for (let i = 0; i < orbBank.length; i++) {
      const o = orbBank[i];
      if (!o.placed) {
        const dx = pos.x - o.x;
        const dy = pos.y - o.y;
        if (dx * dx + dy * dy <= o.radius * o.radius) {
          draggingOrb = o;
          dragOffset.x = pos.x - o.x;
          dragOffset.y = pos.y - o.y;
          selectedOrbIndex = i;
          selectedDeviceIndex = -1;
          carryOrb = null;
          return;
        }
      }
    }
    // if clicking on a device socket, maybe pick up orb from socket
    for (let di = 0; di < devices.length; di++) {
      const d = devices[di];
      const spacing = (d.width - 40) / Math.max(1, d.sockets);
      for (let si = 0; si < d.sockets; si++) {
        const sx = d.x + 20 + si * spacing + spacing / 2;
        const sy = d.y + d.height - 34;
        const dx = pos.x - sx;
        const dy = pos.y - sy;
        if (dx * dx + dy * dy <= 20 * 20) {
          // pick up if present
          if (d.socketOrbs[si]) {
            const orb = d.socketOrbs[si];
            d.socketOrbs[si] = null;
            orb.placed = false;
            // put orb at pointer and start dragging
            orb.x = pos.x;
            orb.y = pos.y;
            draggingOrb = orb;
            dragOffset.x = 0;
            dragOffset.y = 0;
            selectedDeviceIndex = di;
            selectedOrbIndex = orbBank.indexOf(orb);
            updateAria('Picked up orb ' + orb.value + ' from device socket.');
            return;
          } else {
            // empty socket clicked -> highlight for keyboard selection
            selectedDeviceIndex = di;
            selectedOrbIndex = -1;
            carryOrb = null;
            updateAria('Selected device ' + (di + 1) + '. Use number keys to pick up an orb.');
            return;
          }
        }
      }
    }
  }

  function onPointerMove(e) {
    if (!draggingOrb) return;
    e.preventDefault();
    const pos = getMousePos(e);
    draggingOrb.x = pos.x - dragOffset.x;
    draggingOrb.y = pos.y - dragOffset.y;
  }

  function onPointerUp(e) {
    if (!draggingOrb) return;
    e.preventDefault();
    const pos = getMousePos(e);
    // check drop into a socket
    let placed = false;
    for (let di = 0; di < devices.length; di++) {
      const d = devices[di];
      const spacing = (d.width - 40) / Math.max(1, d.sockets);
      for (let si = 0; si < d.sockets; si++) {
        const sx = d.x + 20 + si * spacing + spacing / 2;
        const sy = d.y + d.height - 34;
        const dx = pos.x - sx;
        const dy = pos.y - sy;
        if (dx * dx + dy * dy <= 22 * 22) {
          // If socket empty, place
          if (!d.socketOrbs[si]) {
            d.socketOrbs[si] = draggingOrb;
            draggingOrb.placed = true;
            // snap orb into socket visually
            draggingOrb.x = sx;
            draggingOrb.y = sy;
            placed = true;
            updateAria('Placed orb ' + draggingOrb.value + ' into device target ' + d.target + '.');
            // check devices after small hump
            break;
          } else {
            // occupied -> bounce back
            playBuzzer();
          }
        }
      }
      if (placed) break;
    }
    if (!placed) {
      // if dropped outside, return to bank positions
      // find bank index and return to its natural position
      const idx = orbBank.indexOf(draggingOrb);
      if (idx >= 0) {
        draggingOrb.x = 20;
        draggingOrb.y = 80 + idx * 60;
      }
    } else {
      playSuccess();
    }
    draggingOrb = null;
    checkDevices();
  }

  // Keyboard controls
  // Number keys 1-9 pick corresponding orb from bank if exists
  // Arrow keys navigate device sockets, Enter places carry orb into selected socket
  // Delete removes orb from selected socket back to bank
  let deviceFocusIndex = 0; // which device is focused for keyboard placement

  function onKeyDown(e) {
    if (e.key === 'm' || e.key === 'M') {
      toggleAudio();
      updateAria('Audio ' + (audioEnabled ? 'enabled' : 'muted') + '.');
      e.preventDefault();
      return;
    }
    // Number keys
    if (/^[1-9]$/.test(e.key)) {
      const numKey = parseInt(e.key, 10);
      // find an orb in bank with that value not placed
      let foundIndex = -1;
      for (let i = 0; i < orbBank.length; i++) {
        const o = orbBank[i];
        if (!o.placed && o.value === numKey) {
          foundIndex = i;
          break;
        }
      }
      if (foundIndex >= 0) {
        carryOrb = { ...orbBank[foundIndex] }; // shallow copy with same value
        // Mark original as ghost temporarily so it's not selectable
        // Actually we keep original; but keyboard carry references value only, placing will remove actual orb.
        selectedOrbIndex = foundIndex;
        selectedDeviceIndex = deviceFocusIndex;
        updateAria('Picked up orb ' + carryOrb.value + ' with keyboard. Select a device socket and press Enter to place.');
      } else {
        updateAria('No available orb with value ' + numKey + '.');
        playBuzzer();
      }
      e.preventDefault();
      return;
    }
    // Tab to switch between orb bank and devices (prevent default tabbing)
    if (e.key === 'Tab') {
      // cycle focus between orb list and devices
      if (selectedOrbIndex === -1) {
        // move to orb bank selection
        selectedOrbIndex = 0;
        selectedDeviceIndex = -1;
      } else {
        selectedDeviceIndex = 0;
        selectedOrbIndex = -1;
      }
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowRight') {
      // move deviceFocusIndex right
      deviceFocusIndex = (deviceFocusIndex + 1) % devices.length;
      selectedDeviceIndex = deviceFocusIndex;
      selectedOrbIndex = -1;
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowLeft') {
      deviceFocusIndex = (deviceFocusIndex - 1 + devices.length) % devices.length;
      selectedDeviceIndex = deviceFocusIndex;
      selectedOrbIndex = -1;
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowUp') {
      // cycle orb bank selection up
      selectedOrbIndex = (selectedOrbIndex - 1 + orbBank.length) % orbBank.length;
      selectedDeviceIndex = -1;
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown') {
      selectedOrbIndex = (selectedOrbIndex + 1) % orbBank.length;
      selectedDeviceIndex = -1;
      e.preventDefault();
      return;
    }
    if (e.key === 'Enter') {
      // place carry orb into focused device's first available socket
      if (carryOrb && selectedDeviceIndex >= 0) {
        const dev = devices[selectedDeviceIndex];
        let placed = false;
        for (let si = 0; si < dev.sockets; si++) {
          if (!dev.socketOrbs[si]) {
            // find original orb in bank with matching value and not placed
            const origIdx = orbBank.findIndex(o => !o.placed && o.value === carryOrb.value);
            if (origIdx >= 0) {
              const orig = orbBank[origIdx];
              orig.placed = true;
              dev.socketOrbs[si] = orig;
              // snap to socket
              const spacing = (dev.width - 40) / Math.max(1, dev.sockets);
              const sx = dev.x + 20 + si * spacing + spacing / 2;
              const sy = dev.y + dev.height - 34;
              orig.x = sx;
              orig.y = sy;
              placed = true;
              updateAria('Placed orb ' + orig.value + ' into device target ' + dev.target + ' via keyboard.');
              playSuccess();
            } else {
              // should not happen - nothing found to match carry
              playBuzzer();
            }
            break;
          }
        }
        if (!placed) {
          updateAria('No available socket on selected device.');
          playBuzzer();
        }
        carryOrb = null;
        checkDevices();
      } else if (selectedOrbIndex >= 0 && selectedDeviceIndex >= 0) {
        // pick orb from bank and place into device
        const orig = orbBank[selectedOrbIndex];
        if (!orig.placed) {
          const dev = devices[selectedDeviceIndex];
          let placed = false;
          for (let si = 0; si < dev.sockets; si++) {
            if (!dev.socketOrbs[si]) {
              dev.socketOrbs[si] = orig;
              orig.placed = true;
              const spacing = (dev.width - 40) / Math.max(1, dev.sockets);
              const sx = dev.x + 20 + si * spacing + spacing / 2;
              const sy = dev.y + dev.height - 34;
              orig.x = sx;
              orig.y = sy;
              placed = true;
              updateAria('Placed orb ' + orig.value + ' into device target ' + dev.target + ' via keyboard.');
              playSuccess();
              break;
            }
          }
          if (!placed) {
            playBuzzer();
            updateAria('No available socket on selected device.');
          }
          checkDevices();
        }
      }
      e.preventDefault();
      return;
    }
    if (e.key === 'Delete' || e.key === 'Backspace') {
      // remove orb from selected device and return to bank
      if (selectedDeviceIndex >= 0) {
        const dev = devices[selectedDeviceIndex];
        // remove last non-null orb found
        for (let si = dev.sockets - 1; si >= 0; si--) {
          if (dev.socketOrbs[si]) {
            const orb = dev.socketOrbs[si];
            dev.socketOrbs[si] = null;
            orb.placed = false;
            // send it back to its bank position
            const idx = orbBank.indexOf(orb);
            if (idx >= 0) {
              orb.x = 20;
              orb.y = 80 + idx * 60;
            }
            updateAria('Removed orb ' + orb.value + ' from device.');
            playBuzzer();
            checkDevices();
            break;
          }
        }
      }
      e.preventDefault();
      return;
    }
  }

  // Aria update for screen readers
  function updateAria(text) {
    ariaStatus.textContent = text;
  }

  // Game loop
  let lastTS = 0;
  function loop(ts) {
    const dt = Math.min(50, ts - lastTS);
    lastTS = ts;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    // update sparks
    for (let i = sparks.length - 1; i >= 0; i--) {
      const s = sparks[i];
      s.x += s.vx;
      s.y += s.vy;
      s.vy += 0.12;
      s.life -= 1;
      if (s.life <= 0) sparks.splice(i, 1);
    }
    // device wobble
    devices.forEach(d => {
      if (d.lit) {
        d.wobble = Math.min(8, d.wobble + 0.4);
      } else {
        d.wobble = Math.max(0, d.wobble - 0.6);
      }
    });

    // After round solved, proceed to next level after small delay
    if (roundSolved) {
      timeSinceSolve += dt;
      if (timeSinceSolve > 1400) {
        level++;
        if (level > maxLevels) {
          // game finished - reset level and increase challenge
          updateAria('Congratulations! You completed all levels. Starting over.');
          level = 1;
          score = 0;
        } else {
          updateAria('Advancing to level ' + level + '.');
        }
        initRound();
      }
    }

    // Slight bobbing animation for orbs in bank
    orbBank.forEach((o, idx) => {
      if (!o.placed && o !== draggingOrb) {
        o.x = 20 + Math.sin(Date.now() / 500 + idx) * 2;
        // ensure vertical anchors remain consistent
        o.y = 80 + idx * 60;
      }
    });
  }

  function render() {
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawUI();

    // sparks on top of everything
    sparks.forEach(s => {
      ctx.save();
      ctx.fillStyle = s.color;
      ctx.globalAlpha = Math.max(0, Math.min(1, s.life / 60));
      ctx.beginPath();
      ctx.arc(s.x, s.y, 3 + Math.random() * 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
  }

  // Placement helper to find bank orb by id
  function findOrbById(id) {
    return orbBank.find(o => o.id === id);
  }

  // Event listeners
  canvas.addEventListener('mousedown', onPointerDown);
  canvas.addEventListener('mousemove', onPointerMove);
  document.addEventListener('mouseup', onPointerUp);
  // touch support
  canvas.addEventListener('touchstart', onPointerDown, { passive: false });
  canvas.addEventListener('touchmove', onPointerMove, { passive: false });
  document.addEventListener('touchend', onPointerUp);

  // keyboard
  canvas.addEventListener('keydown', onKeyDown);

  // clicking speaker icon (determine click coords)
  canvas.addEventListener('click', function(e) {
    const pos = getMousePos(e);
    // speaker icon at WIDTH - 44, 12 and approx size 44x36
    if (pos.x >= WIDTH - 60 && pos.x <= WIDTH && pos.y >= 0 && pos.y <= 44) {
      toggleAudio();
      updateAria('Audio ' + (audioEnabled ? 'enabled' : 'muted') + '.');
    }
  });

  // Initialize and start
  initRound();
  requestAnimationFrame(loop);

  // Safe API: Provide a small public interface via window for debugging (non-essential)
  try {
    window.electricMathGame = {
      reset: function() {
        level = 1;
        score = 0;
        initRound();
      },
      toggleAudio: toggleAudio
    };
  } catch (e) {
    // ignore if cannot attach to window
  }

  // Error handling for audio resume on user gesture - some browsers require resume
  function resumeAudioOnInteraction() {
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        audioEnabled = true;
        masterGain.gain.value = 0.6;
      }).catch(err => {
        console.warn('Could not resume audio context:', err);
        audioEnabled = false;
      });
    }
  }
  // Add one-time listeners to attempt resume on first user gesture
  const resumeHandler = function() {
    resumeAudioOnInteraction();
    window.removeEventListener('mousedown', resumeHandler);
    window.removeEventListener('touchstart', resumeHandler);
    window.removeEventListener('keydown', resumeHandler);
  };
  window.addEventListener('mousedown', resumeHandler);
  window.addEventListener('touchstart', resumeHandler);
  window.addEventListener('keydown', resumeHandler);
})();
---

