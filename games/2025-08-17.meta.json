{
  "generated_date": "2025-08-17",
  "generated_timestamp": "2025-08-17T00:24:48.981109",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 11122,
  "game_filename": "2025-08-17.js",
  "game_size_bytes": 34693,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Electricity Math Game for ages 7-9\n  // Renders inside element with ID 'game-of-the-day-stage'\n  // Canvas is 720x480. All graphics drawn with canvas APIs. Sounds with Web Audio API.\n  // Keyboard accessible, touch/mouse drag supported, error handling for audio.\n\n  // Find stage element\n  const stage = document.getElementById('game-of-the-day-stage');\n  if (!stage) {\n    console.error('Element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear stage and create canvas\n  stage.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n  canvas.setAttribute('tabindex', '0'); // focusable for keyboard\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label',\n    'Electric Math Lab. Drag numbered charge-orbs into device sockets to match target numbers. ' +\n    'Use mouse or touch to drag. Use number keys 1-9 to pick an orb and Enter to place into a selected socket. ' +\n    'Press M to mute/unmute sound. Correct matches light up devices.');\n  stage.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d', { alpha: false });\n\n  // Accessibility readout element (hidden visually but readable for screen readers)\n  const ariaStatus = document.createElement('div');\n  ariaStatus.setAttribute('aria-live', 'polite');\n  ariaStatus.style.position = 'absolute';\n  ariaStatus.style.left = '-9999px';\n  ariaStatus.style.width = '1px';\n  ariaStatus.style.height = '1px';\n  ariaStatus.style.overflow = 'hidden';\n  ariaStatus.id = 'electric-math-aria';\n  stage.appendChild(ariaStatus);\n\n  // Game constants\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let masterGain = null;\n  let backgroundNode = null;\n  let audioEnabled = true;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    audioCtx = new AudioContext();\n    masterGain = audioCtx.createGain();\n    masterGain.gain.value = 0.6; // default volume\n    masterGain.connect(audioCtx.destination);\n    // gentle background hum (low volume, subtle filter)\n    backgroundNode = audioCtx.createOscillator();\n    const bgGain = audioCtx.createGain();\n    const bgFilter = audioCtx.createBiquadFilter();\n    backgroundNode.type = 'sine';\n    backgroundNode.frequency.value = 80;\n    bgFilter.type = 'lowpass';\n    bgFilter.frequency.value = 400;\n    bgGain.gain.value = 0.02;\n    backgroundNode.connect(bgFilter);\n    bgFilter.connect(bgGain);\n    bgGain.connect(masterGain);\n    backgroundNode.start();\n  } catch (e) {\n    console.warn('Web Audio API not available or could not be started:', e);\n    audioEnabled = false;\n    audioCtx = null;\n  }\n\n  // Helper to create short chime for success\n  function playSuccess() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc1 = audioCtx.createOscillator();\n      const osc2 = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      osc1.type = 'sine';\n      osc2.type = 'triangle';\n      osc1.frequency.setValueAtTime(880, now);\n      osc2.frequency.setValueAtTime(1320, now);\n      filter.type = 'lowpass';\n      filter.frequency.setValueAtTime(1200, now);\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(0.12, now + 0.02);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);\n      osc1.connect(filter);\n      osc2.connect(filter);\n      filter.connect(gain);\n      gain.connect(masterGain);\n      osc1.start(now);\n      osc2.start(now);\n      osc1.stop(now + 0.95);\n      osc2.stop(now + 0.95);\n    } catch (e) {\n      console.warn('Error playing success sound:', e);\n    }\n  }\n\n  // Helper to play buzzer for incorrect\n  function playBuzzer() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      osc.type = 'square';\n      osc.frequency.setValueAtTime(160, now);\n      filter.type = 'lowpass';\n      filter.frequency.setValueAtTime(700, now);\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(masterGain);\n      osc.start(now);\n      osc.stop(now + 0.6);\n    } catch (e) {\n      console.warn('Error playing buzzer:', e);\n    }\n  }\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    if (!audioCtx) {\n      audioEnabled = false;\n      return;\n    }\n    audioEnabled = !audioEnabled;\n    if (!audioEnabled) {\n      masterGain.gain.value = 0.0;\n    } else {\n      masterGain.gain.value = 0.6;\n    }\n  }\n\n  // Game state\n  let level = 1;\n  const maxLevels = 6;\n  let score = 0;\n  let roundSolved = false;\n  let timeSinceSolve = 0;\n\n  // Orbs (chargers) bank attached to left side. Each orb has a number 1-9.\n  const orbBank = [];\n  // Targets: devices placed across the right/top area with sockets.\n  const devices = [];\n\n  // Dragging state\n  let draggingOrb = null;\n  let dragOffset = { x: 0, y: 0 };\n\n  // Selection for keyboard control\n  let selectedOrbIndex = 0; // index in orbBank for keyboard pick\n  let selectedDeviceIndex = 0;\n  let carryOrb = null; // orb currently held by keyboard\n\n  // Random helpers\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Initialize round: create orbs and devices according to level\n  function initRound() {\n    roundSolved = false;\n    timeSinceSolve = 0;\n    orbBank.length = 0;\n    devices.length = 0;\n    // Difficulty scaling: as level increases, increase orb count and socket counts, target range\n    const orbCount = Math.min(9, 4 + level); // 5..9\n    const deviceCount = Math.min(4, 1 + Math.floor(level / 2)); // 1..3\n    const maxTarget = 6 + level * 2; // 8..18\n    // Generate orbs with numbers so that a solution exists\n    // Approach: create a target list first, then generate orbs including exact sums\n    const targets = [];\n    for (let i = 0; i < deviceCount; i++) {\n      const target = randInt(4, Math.min(12 + level, maxTarget));\n      const sockets = Math.min(3, 1 + Math.floor(level / 3)); // 1..3 sockets\n      targets.push({ target, sockets });\n    }\n    // Fill orb bank by starting with numbers that can sum to targets\n    const created = [];\n    // For each target, create numbers that sum to it using 1..3 addends\n    targets.forEach(t => {\n      let remain = t.target;\n      const parts = [];\n      for (let s = 0; s < t.sockets - 1; s++) {\n        const part = randInt(1, Math.max(1, Math.floor(remain / 2)));\n        parts.push(part);\n        remain -= part;\n      }\n      parts.push(remain);\n      parts.forEach(p => created.push(Math.max(1, Math.min(9, p))));\n    });\n    // Fill the rest with random numbers\n    while (created.length < orbCount) {\n      created.push(randInt(1, 9));\n    }\n    // Shuffle created\n    for (let i = created.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [created[i], created[j]] = [created[j], created[i]];\n    }\n    // Place orbs visually\n    const baseX = 20;\n    const baseY = 80;\n    const spacingY = 60;\n    created.forEach((num, i) => {\n      orbBank.push({\n        id: `o${i}_${Date.now()}`,\n        value: num,\n        x: baseX,\n        y: baseY + i * spacingY,\n        radius: 22,\n        placed: false\n      });\n    });\n    // Create devices positioned on right\n    const devBaseX = 400;\n    const devBaseY = 80;\n    const devSpacingX = 300 / Math.max(1, deviceCount);\n    for (let i = 0; i < deviceCount; i++) {\n      const d = {\n        id: 'd' + i,\n        x: devBaseX + i * devSpacingX,\n        y: devBaseY + i * 80,\n        width: 240,\n        height: 120,\n        target: targets[i].target,\n        sockets: targets[i].sockets,\n        socketOrbs: new Array(targets[i].sockets).fill(null),\n        lit: false,\n        wobble: 0\n      };\n      devices.push(d);\n    }\n    // Reset selection\n    selectedOrbIndex = 0;\n    selectedDeviceIndex = 0;\n    carryOrb = null;\n    updateAria('New round started. Level ' + level + '. Place orbs to match device targets.');\n  }\n\n  // Check devices for correct sums\n  function checkDevices() {\n    let allGood = true;\n    devices.forEach(dev => {\n      const sum = dev.socketOrbs.reduce((acc, o) => acc + (o ? o.value : 0), 0);\n      if (sum === dev.target) {\n        if (!dev.lit) {\n          dev.lit = true;\n          sparkAnimation(dev);\n          playSuccess();\n          updateAria(`Device target ${dev.target} solved!`);\n          score += 10;\n        }\n      } else {\n        if (dev.lit) {\n          // previously lit, now changed (shouldn't happen), but reset\n          dev.lit = false;\n        }\n        allGood = false;\n      }\n    });\n    if (allGood && devices.length > 0) {\n      roundSolved = true;\n      timeSinceSolve = 0;\n      updateAria('All devices powered! Level completed.');\n    }\n  }\n\n  // Spark animation state store\n  const sparks = [];\n\n  function sparkAnimation(dev) {\n    // spawn several sparks around device\n    for (let i = 0; i < 12; i++) {\n      sparks.push({\n        x: dev.x + dev.width * (Math.random() * 0.8 + 0.1),\n        y: dev.y + dev.height * (Math.random() * 0.8 + 0.1),\n        vx: Math.random() * 4 - 2,\n        vy: Math.random() * -3 - 1,\n        life: 60 + Math.random() * 30,\n        color: 'rgba(255, 255, 120, 1)'\n      });\n    }\n  }\n\n  // Draw helpers for cute characters and wacky electricity\n  function drawBackground() {\n    // Gentle gradient background\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#edf6ff');\n    g.addColorStop(1, '#eafbee');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Wacky clouds with smiley faces\n    drawCloud(120, 40, 60, 30, '#ffffff', '#bfefff', true);\n    drawCloud(540, 60, 70, 34, '#fff7f2', '#ffd9c8', true);\n\n    // Lab table\n    ctx.fillStyle = '#f3f0ff';\n    ctx.fillRect(0, 360, WIDTH, 120);\n    ctx.strokeStyle = '#d0c9ff';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(0, 360, WIDTH, 120);\n\n    // Title\n    ctx.fillStyle = '#0b3d91';\n    ctx.font = '20px \"Segoe UI\", Roboto, Arial';\n    ctx.fillText('Sparky\\'s Electric Math Lab \u2014 Level ' + level + '  Score: ' + score, 20, 28);\n  }\n\n  function drawCloud(cx, cy, rx, ry, color, edgeColor, smile) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.ellipse(-rx * 0.4, 0, rx * 0.6, ry, 0, 0, Math.PI * 2);\n    ctx.ellipse(rx * 0.2, -ry * 0.2, rx * 0.76, ry * 0.9, 0, 0, Math.PI * 2);\n    ctx.ellipse(rx * 0.7, ry * 0.1, rx * 0.5, ry * 0.8, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = edgeColor;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    if (smile) {\n      ctx.fillStyle = '#1a1a1a';\n      ctx.beginPath();\n      ctx.arc(0 - rx * 0.1, -2, 2.5, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(rx * 0.35, -4, 2.5, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.strokeStyle = '#1a1a1a';\n      ctx.lineWidth = 1.8;\n      ctx.beginPath();\n      ctx.arc(rx * 0.1, 4, 8, 0, Math.PI);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawOrb(o, highlight = false) {\n    // body\n    ctx.save();\n    ctx.translate(o.x, o.y);\n    const grd = ctx.createRadialGradient(-6, -6, 6, 6, 6, o.radius);\n    grd.addColorStop(0, highlight ? '#fff7b6' : '#fffef0');\n    grd.addColorStop(1, '#ffdd4a');\n    ctx.fillStyle = grd;\n    ctx.beginPath();\n    ctx.arc(0, 0, o.radius, 0, Math.PI * 2);\n    ctx.fill();\n    // glossy\n    ctx.fillStyle = 'rgba(255,255,255,0.5)';\n    ctx.beginPath();\n    ctx.ellipse(-6, -8, o.radius * 0.5, o.radius * 0.35, -0.5, 0, Math.PI * 2);\n    ctx.fill();\n    // number\n    ctx.fillStyle = '#2b2b2b';\n    ctx.font = 'bold 16px \"Segoe UI\", Roboto, Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(o.value, 0, 0);\n    ctx.restore();\n  }\n\n  function drawDevice(dev) {\n    ctx.save();\n    // body\n    ctx.fillStyle = dev.lit ? 'rgba(255,245,200,0.95)' : '#f6f8ff';\n    ctx.strokeStyle = '#b9c7ff';\n    ctx.lineWidth = 2;\n    const x = dev.x;\n    const y = dev.y;\n    ctx.beginPath();\n    roundRect(ctx, x, y, dev.width, dev.height, 10);\n    ctx.fill();\n    ctx.stroke();\n\n    // cute character: Sparky lightbulb face top-left of device area\n    drawSparky(x + 18, y + 18, dev.lit);\n\n    // Target text\n    ctx.fillStyle = '#0a2d5a';\n    ctx.font = '16px \"Segoe UI\", Roboto, Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Target: ' + dev.target, x + 60, y + 28);\n\n    // sockets\n    const spacing = (dev.width - 40) / Math.max(1, dev.sockets);\n    for (let i = 0; i < dev.sockets; i++) {\n      const sx = x + 20 + i * spacing + spacing / 2;\n      const sy = y + dev.height - 34;\n      ctx.beginPath();\n      ctx.fillStyle = '#eef3ff';\n      ctx.strokeStyle = '#a8bdfa';\n      ctx.lineWidth = 2;\n      ctx.arc(sx, sy, 20, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n      // value if present\n      const placed = dev.socketOrbs[i];\n      if (placed) {\n        // draw smaller orb inside\n        ctx.save();\n        ctx.translate(sx, sy);\n        ctx.beginPath();\n        ctx.fillStyle = '#fff7b6';\n        ctx.arc(0, 0, 16, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.strokeStyle = '#f1c542';\n        ctx.stroke();\n        ctx.fillStyle = '#17292b';\n        ctx.font = 'bold 14px \"Segoe UI\", Roboto, Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(placed.value, 0, 0);\n        ctx.restore();\n      } else {\n        // hint small plus sign\n        ctx.fillStyle = '#93a8ff';\n        ctx.fillRect(sx - 1, sy - 8, 2, 16);\n        ctx.fillRect(sx - 8, sy - 1, 16, 2);\n      }\n\n      // highlight selection\n      if (selectedDeviceIndex === devices.indexOf(dev) && selectedOrbIndex === -1) {\n        // show a subtle pulsing ring\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(20,120,200,0.25)';\n        ctx.lineWidth = 4;\n        ctx.arc(sx, sy, 26 + Math.sin(Date.now() / 250) * 2, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    }\n\n    // wires from left battery to this device - wacky zigzags\n    drawWire(180, y + dev.height / 2, x + 10, y + dev.height / 2, dev.lit);\n\n    ctx.restore();\n  }\n\n  function drawSparky(cx, cy, lit) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    // bulb body\n    ctx.beginPath();\n    ctx.fillStyle = lit ? '#fff8b8' : '#fff';\n    ctx.arc(0, 0, 16, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#d1caa3';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    // eyes\n    ctx.fillStyle = '#111';\n    ctx.beginPath();\n    ctx.arc(-6, -2, 2.5, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(2, -2, 2.5, 0, Math.PI * 2);\n    ctx.fill();\n    // smile\n    ctx.beginPath();\n    ctx.strokeStyle = '#373737';\n    ctx.lineWidth = 1;\n    ctx.arc(-1, 2, 6, 0.15 * Math.PI, 0.85 * Math.PI);\n    ctx.stroke();\n    // filament lines if lit\n    if (lit) {\n      ctx.strokeStyle = '#ffbb20';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(-4, -2);\n      ctx.lineTo(0, -6);\n      ctx.lineTo(4, -2);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawWire(x1, y1, x2, y2, energized) {\n    ctx.save();\n    ctx.strokeStyle = energized ? 'rgba(255,200,80,1)' : '#9aaee8';\n    ctx.lineWidth = 4;\n    ctx.beginPath();\n    // zigzag path\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const steps = 6;\n    ctx.moveTo(x1, y1);\n    for (let i = 1; i <= steps; i++) {\n      const t = i / steps;\n      const px = x1 + dx * t + Math.sin((t + Date.now() / 600) * Math.PI * 4) * 6;\n      const py = y1 + dy * t + Math.cos((t + Date.now() / 600) * Math.PI * 3) * 2;\n      ctx.lineTo(px, py);\n    }\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  // Rounded rectangle helper\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // UI draw (orb bank, buttons)\n  function drawUI() {\n    // Orb bank title\n    ctx.fillStyle = '#0a2d5a';\n    ctx.font = '16px \"Segoe UI\", Roboto, Arial';\n    ctx.fillText('Charge Orbs', 20, 60);\n\n    // Draw orbs not placed\n    orbBank.forEach((o, idx) => {\n      if (!o.placed && o !== draggingOrb && o !== carryOrb) {\n        const highlight = selectedOrbIndex === idx && carryOrb === null;\n        drawOrb(o, highlight);\n        // keyboard selection rectangle\n        if (highlight) {\n          ctx.save();\n          ctx.strokeStyle = 'rgba(20,120,200,0.2)';\n          ctx.lineWidth = 3;\n          ctx.beginPath();\n          ctx.arc(o.x, o.y, o.radius + 8, 0, Math.PI * 2);\n          ctx.stroke();\n          ctx.restore();\n        }\n      }\n    });\n\n    // Draw battery character near left center\n    drawBattery(180, 200);\n\n    // Draw devices\n    devices.forEach((d, idx) => {\n      drawDevice(d);\n    });\n\n    // Draw dragging orb above everything\n    if (draggingOrb) {\n      drawOrb(draggingOrb, true);\n    }\n    if (carryOrb) {\n      // draw carrier orb near top center for keyboard carry\n      const px = 360;\n      const py = 40;\n      ctx.save();\n      ctx.globalAlpha = 0.95;\n      ctx.translate(px, py);\n      drawOrb({ x: 0, y: 0, radius: 22, value: carryOrb.value }, true);\n      ctx.restore();\n    }\n\n    // Speaker icon\n    drawSpeakerIcon(WIDTH - 44, 12, audioEnabled);\n\n    // Instructions\n    ctx.fillStyle = '#184580';\n    ctx.font = '13px \"Segoe UI\", Roboto, Arial';\n    ctx.fillText('Instructions: Drag number orbs into device sockets to match the target sum.', 20, HEIGHT - 28);\n    ctx.fillText('Keyboard: 1-9 pick orb, Tab switches focus, Arrow keys select socket, Enter places, Delete removes, M mute.', 20, HEIGHT - 10);\n  }\n\n  function drawBattery(cx, cy) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    // battery body\n    ctx.fillStyle = '#f7f7fb';\n    ctx.strokeStyle = '#b6bde6';\n    ctx.lineWidth = 2;\n    roundRect(ctx, -60, -40, 120, 80, 8);\n    ctx.fill();\n    ctx.stroke();\n    // terminals\n    ctx.fillStyle = '#d3d7ff';\n    ctx.fillRect(64, -12, 16, 24);\n    // character face on battery\n    ctx.fillStyle = '#1a2b4a';\n    ctx.beginPath();\n    ctx.arc(-30, -8, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(-10, -8, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#1a2b4a';\n    ctx.beginPath();\n    ctx.arc(-20, 2, 10, 0.15 * Math.PI, 0.85 * Math.PI);\n    ctx.stroke();\n    // bolt logo\n    ctx.fillStyle = '#ffd84a';\n    ctx.beginPath();\n    ctx.moveTo(10, -20);\n    ctx.lineTo(2, 0);\n    ctx.lineTo(16, 0);\n    ctx.lineTo(4, 20);\n    ctx.lineTo(18, -2);\n    ctx.lineTo(6, -2);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawSpeakerIcon(x, y, on) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = on ? '#ffcf33' : '#cccccc';\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(0, 10);\n    ctx.lineTo(12, -6);\n    ctx.lineTo(12, 26);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    if (on) {\n      ctx.beginPath();\n      ctx.arc(22, 6, 10, -0.6, 0.6);\n      ctx.strokeStyle = 'rgba(255,150,0,0.9)';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(30, 6, 14, -0.6, 0.6);\n      ctx.strokeStyle = 'rgba(255,200,80,0.5)';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    } else {\n      // draw small cross to indicate off\n      ctx.strokeStyle = '#7a7a7a';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(22, -6);\n      ctx.lineTo(34, 18);\n      ctx.moveTo(34, -6);\n      ctx.lineTo(22, 18);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Mouse and touch handling\n  function getMousePos(e) {\n    const rect = canvas.getBoundingClientRect();\n    const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX);\n    const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY);\n    return {\n      x: (clientX - rect.left) * (canvas.width / rect.width),\n      y: (clientY - rect.top) * (canvas.height / rect.height)\n    };\n  }\n\n  function onPointerDown(e) {\n    e.preventDefault();\n    const pos = getMousePos(e);\n    // first check orbs\n    for (let i = 0; i < orbBank.length; i++) {\n      const o = orbBank[i];\n      if (!o.placed) {\n        const dx = pos.x - o.x;\n        const dy = pos.y - o.y;\n        if (dx * dx + dy * dy <= o.radius * o.radius) {\n          draggingOrb = o;\n          dragOffset.x = pos.x - o.x;\n          dragOffset.y = pos.y - o.y;\n          selectedOrbIndex = i;\n          selectedDeviceIndex = -1;\n          carryOrb = null;\n          return;\n        }\n      }\n    }\n    // if clicking on a device socket, maybe pick up orb from socket\n    for (let di = 0; di < devices.length; di++) {\n      const d = devices[di];\n      const spacing = (d.width - 40) / Math.max(1, d.sockets);\n      for (let si = 0; si < d.sockets; si++) {\n        const sx = d.x + 20 + si * spacing + spacing / 2;\n        const sy = d.y + d.height - 34;\n        const dx = pos.x - sx;\n        const dy = pos.y - sy;\n        if (dx * dx + dy * dy <= 20 * 20) {\n          // pick up if present\n          if (d.socketOrbs[si]) {\n            const orb = d.socketOrbs[si];\n            d.socketOrbs[si] = null;\n            orb.placed = false;\n            // put orb at pointer and start dragging\n            orb.x = pos.x;\n            orb.y = pos.y;\n            draggingOrb = orb;\n            dragOffset.x = 0;\n            dragOffset.y = 0;\n            selectedDeviceIndex = di;\n            selectedOrbIndex = orbBank.indexOf(orb);\n            updateAria('Picked up orb ' + orb.value + ' from device socket.');\n            return;\n          } else {\n            // empty socket clicked -> highlight for keyboard selection\n            selectedDeviceIndex = di;\n            selectedOrbIndex = -1;\n            carryOrb = null;\n            updateAria('Selected device ' + (di + 1) + '. Use number keys to pick up an orb.');\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  function onPointerMove(e) {\n    if (!draggingOrb) return;\n    e.preventDefault();\n    const pos = getMousePos(e);\n    draggingOrb.x = pos.x - dragOffset.x;\n    draggingOrb.y = pos.y - dragOffset.y;\n  }\n\n  function onPointerUp(e) {\n    if (!draggingOrb) return;\n    e.preventDefault();\n    const pos = getMousePos(e);\n    // check drop into a socket\n    let placed = false;\n    for (let di = 0; di < devices.length; di++) {\n      const d = devices[di];\n      const spacing = (d.width - 40) / Math.max(1, d.sockets);\n      for (let si = 0; si < d.sockets; si++) {\n        const sx = d.x + 20 + si * spacing + spacing / 2;\n        const sy = d.y + d.height - 34;\n        const dx = pos.x - sx;\n        const dy = pos.y - sy;\n        if (dx * dx + dy * dy <= 22 * 22) {\n          // If socket empty, place\n          if (!d.socketOrbs[si]) {\n            d.socketOrbs[si] = draggingOrb;\n            draggingOrb.placed = true;\n            // snap orb into socket visually\n            draggingOrb.x = sx;\n            draggingOrb.y = sy;\n            placed = true;\n            updateAria('Placed orb ' + draggingOrb.value + ' into device target ' + d.target + '.');\n            // check devices after small hump\n            break;\n          } else {\n            // occupied -> bounce back\n            playBuzzer();\n          }\n        }\n      }\n      if (placed) break;\n    }\n    if (!placed) {\n      // if dropped outside, return to bank positions\n      // find bank index and return to its natural position\n      const idx = orbBank.indexOf(draggingOrb);\n      if (idx >= 0) {\n        draggingOrb.x = 20;\n        draggingOrb.y = 80 + idx * 60;\n      }\n    } else {\n      playSuccess();\n    }\n    draggingOrb = null;\n    checkDevices();\n  }\n\n  // Keyboard controls\n  // Number keys 1-9 pick corresponding orb from bank if exists\n  // Arrow keys navigate device sockets, Enter places carry orb into selected socket\n  // Delete removes orb from selected socket back to bank\n  let deviceFocusIndex = 0; // which device is focused for keyboard placement\n\n  function onKeyDown(e) {\n    if (e.key === 'm' || e.key === 'M') {\n      toggleAudio();\n      updateAria('Audio ' + (audioEnabled ? 'enabled' : 'muted') + '.');\n      e.preventDefault();\n      return;\n    }\n    // Number keys\n    if (/^[1-9]$/.test(e.key)) {\n      const numKey = parseInt(e.key, 10);\n      // find an orb in bank with that value not placed\n      let foundIndex = -1;\n      for (let i = 0; i < orbBank.length; i++) {\n        const o = orbBank[i];\n        if (!o.placed && o.value === numKey) {\n          foundIndex = i;\n          break;\n        }\n      }\n      if (foundIndex >= 0) {\n        carryOrb = { ...orbBank[foundIndex] }; // shallow copy with same value\n        // Mark original as ghost temporarily so it's not selectable\n        // Actually we keep original; but keyboard carry references value only, placing will remove actual orb.\n        selectedOrbIndex = foundIndex;\n        selectedDeviceIndex = deviceFocusIndex;\n        updateAria('Picked up orb ' + carryOrb.value + ' with keyboard. Select a device socket and press Enter to place.');\n      } else {\n        updateAria('No available orb with value ' + numKey + '.');\n        playBuzzer();\n      }\n      e.preventDefault();\n      return;\n    }\n    // Tab to switch between orb bank and devices (prevent default tabbing)\n    if (e.key === 'Tab') {\n      // cycle focus between orb list and devices\n      if (selectedOrbIndex === -1) {\n        // move to orb bank selection\n        selectedOrbIndex = 0;\n        selectedDeviceIndex = -1;\n      } else {\n        selectedDeviceIndex = 0;\n        selectedOrbIndex = -1;\n      }\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'ArrowRight') {\n      // move deviceFocusIndex right\n      deviceFocusIndex = (deviceFocusIndex + 1) % devices.length;\n      selectedDeviceIndex = deviceFocusIndex;\n      selectedOrbIndex = -1;\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'ArrowLeft') {\n      deviceFocusIndex = (deviceFocusIndex - 1 + devices.length) % devices.length;\n      selectedDeviceIndex = deviceFocusIndex;\n      selectedOrbIndex = -1;\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'ArrowUp') {\n      // cycle orb bank selection up\n      selectedOrbIndex = (selectedOrbIndex - 1 + orbBank.length) % orbBank.length;\n      selectedDeviceIndex = -1;\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'ArrowDown') {\n      selectedOrbIndex = (selectedOrbIndex + 1) % orbBank.length;\n      selectedDeviceIndex = -1;\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'Enter') {\n      // place carry orb into focused device's first available socket\n      if (carryOrb && selectedDeviceIndex >= 0) {\n        const dev = devices[selectedDeviceIndex];\n        let placed = false;\n        for (let si = 0; si < dev.sockets; si++) {\n          if (!dev.socketOrbs[si]) {\n            // find original orb in bank with matching value and not placed\n            const origIdx = orbBank.findIndex(o => !o.placed && o.value === carryOrb.value);\n            if (origIdx >= 0) {\n              const orig = orbBank[origIdx];\n              orig.placed = true;\n              dev.socketOrbs[si] = orig;\n              // snap to socket\n              const spacing = (dev.width - 40) / Math.max(1, dev.sockets);\n              const sx = dev.x + 20 + si * spacing + spacing / 2;\n              const sy = dev.y + dev.height - 34;\n              orig.x = sx;\n              orig.y = sy;\n              placed = true;\n              updateAria('Placed orb ' + orig.value + ' into device target ' + dev.target + ' via keyboard.');\n              playSuccess();\n            } else {\n              // should not happen - nothing found to match carry\n              playBuzzer();\n            }\n            break;\n          }\n        }\n        if (!placed) {\n          updateAria('No available socket on selected device.');\n          playBuzzer();\n        }\n        carryOrb = null;\n        checkDevices();\n      } else if (selectedOrbIndex >= 0 && selectedDeviceIndex >= 0) {\n        // pick orb from bank and place into device\n        const orig = orbBank[selectedOrbIndex];\n        if (!orig.placed) {\n          const dev = devices[selectedDeviceIndex];\n          let placed = false;\n          for (let si = 0; si < dev.sockets; si++) {\n            if (!dev.socketOrbs[si]) {\n              dev.socketOrbs[si] = orig;\n              orig.placed = true;\n              const spacing = (dev.width - 40) / Math.max(1, dev.sockets);\n              const sx = dev.x + 20 + si * spacing + spacing / 2;\n              const sy = dev.y + dev.height - 34;\n              orig.x = sx;\n              orig.y = sy;\n              placed = true;\n              updateAria('Placed orb ' + orig.value + ' into device target ' + dev.target + ' via keyboard.');\n              playSuccess();\n              break;\n            }\n          }\n          if (!placed) {\n            playBuzzer();\n            updateAria('No available socket on selected device.');\n          }\n          checkDevices();\n        }\n      }\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'Delete' || e.key === 'Backspace') {\n      // remove orb from selected device and return to bank\n      if (selectedDeviceIndex >= 0) {\n        const dev = devices[selectedDeviceIndex];\n        // remove last non-null orb found\n        for (let si = dev.sockets - 1; si >= 0; si--) {\n          if (dev.socketOrbs[si]) {\n            const orb = dev.socketOrbs[si];\n            dev.socketOrbs[si] = null;\n            orb.placed = false;\n            // send it back to its bank position\n            const idx = orbBank.indexOf(orb);\n            if (idx >= 0) {\n              orb.x = 20;\n              orb.y = 80 + idx * 60;\n            }\n            updateAria('Removed orb ' + orb.value + ' from device.');\n            playBuzzer();\n            checkDevices();\n            break;\n          }\n        }\n      }\n      e.preventDefault();\n      return;\n    }\n  }\n\n  // Aria update for screen readers\n  function updateAria(text) {\n    ariaStatus.textContent = text;\n  }\n\n  // Game loop\n  let lastTS = 0;\n  function loop(ts) {\n    const dt = Math.min(50, ts - lastTS);\n    lastTS = ts;\n    update(dt);\n    render();\n    requestAnimationFrame(loop);\n  }\n\n  function update(dt) {\n    // update sparks\n    for (let i = sparks.length - 1; i >= 0; i--) {\n      const s = sparks[i];\n      s.x += s.vx;\n      s.y += s.vy;\n      s.vy += 0.12;\n      s.life -= 1;\n      if (s.life <= 0) sparks.splice(i, 1);\n    }\n    // device wobble\n    devices.forEach(d => {\n      if (d.lit) {\n        d.wobble = Math.min(8, d.wobble + 0.4);\n      } else {\n        d.wobble = Math.max(0, d.wobble - 0.6);\n      }\n    });\n\n    // After round solved, proceed to next level after small delay\n    if (roundSolved) {\n      timeSinceSolve += dt;\n      if (timeSinceSolve > 1400) {\n        level++;\n        if (level > maxLevels) {\n          // game finished - reset level and increase challenge\n          updateAria('Congratulations! You completed all levels. Starting over.');\n          level = 1;\n          score = 0;\n        } else {\n          updateAria('Advancing to level ' + level + '.');\n        }\n        initRound();\n      }\n    }\n\n    // Slight bobbing animation for orbs in bank\n    orbBank.forEach((o, idx) => {\n      if (!o.placed && o !== draggingOrb) {\n        o.x = 20 + Math.sin(Date.now() / 500 + idx) * 2;\n        // ensure vertical anchors remain consistent\n        o.y = 80 + idx * 60;\n      }\n    });\n  }\n\n  function render() {\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawBackground();\n    drawUI();\n\n    // sparks on top of everything\n    sparks.forEach(s => {\n      ctx.save();\n      ctx.fillStyle = s.color;\n      ctx.globalAlpha = Math.max(0, Math.min(1, s.life / 60));\n      ctx.beginPath();\n      ctx.arc(s.x, s.y, 3 + Math.random() * 3, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    });\n  }\n\n  // Placement helper to find bank orb by id\n  function findOrbById(id) {\n    return orbBank.find(o => o.id === id);\n  }\n\n  // Event listeners\n  canvas.addEventListener('mousedown', onPointerDown);\n  canvas.addEventListener('mousemove', onPointerMove);\n  document.addEventListener('mouseup', onPointerUp);\n  // touch support\n  canvas.addEventListener('touchstart', onPointerDown, { passive: false });\n  canvas.addEventListener('touchmove', onPointerMove, { passive: false });\n  document.addEventListener('touchend', onPointerUp);\n\n  // keyboard\n  canvas.addEventListener('keydown', onKeyDown);\n\n  // clicking speaker icon (determine click coords)\n  canvas.addEventListener('click', function(e) {\n    const pos = getMousePos(e);\n    // speaker icon at WIDTH - 44, 12 and approx size 44x36\n    if (pos.x >= WIDTH - 60 && pos.x <= WIDTH && pos.y >= 0 && pos.y <= 44) {\n      toggleAudio();\n      updateAria('Audio ' + (audioEnabled ? 'enabled' : 'muted') + '.');\n    }\n  });\n\n  // Initialize and start\n  initRound();\n  requestAnimationFrame(loop);\n\n  // Safe API: Provide a small public interface via window for debugging (non-essential)\n  try {\n    window.electricMathGame = {\n      reset: function() {\n        level = 1;\n        score = 0;\n        initRound();\n      },\n      toggleAudio: toggleAudio\n    };\n  } catch (e) {\n    // ignore if cannot attach to window\n  }\n\n  // Error handling for audio resume on user gesture - some browsers require resume\n  function resumeAudioOnInteraction() {\n    if (audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().then(() => {\n        audioEnabled = true;\n        masterGain.gain.value = 0.6;\n      }).catch(err => {\n        console.warn('Could not resume audio context:', err);\n        audioEnabled = false;\n      });\n    }\n  }\n  // Add one-time listeners to attempt resume on first user gesture\n  const resumeHandler = function() {\n    resumeAudioOnInteraction();\n    window.removeEventListener('mousedown', resumeHandler);\n    window.removeEventListener('touchstart', resumeHandler);\n    window.removeEventListener('keydown', resumeHandler);\n  };\n  window.addEventListener('mousedown', resumeHandler);\n  window.addEventListener('touchstart', resumeHandler);\n  window.addEventListener('keydown', resumeHandler);\n})();\n---\n",
  "improve_response_tokens": 22186,
  "formatted_code": true,
  "formatting_response_tokens": 23489,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}