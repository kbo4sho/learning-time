{
  "generated_date": "2025-08-18",
  "generated_timestamp": "2025-08-18T00:24:23.280501",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9285,
  "game_filename": "2025-08-18.js",
  "game_size_bytes": 25548,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n\"use strict\";\n\n// Electricity Math Game for ages 7-9\n// Renders into existing element with id \"game-of-the-day-stage\"\n// All drawing via canvas, sound via Web Audio API oscillators.\n// Keyboard and mouse controls implemented. Accessible instructions and visual audio cues included.\n\n// Immediately executed to initialize\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const CANVAS_ID = \"game-of-the-day-canvas\";\n\n  // Colors / theme\n  const COLORS = {\n    bg: \"#e6f7fb\", // calming pale blue\n    panel: \"#f7fbfd\",\n    wire: \"#7cc7c7\",\n    bulbOff: \"#f4e7b8\",\n    bulbOn: \"#ffd86b\",\n    robot: \"#b3e0ff\",\n    acc: \"#ffb7b7\",\n    text: \"#10323a\",\n    soft: \"#d9f0ef\",\n    speakerOn: \"#2e8b57\",\n    speakerOff: \"#9aa5a6\",\n    spark: \"#fff27f\"\n  };\n\n  // Canvas setup\n  const stage = document.getElementById(\"game-of-the-day-stage\");\n  if (!stage) {\n    console.error(\"No element with id 'game-of-the-day-stage' found.\");\n    return;\n  }\n  // Clear any children and create canvas\n  stage.innerHTML = \"\";\n  const canvas = document.createElement(\"canvas\");\n  canvas.id = CANVAS_ID;\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // to receive keyboard focus\n  canvas.style.outline = \"none\";\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n\n  // Audio manager using Web Audio API\n  const audioManager = {\n    ctx: null,\n    masterGain: null,\n    backgroundOsc: null,\n    enabled: false,\n    creating: false,\n    // Try to initialize audio context on first user gesture\n    async init() {\n      if (this.creating || this.ctx) return;\n      this.creating = true;\n      try {\n        const AudioCtx = window.AudioContext || window.webkitAudioContext;\n        if (!AudioCtx) throw new Error(\"Web Audio API not supported\");\n        this.ctx = new AudioCtx();\n        this.masterGain = this.ctx.createGain();\n        this.masterGain.gain.value = 0.55;\n        this.masterGain.connect(this.ctx.destination);\n        // gentle background hum\n        this.backgroundOsc = this.ctx.createOscillator();\n        const bgGain = this.ctx.createGain();\n        this.backgroundOsc.type = \"sine\";\n        this.backgroundOsc.frequency.value = 60; // 60 Hz hum-ish subtle\n        bgGain.gain.value = 0.01;\n        this.backgroundOsc.connect(bgGain);\n        bgGain.connect(this.masterGain);\n        this.backgroundOsc.start();\n        this.enabled = true;\n        this.creating = false;\n      } catch (err) {\n        console.warn(\"Audio initialization failed:\", err);\n        this.ctx = null;\n        this.enabled = false;\n        this.creating = false;\n      }\n    },\n    // Play a tone with simple envelope\n    playTone({ freq = 440, type = \"sine\", duration = 0.25, volume = 0.12, detune = 0 } = {}) {\n      if (!this.enabled || !this.ctx) return;\n      try {\n        const osc = this.ctx.createOscillator();\n        const gain = this.ctx.createGain();\n        osc.type = type;\n        osc.frequency.value = freq;\n        osc.detune.value = detune;\n        gain.gain.value = 0;\n        osc.connect(gain);\n        gain.connect(this.masterGain);\n        const now = this.ctx.currentTime;\n        gain.gain.cancelScheduledValues(now);\n        gain.gain.setValueAtTime(0, now);\n        gain.gain.linearRampToValueAtTime(volume, now + 0.01);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n        osc.start(now);\n        osc.stop(now + duration + 0.02);\n      } catch (err) {\n        console.warn(\"Error playing tone:\", err);\n      }\n    },\n    // Simple chime for correct\n    playCorrect() {\n      if (!this.enabled) return;\n      this.playTone({ freq: 880, type: \"sine\", duration: 0.25, volume: 0.12 });\n      // quick harmonic\n      setTimeout(() => this.playTone({ freq: 1320, type: \"triangle\", duration: 0.18, volume: 0.08 }), 80);\n    },\n    // Buzzy for incorrect\n    playIncorrect() {\n      if (!this.enabled) return;\n      this.playTone({ freq: 200, type: \"sawtooth\", duration: 0.18, volume: 0.14 });\n      setTimeout(() => this.playTone({ freq: 120, type: \"sawtooth\", duration: 0.14, volume: 0.10 }), 80);\n    },\n    // Shoot sound\n    playShoot() {\n      if (!this.enabled) return;\n      this.playTone({ freq: 520, type: \"square\", duration: 0.12, volume: 0.09 });\n    },\n    toggle() {\n      // If audio not yet created, attempt to init\n      if (!this.ctx) {\n        this.init();\n        return;\n      }\n      this.enabled = !this.enabled;\n      if (!this.enabled) {\n        // mute\n        if (this.masterGain) this.masterGain.gain.value = 0;\n      } else {\n        if (this.masterGain) this.masterGain.gain.value = 0.55;\n      }\n    }\n  };\n\n  // Utility helpers\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // Game state\n  const state = {\n    bulbs: [], // top bulbs with targets\n    orbs: [], // active fired orbs\n    spareOrbs: [], // three available numbers visible at generator\n    score: 0,\n    lives: 3,\n    round: 1,\n    message: \"Welcome! Make each bulb reach its number by zapping it with number-orbs.\",\n    lastActionTime: Date.now(),\n    audioAvailable: false,\n    aimAngle: -Math.PI / 2, // upward\n    power: 10, // speed multiplier\n    mousePos: { x: WIDTH / 2, y: HEIGHT / 2 },\n    isMouseAiming: false,\n    focused: true,\n    paused: false,\n    speakerVisible: true\n  };\n\n  // Initialize bulbs for a round\n  function setupRound(round = 1) {\n    state.bulbs = [];\n    state.orbs = [];\n    state.spareOrbs = [];\n    state.message = \"Round \" + round + \": Light all bulbs by matching sums!\";\n    state.round = round;\n    state.lives = Math.max(1, 4 - Math.floor((round - 1) / 2));\n    state.score = 0;\n    // create 3 bulbs with targets increasing with round\n    const base = 6 + round;\n    for (let i = 0; i < 3; i++) {\n      const target = randInt(base + i, base + 6 + i);\n      state.bulbs.push({\n        x: 140 + i * 220,\n        y: 110,\n        radius: 42,\n        target,\n        current: 0,\n        lit: false,\n        charOffset: randInt(-8, 8)\n      });\n    }\n    // create 3 spare orbs (numbers) for generator\n    refillSpareOrbs();\n  }\n\n  function refillSpareOrbs() {\n    state.spareOrbs = [];\n    for (let i = 0; i < 3; i++) {\n      // choose numbers that are helpful for targets\n      const t = state.bulbs[randInt(0, state.bulbs.length - 1)].target;\n      const suggestion = clamp(randInt(1, Math.max(3, Math.floor(t / 2))), 1, 9);\n      state.spareOrbs.push({\n        value: suggestion,\n        x: WIDTH / 2 - 60 + i * 60,\n        y: HEIGHT - 68,\n        radius: 16,\n        color: COLORS.accent || \"#ffb7b7\"\n      });\n    }\n  }\n\n  // Orb object created when shooting\n  function createOrb(value, x, y, vx, vy) {\n    return {\n      value,\n      x,\n      y,\n      vx,\n      vy,\n      radius: 14,\n      alive: true,\n      trail: []\n    };\n  }\n\n  // Input handling\n  let lastShotTime = 0;\n  const SHOT_COOLDOWN = 250; // ms\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    state.mousePos.x = mx;\n    state.mousePos.y = my;\n    state.isMouseAiming = true;\n    // compute aimAngle from generator center\n    const gx = WIDTH / 2;\n    const gy = HEIGHT - 40;\n    const dx = mx - gx;\n    const dy = my - gy;\n    state.aimAngle = Math.atan2(dy, dx);\n  });\n\n  canvas.addEventListener(\"mouseleave\", () => {\n    state.isMouseAiming = false;\n  });\n\n  canvas.addEventListener(\"click\", async (e) => {\n    // Click acts as shoot + toggles audio if clicking speaker area\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    // If click on speaker icon area\n    if (mx >= WIDTH - 60 && mx <= WIDTH - 20 && my >= 20 && my <= 60) {\n      // try init audio on click\n      await audioManager.init();\n      audioManager.toggle();\n      state.audioAvailable = audioManager.enabled;\n      state.message = audioManager.enabled ? \"Audio ON\" : \"Audio OFF\";\n      return;\n    }\n    // Ensure AudioContext created on first user gesture if possible\n    if (!audioManager.ctx) {\n      await audioManager.init();\n      state.audioAvailable = audioManager.enabled;\n    }\n    shootFromGenerator();\n    canvas.focus();\n  });\n\n  // Keyboard controls\n  const keyState = {};\n  window.addEventListener(\"keydown\", async (e) => {\n    keyState[e.code] = true;\n    // Try to init audio when a key is pressed first\n    if (!audioManager.ctx) {\n      await audioManager.init();\n      state.audioAvailable = audioManager.enabled;\n    }\n    if (e.code === \"KeyM\") {\n      audioManager.toggle();\n      state.audioAvailable = audioManager.enabled;\n      state.message = audioManager.enabled ? \"Audio ON\" : \"Audio OFF\";\n      e.preventDefault();\n    } else if (e.code === \"Space\") {\n      shootFromGenerator();\n      e.preventDefault();\n    } else if (e.code === \"KeyR\") {\n      setupRound(1);\n      e.preventDefault();\n    } else if (e.code === \"KeyP\") {\n      state.paused = !state.paused;\n      state.message = state.paused ? \"Paused\" : \"Resumed\";\n      e.preventDefault();\n    }\n  });\n\n  window.addEventListener(\"keyup\", (e) => {\n    keyState[e.code] = false;\n  });\n\n  // Shoot logic: fires the left-most spare orb value\n  function shootFromGenerator() {\n    if (state.paused) return;\n    const now = Date.now();\n    if (now - lastShotTime < SHOT_COOLDOWN) return;\n    lastShotTime = now;\n    if (state.spareOrbs.length === 0) {\n      state.message = \"No orbs left! Refilling...\";\n      refillSpareOrbs();\n      return;\n    }\n    // pick first spare orb\n    const orbInfo = state.spareOrbs.shift();\n    const gx = WIDTH / 2;\n    const gy = HEIGHT - 40;\n    const angle = state.aimAngle;\n    const speed = 3 + state.power * 0.6;\n    const vx = Math.cos(angle) * speed;\n    const vy = Math.sin(angle) * speed;\n    const orb = createOrb(orbInfo.value, gx + Math.cos(angle) * 28, gy + Math.sin(angle) * 28, vx, vy);\n    state.orbs.push(orb);\n    audioManager.playShoot();\n    state.message = `Zapped a ${orb.value}! Aim for a bulb to reach its number.`;\n  }\n\n  // Update loop: physics and collisions\n  function update(dt) {\n    if (state.paused) return;\n    // Keyboard aim adjustments\n    if (keyState[\"ArrowLeft\"]) {\n      state.aimAngle -= 0.03;\n    }\n    if (keyState[\"ArrowRight\"]) {\n      state.aimAngle += 0.03;\n    }\n    if (keyState[\"ArrowUp\"]) {\n      state.power = clamp(state.power + 0.06, 6, 16);\n    }\n    if (keyState[\"ArrowDown\"]) {\n      state.power = clamp(state.power - 0.06, 6, 16);\n    }\n\n    // Update orbs\n    for (const orb of state.orbs) {\n      if (!orb.alive) continue;\n      orb.vy += 0.06; // subtle gravity to simulate wire sag\n      orb.x += orb.vx;\n      orb.y += orb.vy;\n      // record trail\n      orb.trail.push({ x: orb.x, y: orb.y });\n      if (orb.trail.length > 10) orb.trail.shift();\n      // boundary check: if off screen, remove\n      if (orb.x < -30 || orb.x > WIDTH + 30 || orb.y > HEIGHT + 40) {\n        orb.alive = false;\n      }\n      // check collisions with bulbs\n      for (const bulb of state.bulbs) {\n        if (bulb.lit) continue;\n        const dx = orb.x - bulb.x;\n        const dy = orb.y - bulb.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist < orb.radius + bulb.radius - 6) {\n          // deposit value\n          bulb.current += orb.value;\n          orb.alive = false;\n          // sound and check\n          if (bulb.current === bulb.target) {\n            bulb.lit = true;\n            state.score += bulb.target;\n            audioManager.playCorrect();\n            state.message = `Great! Bulb reached ${bulb.target}!`;\n          } else if (bulb.current > bulb.target) {\n            // Overload\n            state.lives -= 1;\n            audioManager.playIncorrect();\n            state.message = `Overload! Bulb needed ${bulb.target} but got ${bulb.current}. It reset. Lives: ${state.lives}`;\n            bulb.current = 0;\n          } else {\n            // Partial\n            audioManager.playShoot();\n            state.message = `Bulb got ${bulb.current} / ${bulb.target}. Keep going!`;\n          }\n          // spawn tiny sparks (visual) by saving a transient property\n          bulb.sparkTimer = 16;\n          break;\n        }\n      }\n    }\n\n    // clean up dead orbs\n    state.orbs = state.orbs.filter((o) => o.alive);\n\n    // Check round completion\n    if (state.bulbs.every((b) => b.lit)) {\n      state.round += 1;\n      state.message = `Round complete! Starting round ${state.round}...`;\n      // small delay before next round\n      setTimeout(() => {\n        setupRound(state.round);\n      }, 900);\n    }\n\n    // Check game over\n    if (state.lives <= 0) {\n      state.paused = true;\n      state.message = \"Game over! Press R to restart.\";\n    }\n  }\n\n  // Drawing functions\n  function drawBackground() {\n    ctx.fillStyle = COLORS.bg;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // gentle circuit-grid pattern\n    ctx.strokeStyle = COLORS.soft;\n    ctx.lineWidth = 1;\n    for (let x = 0; x < WIDTH; x += 24) {\n      ctx.beginPath();\n      ctx.moveTo(x + (Math.sin(perfNow() / 800 + x * 0.02) * 4), 0);\n      ctx.lineTo(x + (Math.sin(perfNow() / 800 + x * 0.02) * 4), HEIGHT);\n      ctx.stroke();\n    }\n    for (let y = 0; y < HEIGHT; y += 24) {\n      ctx.beginPath();\n      ctx.moveTo(0, y + (Math.cos(perfNow() / 800 + y * 0.02) * 4));\n      ctx.lineTo(WIDTH, y + (Math.cos(perfNow() / 800 + y * 0.02) * 4));\n      ctx.stroke();\n    }\n  }\n\n  function perfNow() {\n    return performance.now();\n  }\n\n  function drawBulbs() {\n    for (const bulb of state.bulbs) {\n      // draw wire stub\n      ctx.beginPath();\n      ctx.strokeStyle = COLORS.wire;\n      ctx.lineWidth = 6;\n      ctx.moveTo(bulb.x, bulb.y + bulb.radius + 8);\n      ctx.lineTo(bulb.x, bulb.y + bulb.radius + 40);\n      ctx.stroke();\n\n      // bulb glass\n      ctx.beginPath();\n      ctx.fillStyle = bulb.lit ? COLORS.bulbOn : COLORS.bulbOff;\n      ctx.strokeStyle = \"#bda65b\";\n      ctx.lineWidth = 3;\n      ctx.ellipse(bulb.x, bulb.y, bulb.radius, bulb.radius * 1.1, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // filament indicator (shows partial charge)\n      ctx.beginPath();\n      const ratio = clamp(bulb.current / bulb.target, 0, 1);\n      ctx.strokeStyle = \"#a55b00\";\n      ctx.lineWidth = 3;\n      ctx.moveTo(bulb.x - 12, bulb.y);\n      ctx.lineTo(bulb.x + 12, bulb.y - 6 * ratio);\n      ctx.stroke();\n\n      // target number and current\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"bold 16px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(`Need: ${bulb.target}`, bulb.x, bulb.y - bulb.radius - 8);\n      ctx.font = \"bold 18px sans-serif\";\n      ctx.fillText(`${bulb.current}`, bulb.x, bulb.y + 6);\n\n      // playful character on bulb base (Wirefox)\n      drawWireFox(bulb.x - 24, bulb.y + bulb.radius + 22, bulb.charOffset, bulb.lit);\n\n      // spark effects\n      if (bulb.sparkTimer && bulb.sparkTimer > 0) {\n        drawSparks(bulb.x, bulb.y + 6, bulb.sparkTimer);\n        bulb.sparkTimer -= 1;\n      }\n    }\n  }\n\n  function drawWireFox(x, y, offset, happy) {\n    ctx.save();\n    ctx.translate(x, y);\n    // body\n    ctx.fillStyle = \"#ffc8a2\";\n    ctx.beginPath();\n    ctx.ellipse(0, 6 + offset * 0.1, 18, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // head\n    ctx.beginPath();\n    ctx.fillStyle = \"#ffd9b1\";\n    ctx.arc(0, -6 + offset * 0.1, 12, 0, Math.PI * 2);\n    ctx.fill();\n    // eyes\n    ctx.fillStyle = happy ? \"#003\" : \"#222\";\n    ctx.beginPath();\n    ctx.arc(-4, -8, 2, 0, Math.PI * 2);\n    ctx.arc(4, -8, 2, 0, Math.PI * 2);\n    ctx.fill();\n    // little wire tail\n    ctx.strokeStyle = \"#d18b4a\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(14, 8);\n    ctx.lineTo(22, 10);\n    ctx.lineTo(26, 6);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function drawSparks(cx, cy, t) {\n    const count = Math.floor(6 + Math.random() * 6);\n    for (let i = 0; i < count; i++) {\n      const a = Math.random() * Math.PI * 2;\n      const r = Math.random() * (t * 1.8);\n      const x = cx + Math.cos(a) * r;\n      const y = cy + Math.sin(a) * r;\n      ctx.fillStyle = COLORS.spark;\n      ctx.beginPath();\n      ctx.arc(x, y, Math.max(1, 3 - t / 8), 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function drawGenerator() {\n    const gx = WIDTH / 2;\n    const gy = HEIGHT - 40;\n    // base panel\n    ctx.fillStyle = COLORS.panel;\n    ctx.strokeStyle = \"#c9e8ea\";\n    roundRect(ctx, gx - 140, gy - 30, 280, 64, 10);\n    ctx.fill();\n    ctx.stroke();\n\n    // friendly robot \"Volty\" left side\n    drawVolty(gx - 160, gy - 8);\n\n    // center emitter\n    ctx.beginPath();\n    ctx.fillStyle = \"#fff\";\n    ctx.strokeStyle = \"#bcdad9\";\n    ctx.lineWidth = 3;\n    ctx.arc(gx, gy, 28, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // show current aim line from emitter\n    ctx.beginPath();\n    ctx.strokeStyle = COLORS.wire;\n    ctx.lineWidth = 4;\n    ctx.moveTo(gx, gy);\n    const aimX = gx + Math.cos(state.aimAngle) * 90;\n    const aimY = gy + Math.sin(state.aimAngle) * 90;\n    ctx.lineTo(aimX, aimY);\n    ctx.stroke();\n\n    // spare orbs\n    for (let i = 0; i < state.spareOrbs.length; i++) {\n      const sp = state.spareOrbs[i];\n      // small hover bob\n      const bob = Math.sin(perfNow() / 300 + i) * 4;\n      ctx.beginPath();\n      ctx.fillStyle = \"#ffe9e9\";\n      ctx.arc(sp.x, sp.y + bob, sp.radius + 2, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.fillStyle = \"#ff8b8b\";\n      ctx.arc(sp.x, sp.y + bob, sp.radius, 0, Math.PI * 2);\n      ctx.fill();\n      // number\n      ctx.fillStyle = \"#fff\";\n      ctx.font = \"bold 14px monospace\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(sp.value, sp.x, sp.y + 5 + bob);\n    }\n\n    // power meter\n    ctx.fillStyle = \"#cfeeea\";\n    ctx.fillRect(gx + 90, gy - 22, 36, 44);\n    ctx.fillStyle = \"#2e8b57\";\n    const height = clamp(((state.power - 6) / (16 - 6)) * 36, 2, 36);\n    ctx.fillRect(gx + 96, gy + 12 - height, 24, height);\n    ctx.strokeStyle = \"#9ccbbf\";\n    ctx.strokeRect(gx + 90, gy - 22, 36, 44);\n\n    // show controls text\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"12px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Arrow keys to aim, Space to zap, M toggle sound\", 12, HEIGHT - 12);\n    ctx.fillText(\"Press R to restart, P to pause\", 12, HEIGHT - 28);\n  }\n\n  function drawVolty(x, y) {\n    ctx.save();\n    ctx.translate(x, y);\n    // head\n    ctx.fillStyle = COLORS.robot;\n    ctx.fillRect(-28, -28, 40, 36);\n    // eye / screen\n    ctx.fillStyle = \"#06292c\";\n    ctx.fillRect(-24, -22, 32, 24);\n    // smile\n    ctx.fillStyle = \"#8fe7e3\";\n    ctx.fillRect(-12, -8, 8, 4);\n    // antenna\n    ctx.beginPath();\n    ctx.strokeStyle = \"#7cc7c7\";\n    ctx.lineWidth = 3;\n    ctx.moveTo(12, -32);\n    ctx.lineTo(18, -44);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.fillStyle = \"#ffed99\";\n    ctx.arc(18, -44, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function roundRect(ctxRef, x, y, w, h, r) {\n    ctxRef.beginPath();\n    ctxRef.moveTo(x + r, y);\n    ctxRef.arcTo(x + w, y, x + w, y + h, r);\n    ctxRef.arcTo(x + w, y + h, x, y + h, r);\n    ctxRef.arcTo(x, y + h, x, y, r);\n    ctxRef.arcTo(x, y, x + w, y, r);\n    ctxRef.closePath();\n  }\n\n  function drawOrbs() {\n    // trails first\n    for (const orb of state.orbs) {\n      if (!orb.alive) continue;\n      ctx.beginPath();\n      let alpha = 0.25;\n      for (let i = orb.trail.length - 1; i >= 0; i--) {\n        const p = orb.trail[i];\n        ctx.fillStyle = `rgba(255,230,120,${alpha})`;\n        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);\n        alpha *= 0.85;\n      }\n    }\n    // draw orbs\n    for (const orb of state.orbs) {\n      if (!orb.alive) continue;\n      ctx.beginPath();\n      ctx.fillStyle = \"#ffd36b\";\n      ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);\n      ctx.fill();\n      // number\n      ctx.fillStyle = \"#2d2d2d\";\n      ctx.font = \"bold 14px monospace\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(orb.value, orb.x, orb.y + 5);\n    }\n  }\n\n  function drawUI() {\n    // top-left info panel\n    ctx.fillStyle = \"rgba(255,255,255,0.6)\";\n    roundRect(ctx, 12, 12, 280, 72, 8);\n    ctx.fill();\n    ctx.strokeStyle = \"#bfecec\";\n    ctx.stroke();\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"bold 16px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Score: ${state.score}`, 28, 36);\n    ctx.fillText(`Round: ${state.round}`, 28, 56);\n    ctx.fillText(`Lives: ${state.lives}`, 160, 56);\n\n    // message box\n    ctx.fillStyle = \"rgba(255,255,255,0.5)\";\n    roundRect(ctx, 310, 12, 398, 72, 8);\n    ctx.fill();\n    ctx.strokeStyle = \"#bfecec\";\n    ctx.stroke();\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"left\";\n    // wrap message if needed\n    const msg = state.message || \"\";\n    wrapText(ctx, msg, 326, 34, 370, 18);\n\n    // speaker icon (visual cue for audio)\n    ctx.save();\n    ctx.translate(WIDTH - 44, 36);\n    ctx.fillStyle = audioManager.enabled ? COLORS.speakerOn : COLORS.speakerOff;\n    // speaker base\n    ctx.beginPath();\n    ctx.moveTo(-12, -8);\n    ctx.lineTo(-4, -8);\n    ctx.lineTo(4, -16);\n    ctx.lineTo(4, 16);\n    ctx.lineTo(-4, 8);\n    ctx.lineTo(-12, 8);\n    ctx.closePath();\n    ctx.fill();\n    // waves if enabled\n    if (audioManager.enabled) {\n      ctx.beginPath();\n      ctx.strokeStyle = COLORS.speakerOn;\n      ctx.lineWidth = 2;\n      ctx.arc(6, 0, 6, -0.5, 0.5);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(6, 0, 10, -0.5, 0.5);\n      ctx.stroke();\n    } else {\n      // X mark when off\n      ctx.strokeStyle = COLORS.speakerOff;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(-8, -8);\n      ctx.lineTo(8, 8);\n      ctx.moveTo(8, -8);\n      ctx.lineTo(-8, 8);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Accessibility instruction block\n    ctx.fillStyle = \"rgba(255,255,255,0.4)\";\n    roundRect(ctx, 12, HEIGHT - 110, 260, 88, 8);\n    ctx.fill();\n    ctx.strokeStyle = \"#cfeeea\";\n    ctx.stroke();\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"12px sans-serif\";\n    wrapText(ctx, \"Instructions: Aim with mouse or arrow keys. Press Space to zap the number-orb into a bulb. Make each bulb's number match the target. Press M to toggle sound.\", 24, HEIGHT - 90, 232, 16);\n  }\n\n  function wrapText(ctxRef, text, x, y, maxWidth, lineHeight) {\n    const words = text.split(\" \");\n    let line = \"\";\n    let curY = y;\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + \" \";\n      const metrics = ctxRef.measureText(testLine);\n      if (metrics.width > maxWidth && n > 0) {\n        ctxRef.fillText(line, x, curY);\n        line = words[n] + \" \";\n        curY += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctxRef.fillText(line, x, curY);\n  }\n\n  // Draw characters like Sparky (a lightning bug) as a decorative friend\n  function drawSparky(x, y, t) {\n    ctx.save();\n    ctx.translate(x, y);\n    // body\n    ctx.beginPath();\n    ctx.fillStyle = \"#fef08a\";\n    ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // wings\n    ctx.beginPath();\n    ctx.fillStyle = \"#e8f6ff\";\n    ctx.ellipse(-6, -6, 6, 4, -0.5, 0, Math.PI * 2);\n    ctx.ellipse(6, -6, 6, 4, 0.5, 0, Math.PI * 2);\n    ctx.fill();\n    // antennae\n    ctx.strokeStyle = \"#6b7280\";\n    ctx.lineWidth = 1.2;\n    ctx.beginPath();\n    ctx.moveTo(-3, -6);\n    ctx.lineTo(-8, -12);\n    ctx.moveTo(3, -6);\n    ctx.lineTo(8, -12);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  // Main render\n  function render(now) {\n    // time delta roughly\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawBackground();\n    drawBulbs();\n    drawOrbs();\n    drawGenerator();\n    drawUI();\n    // decorative Sparky at top right\n    drawSparky(WIDTH - 80, 80, now);\n\n    // focus ring for keyboard accessibility\n    if (document.activeElement === canvas) {\n      ctx.strokeStyle = \"#9dd6d6\";\n      ctx.lineWidth = 2;\n      ctx.strokeRect(0.5, 0.5, WIDTH - 1, HEIGHT - 1);\n    }\n  }\n\n  // Main loop\n  let lastTime = performance.now();\n  function loop(ts) {\n    const dt = ts - lastTime;\n    lastTime = ts;\n    update(dt);\n    render(ts);\n    requestAnimationFrame(loop);\n  }\n\n  // Initialization and error handling\n  try {\n    setupRound(1);\n    requestAnimationFrame(loop);\n  } catch (err) {\n    console.error(\"Game initialization error:\", err);\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = \"#ffdddd\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = \"#600\";\n    ctx.font = \"18px sans-serif\";\n    ctx.fillText(\"An error occurred loading the game. Try reloading the page.\", 24, 40);\n  }\n\n  // Accessibility: expose a simple API on the canvas element for screen readers via title and aria\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Electricity math game. Aim and shoot number orbs to match bulbs' target numbers. Use arrow keys to aim and space to shoot. Press M to toggle sound.\");\n  canvas.title = \"Electricity Math Game: Aim with mouse or arrow keys. Space to zap. M toggles sound. Press R to restart.\";\n\n  // Provide helpful console instructions for caregivers / teachers\n  console.info(\"Electricity Math Game initialized. Controls: Arrow keys to aim, Space to shoot, M to toggle sound, R restart, P pause. Click speaker icon to toggle sound as well.\");\n\n  // Expose some functions for debugging if needed (not required)\n  window._electricMathGame = {\n    state,\n    audioManager,\n    setupRound\n  };\n})();\n---\n",
  "improve_response_tokens": 17719,
  "formatted_code": true,
  "formatting_response_tokens": 18662,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}