{
  "generated_date": "2025-08-15",
  "generated_timestamp": "2025-08-15T00:24:05.700916",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10818,
  "game_filename": "2025-08-15.js",
  "game_size_bytes": 31123,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  'use strict';\n\n  // Game for ages 7-9: \"Spark & the Electric Sum\"\n  // Renders into element with ID 'game-of-the-day-stage'\n  // Canvas 720x480. All graphics drawn via canvas methods.\n  // Audio via Web Audio API (oscillators only). Includes error handling and accessibility.\n\n  // -------------------------\n  // Utility functions\n  // -------------------------\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n  function rand(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n  function pick(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n  }\n\n  // -------------------------\n  // Setup stage and canvas\n  // -------------------------\n  const stage = document.getElementById('game-of-the-day-stage');\n  if (!stage) {\n    console.error('Element with ID \"game-of-the-day-stage\" not found. Creating one automatically.');\n    const fallback = document.createElement('div');\n    fallback.id = 'game-of-the-day-stage';\n    document.body.appendChild(fallback);\n  }\n  // Clear stage content\n  stage.innerHTML = '';\n  stage.style.outline = 'none';\n\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.tabIndex = 0; // make focusable\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Spark and the Electric Sum: use arrow keys to move Spark, space to collect electrons, click to drag electrons. Toggle sound with S. Press Enter to submit collected charge. Instructions are shown on screen.');\n  canvas.style.display = 'block';\n  canvas.style.margin = '0';\n  stage.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // -------------------------\n  // Audio setup with error handling\n  // -------------------------\n  let audioCtx = null;\n  let audioAvailable = true;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContext) throw new Error('Web Audio API not supported');\n    audioCtx = new AudioContext();\n  } catch (e) {\n    console.warn('Audio context could not be created:', e);\n    audioAvailable = false;\n  }\n\n  // Background hum nodes\n  let bgOsc = null;\n  let bgGain = null;\n  let audioOn = true; // user-controlled toggle\n\n  function safeResumeAudio() {\n    if (!audioAvailable || !audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('Audio resume failed', e);\n      });\n    }\n  }\n\n  // Sound generators\n  function playTone({ freq = 440, duration = 0.3, type = 'sine', volume = 0.12, detune = 0, filterFreq = null }) {\n    if (!audioAvailable || !audioOn) return Promise.resolve();\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      o.detune.value = detune;\n      if (filterFreq) {\n        const f = audioCtx.createBiquadFilter();\n        f.type = 'lowpass';\n        f.frequency.value = filterFreq;\n        o.connect(f);\n        f.connect(g);\n      } else {\n        o.connect(g);\n      }\n      g.gain.value = 0;\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(volume, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, now + duration);\n      o.start(now);\n      o.stop(now + duration + 0.02);\n      return Promise.resolve();\n    } catch (err) {\n      console.warn('playTone failed', err);\n      return Promise.resolve();\n    }\n  }\n\n  function playCorrectChord() {\n    if (!audioAvailable || !audioOn) return;\n    // simple arpeggio\n    const now = audioCtx.currentTime;\n    const freqs = [523.25, 659.25, 783.99]; // C5, E5, G5\n    freqs.forEach((f, i) => {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = 'triangle';\n      o.frequency.value = f;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      const t = now + i * 0.06;\n      g.gain.setValueAtTime(0.001, t);\n      g.gain.linearRampToValueAtTime(0.12, t + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.001, t + 0.28);\n      o.start(t);\n      o.stop(t + 0.3);\n    });\n  }\n\n  function playWrongBuzz() {\n    if (!audioAvailable || !audioOn) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const f = audioCtx.createBiquadFilter();\n      o.type = 'sawtooth';\n      o.frequency.value = 120;\n      f.type = 'lowpass';\n      f.frequency.value = 600;\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.001, now);\n      g.gain.linearRampToValueAtTime(0.14, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);\n      o.start(now);\n      o.stop(now + 0.36);\n    } catch (e) {\n      console.warn('playWrongBuzz failed', e);\n    }\n  }\n\n  function playPickupPluck() {\n    playTone({ freq: 880, duration: 0.12, type: 'square', volume: 0.08 });\n    playTone({ freq: 660, duration: 0.14, type: 'sine', volume: 0.06, detune: 10 });\n  }\n\n  function startBackgroundHum() {\n    if (!audioAvailable || !audioOn) return;\n    try {\n      if (bgOsc) {\n        bgOsc.stop();\n        bgOsc.disconnect();\n      }\n      bgOsc = audioCtx.createOscillator();\n      bgGain = audioCtx.createGain();\n      const f = audioCtx.createBiquadFilter();\n      f.type = 'lowpass';\n      f.frequency.value = 600;\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110; // low hum\n      bgOsc.connect(f);\n      f.connect(bgGain);\n      bgGain.connect(audioCtx.destination);\n      bgGain.gain.value = 0.02;\n      bgOsc.start();\n    } catch (e) {\n      console.warn('startBackgroundHum failed', e);\n    }\n  }\n\n  function stopBackgroundHum() {\n    try {\n      if (bgOsc) {\n        bgOsc.stop();\n        bgOsc.disconnect();\n        bgOsc = null;\n      }\n      if (bgGain) {\n        bgGain.disconnect();\n        bgGain = null;\n      }\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  if (audioAvailable) {\n    // start background when user interacts later (click/keypress)\n    audioOn = true;\n  } else {\n    audioOn = false;\n  }\n\n  // -------------------------\n  // Game constants and state\n  // -------------------------\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n\n  const PANEL_X = 540;\n  const PANEL_Y = 120;\n  const PANEL_W = 150;\n  const PANEL_H = 180;\n\n  const BULB_X = PANEL_X + PANEL_W / 2;\n  const BULB_Y = PANEL_Y + PANEL_H + 70;\n\n  let lastTime = 0;\n  let running = false;\n  let showInstructions = true;\n  let level = 1;\n  let score = 0;\n  let targetCharge = 8;\n  let currentCharge = 0;\n  let electrons = [];\n  let messages = []; // temporary messages\n  let glowTime = 0; // visual cue when sound plays\n  let controlsActive = true;\n\n  // Spark (player)\n  const spark = {\n    x: 140,\n    y: HEIGHT / 2,\n    vx: 0,\n    vy: 0,\n    radius: 32,\n    color: '#FFD66B',\n    speed: 240 // px per second\n  };\n\n  // Input state\n  const keys = {};\n  let mouse = { x: 0, y: 0, down: false, dragElectron: null };\n\n  // Accessibility: keyboard mapping note: Arrow keys move, Space collect nearest, Enter submit.\n  // Also 'S' toggles sound.\n\n  // -------------------------\n  // Game functions\n  // -------------------------\n  function resetLevel() {\n    currentCharge = 0;\n    electrons = [];\n    messages = [];\n    glowTime = 0;\n    // targetCharge increases with level but remains reasonable for age 7-9\n    targetCharge = Math.min(20, 5 + Math.floor(level * 1.7));\n    // spawn electrons - ensure there are numbers such that sums can reach target\n    // We'll generate a mix of 1..9 values\n    const count = 6 + Math.min(4, level);\n    for (let i = 0; i < count; i++) {\n      const v = generateElectronValue(i);\n      const e = {\n        id: Math.random().toString(36).slice(2),\n        x: rand(220, 480),\n        y: rand(60, HEIGHT - 80),\n        r: 22,\n        vx: rand(-30, 30),\n        vy: rand(-20, 20),\n        value: v,\n        grabbed: false,\n        beingSent: false,\n        sendT: 0\n      };\n      electrons.push(e);\n    }\n    // ensure solvable: include at least one electron equal to target or combination possible:\n    // add one electron equal to target if small enough\n    if (targetCharge <= 9 && !electrons.some(e => e.value === targetCharge)) {\n      electrons.push({\n        id: 'guarantee',\n        x: rand(260, 400),\n        y: rand(80, HEIGHT - 100),\n        r: 22,\n        vx: 0,\n        vy: 0,\n        value: targetCharge,\n        grabbed: false,\n        beingSent: false,\n        sendT: 0\n      });\n    }\n\n    // Provide gentle audio cue\n    if (audioAvailable && audioOn) {\n      playTone({ freq: 300 + targetCharge * 8, duration: 0.18, type: 'sine', volume: 0.06 });\n    }\n  }\n\n  function generateElectronValue(i) {\n    // make more smaller numbers; occasionally bigger\n    const base = Math.random();\n    if (base < 0.5) return Math.floor(rand(1, 5)); // 1-4\n    if (base < 0.85) return Math.floor(rand(4, 8)); // 4-7\n    return Math.floor(rand(7, 10)); // 7-9\n  }\n\n  function addMessage(text, duration = 1600) {\n    messages.push({ text, t: duration });\n  }\n\n  function collectNearestElectron() {\n    // find nearest electron within range\n    let nearest = null;\n    let nd = Infinity;\n    for (const e of electrons) {\n      if (e.beingSent) continue;\n      const dx = e.x - spark.x;\n      const dy = e.y - spark.y;\n      const d = Math.hypot(dx, dy);\n      if (d < nd) {\n        nd = d;\n        nearest = e;\n      }\n    }\n    if (nearest && nd <= 90) {\n      pickUpElectron(nearest);\n    } else {\n      addMessage('Too far! Move closer to collect electrons.');\n      playWrongBuzz();\n    }\n  }\n\n  function pickUpElectron(e) {\n    if (e.grabbed || e.beingSent) return;\n    e.grabbed = true;\n    if (audioAvailable && audioOn) playPickupPluck();\n    addMessage('Electron ' + e.value + ' collected!');\n  }\n\n  function submitCharge() {\n    // send current electrons to panel -> but we instead sum values of electrons that were pulled to panel\n    // In this implementation, pressing Enter will \"submit\" the currentCharge (we update when sending electrons)\n    // We only check equal/exceed logic here:\n    if (currentCharge === targetCharge) {\n      // success!\n      addMessage('Perfect! Bulb lit! +1 level');\n      score += 10 * level;\n      level++;\n      glowTime = 0.8;\n      if (audioAvailable && audioOn) playCorrectChord();\n      resetLevel();\n    } else if (currentCharge < targetCharge) {\n      addMessage('Not enough charge. Try adding more electrons.');\n      if (audioAvailable && audioOn) playTone({ freq: 260, duration: 0.18, type: 'sine', volume: 0.08 });\n    } else {\n      // overcharged\n      addMessage('Oh no, you overloaded the bulb! It popped! -1 level');\n      score = Math.max(0, score - 5);\n      level = Math.max(1, level - 1);\n      if (audioAvailable && audioOn) playWrongBuzz();\n      resetLevel();\n    }\n  }\n\n  function sendElectronToPanel(e) {\n    e.beingSent = true;\n    e.sendStart = { x: e.x, y: e.y };\n    e.sendT = 0;\n    if (audioAvailable && audioOn) playTone({ freq: 880 - e.value * 20, duration: 0.18, type: 'sine', volume: 0.06 });\n  }\n\n  // -------------------------\n  // Drawing functions\n  // -------------------------\n  function drawBackground() {\n    // calming gradient background with wacky swirls\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#e8f7ff');\n    g.addColorStop(1, '#f5fff7');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // soft circuit pattern (light)\n    ctx.save();\n    ctx.globalAlpha = 0.06;\n    ctx.strokeStyle = '#8cf0ff';\n    ctx.lineWidth = 2;\n    for (let i = 0; i < 8; i++) {\n      ctx.beginPath();\n      const y = 20 + i * 55;\n      ctx.moveTo(0, y);\n      ctx.bezierCurveTo(150, y + 20, 300, y - 20, WIDTH, y + 10);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawPanel() {\n    // Power panel on the right\n    ctx.save();\n    // panel background\n    ctx.fillStyle = '#2d3b4a';\n    roundRect(ctx, PANEL_X, PANEL_Y, PANEL_W, PANEL_H, 12);\n    ctx.fill();\n\n    // label\n    ctx.fillStyle = '#ffffff';\n    ctx.font = 'bold 16px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Power Panel', PANEL_X + PANEL_W / 2, PANEL_Y + 24);\n\n    // target display\n    ctx.fillStyle = '#0fffcf';\n    ctx.font = 'bold 28px sans-serif';\n    ctx.fillText('Need: ' + targetCharge, PANEL_X + PANEL_W / 2, PANEL_Y + 64);\n\n    // current charge gauge\n    ctx.fillStyle = '#222';\n    roundRect(ctx, PANEL_X + 18, PANEL_Y + 78, PANEL_W - 36, 26, 8);\n    ctx.fill();\n    const pct = clamp(currentCharge / Math.max(targetCharge, 1), 0, 1);\n    ctx.fillStyle = '#00ff9e';\n    roundRect(ctx, PANEL_X + 18, PANEL_Y + 78, (PANEL_W - 36) * pct, 26, 8);\n    ctx.fill();\n\n    // gauge text\n    ctx.fillStyle = '#fff';\n    ctx.font = 'bold 18px sans-serif';\n    ctx.fillText('Charge: ' + currentCharge, PANEL_X + PANEL_W / 2, PANEL_Y + 98);\n\n    ctx.restore();\n  }\n\n  function drawBulb() {\n    // bulb character\n    ctx.save();\n    // base wires\n    ctx.strokeStyle = '#e8ffea';\n    ctx.lineWidth = 4;\n    ctx.beginPath();\n    ctx.moveTo(BULB_X - 48, BULB_Y + 36);\n    ctx.lineTo(BULB_X - 10, BULB_Y + 36);\n    ctx.moveTo(BULB_X + 48, BULB_Y + 36);\n    ctx.lineTo(BULB_X + 10, BULB_Y + 36);\n    ctx.stroke();\n\n    // bulb glass\n    const lit = currentCharge >= targetCharge && currentCharge === targetCharge;\n    const bulbGlow = glowTime > 0 ? Math.min(1, glowTime * 1.6) : (lit ? 1 : 0);\n\n    // soft glow\n    if (bulbGlow > 0) {\n      ctx.beginPath();\n      const rg = ctx.createRadialGradient(BULB_X, BULB_Y - 10, 8, BULB_X, BULB_Y - 10, 120);\n      rg.addColorStop(0, `rgba(255,230,120,${0.8 * bulbGlow})`);\n      rg.addColorStop(1, `rgba(255,230,120,0)`);\n      ctx.fillStyle = rg;\n      ctx.fillRect(BULB_X - 120, BULB_Y - 120, 240, 240);\n    }\n\n    // bulb outline\n    ctx.beginPath();\n    ctx.fillStyle = lit ? '#fff6b3' : '#ffffff';\n    ctx.strokeStyle = '#aaa';\n    ctx.lineWidth = 2;\n    ctx.ellipse(BULB_X, BULB_Y - 10, 36, 50, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // filament (friendly face)\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(BULB_X - 10, BULB_Y - 18, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(BULB_X + 10, BULB_Y - 18, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#333';\n    ctx.beginPath();\n    ctx.moveTo(BULB_X - 8, BULB_Y - 6);\n    ctx.quadraticCurveTo(BULB_X, BULB_Y + 2, BULB_X + 8, BULB_Y - 6);\n    ctx.stroke();\n\n    // base\n    ctx.fillStyle = '#667';\n    roundRect(ctx, BULB_X - 20, BULB_Y + 18, 40, 24, 6);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawSpark() {\n    ctx.save();\n    // shadow\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(0,0,0,0.08)';\n    ctx.ellipse(spark.x, spark.y + 38, 28, 10, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body - magnet-like friendly robot\n    ctx.beginPath();\n    ctx.fillStyle = spark.color;\n    ctx.strokeStyle = '#d08f2a';\n    ctx.lineWidth = 2;\n    ctx.ellipse(spark.x, spark.y - 6, spark.radius, spark.radius + 6, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // eyes\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(spark.x - 10, spark.y - 14, 5, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(spark.x + 10, spark.y - 14, 5, 0, Math.PI * 2);\n    ctx.fill();\n\n    // mouth smile\n    ctx.beginPath();\n    ctx.strokeStyle = '#3b3b3b';\n    ctx.lineWidth = 2;\n    ctx.arc(spark.x, spark.y - 2, 8, 0, Math.PI);\n    ctx.stroke();\n\n    // magnet prongs - goofy\n    ctx.fillStyle = '#ff7b7b';\n    ctx.fillRect(spark.x - 30, spark.y + 14, 12, 10);\n    ctx.fillRect(spark.x + 18, spark.y + 14, 12, 10);\n    ctx.strokeStyle = '#b24b4b';\n    ctx.strokeRect(spark.x - 30, spark.y + 14, 12, 10);\n    ctx.strokeRect(spark.x + 18, spark.y + 14, 12, 10);\n\n    // range indicator for collection (when focused)\n    ctx.strokeStyle = 'rgba(255,255,255,0.35)';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.ellipse(spark.x, spark.y + 6, 90, 90, 0, 0, Math.PI * 2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  function drawElectron(e) {\n    ctx.save();\n    // body\n    const g = ctx.createRadialGradient(e.x - 6, e.y - 6, 4, e.x + 6, e.y + 6, e.r + 6);\n    g.addColorStop(0, '#fffef0');\n    g.addColorStop(0.2, '#a0ffee');\n    g.addColorStop(1, '#72d1ff');\n    ctx.fillStyle = g;\n    ctx.beginPath();\n    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#2d94b6';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // number\n    ctx.fillStyle = '#073042';\n    ctx.font = 'bold 16px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(e.value), e.x, e.y + 1);\n\n    // tail or spark\n    ctx.beginPath();\n    ctx.strokeStyle = 'rgba(255,255,255,0.4)';\n    ctx.moveTo(e.x - e.r + 2, e.y - e.r + 2);\n    ctx.lineTo(e.x - e.r - 10, e.y - e.r - 10);\n    ctx.stroke();\n\n    // highlight when grabbed\n    if (e.grabbed) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 3;\n      ctx.globalAlpha = 0.5;\n      ctx.arc(e.x, e.y, e.r + 6, 0, Math.PI * 2);\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n\n    ctx.restore();\n  }\n\n  function drawUI() {\n    // top bar: score, level, instructions icon, sound icon\n    ctx.save();\n    ctx.fillStyle = 'rgba(0,0,0,0.06)';\n    roundRect(ctx, 8, 8, WIDTH - 16, 48, 12);\n    ctx.fill();\n\n    ctx.fillStyle = '#073042';\n    ctx.font = 'bold 18px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Score: ' + score, 20, 34);\n    ctx.fillText('Level: ' + level, 140, 34);\n\n    // instructions toggle text\n    ctx.font = '14px sans-serif';\n    ctx.fillStyle = '#01303a';\n    ctx.fillText(showInstructions ? 'Press H to hide help' : 'Press H to show help', 220, 34);\n\n    // sound icon\n    const sx = WIDTH - 80;\n    const sy = 18;\n    ctx.fillStyle = audioOn ? '#ffdd57' : '#c4c4c4';\n    ctx.beginPath();\n    ctx.moveTo(sx, sy + 6);\n    ctx.lineTo(sx + 12, sy + 6);\n    ctx.lineTo(sx + 22, sy);\n    ctx.lineTo(sx + 22, sy + 36);\n    ctx.lineTo(sx + 12, sy + 30);\n    ctx.lineTo(sx, sy + 30);\n    ctx.closePath();\n    ctx.fill();\n    ctx.strokeStyle = '#6c4f18';\n    ctx.stroke();\n\n    ctx.fillStyle = '#01303a';\n    ctx.textAlign = 'center';\n    ctx.font = '12px sans-serif';\n    ctx.fillText(audioOn ? 'Sound On (S)' : 'Muted (S)', sx + 11, sy + 46);\n\n    // instructions summary (if enabled)\n    if (showInstructions) {\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      roundRect(ctx, 16, 66, 380, 120, 10);\n      ctx.fillStyle = '#01303a';\n      ctx.font = '14px sans-serif';\n      ctx.textAlign = 'left';\n      wrapText(ctx, 'Goal: Collect electrons (numbers) to match the panel target charge exactly. Move Spark with arrow keys or mouse. Press SPACE to collect nearest electron, drag electrons with the mouse, press ENTER to submit your charge.', 24, 86, 360, 18);\n      ctx.fillStyle = '#015a4a';\n      ctx.font = 'bold 13px sans-serif';\n      ctx.fillText('Controls: Arrows = move, Space = collect, Click/Drag = move electron, Enter = submit', 24, 160);\n    }\n\n    ctx.restore();\n  }\n\n  // Helper: rounded rect\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Helper: wrap text\n  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = text.split(' ');\n    let line = '';\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + ' ';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > maxWidth && n > 0) {\n        ctx.fillText(line, x, y);\n        line = words[n] + ' ';\n        y += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line, x, y);\n  }\n\n  // -------------------------\n  // Game update loop\n  // -------------------------\n  function update(dt) {\n    // update spark from keys\n    let moveX = 0;\n    let moveY = 0;\n    if (keys['ArrowLeft']) moveX -= 1;\n    if (keys['ArrowRight']) moveX += 1;\n    if (keys['ArrowUp']) moveY -= 1;\n    if (keys['ArrowDown']) moveY += 1;\n    if (moveX !== 0 || moveY !== 0) {\n      const len = Math.hypot(moveX, moveY) || 1;\n      spark.x += (moveX / len) * spark.speed * dt;\n      spark.y += (moveY / len) * spark.speed * dt;\n    }\n    // mouse movement when dragging spark: if focused and mouse down but not dragging electron, spark follows\n    if (mouse.down && !mouse.dragElectron) {\n      // smooth follow\n      spark.x += (mouse.x - spark.x) * 8 * dt;\n      spark.y += (mouse.y - spark.y) * 8 * dt;\n    }\n\n    // clamp spark within left half to encourage movement\n    spark.x = clamp(spark.x, 60, WIDTH - 220);\n    spark.y = clamp(spark.y, 60, HEIGHT - 60);\n\n    // update electrons\n    for (const e of electrons) {\n      if (e.beingSent) {\n        // animate along curve to panel center\n        e.sendT += dt * 1.6;\n        const t = clamp(e.sendT, 0, 1);\n        const sx = e.sendStart.x;\n        const sy = e.sendStart.y;\n        // simple quadratic curve to BULB position\n        const cx = (sx + BULB_X) / 2 + rand(-30, 30);\n        const cy = Math.min(sy, BULB_Y) - 60;\n        // Quadratic Bezier interpolation\n        e.x = (1 - t) * (1 - t) * sx + 2 * (1 - t) * t * cx + t * t * BULB_X;\n        e.y = (1 - t) * (1 - t) * sy + 2 * (1 - t) * t * cy + t * t * BULB_Y;\n        e.r = 20 * (1 - 0.2 * t);\n        if (t >= 1) {\n          // reached panel - add value\n          currentCharge += e.value;\n          // remove electron\n          e.toRemove = true;\n          if (audioAvailable && audioOn) {\n            playTone({ freq: 520 + e.value * 16, duration: 0.14, type: 'sine', volume: 0.06 });\n          }\n        }\n      } else if (e.grabbed) {\n        // follow spark\n        e.x += (spark.x + 18 - e.x) * 12 * dt;\n        e.y += (spark.y - 8 - e.y) * 12 * dt;\n        // if close to panel area, send to panel\n        const dx = e.x - (PANEL_X + PANEL_W / 2);\n        const dy = e.y - (PANEL_Y + PANEL_H / 2);\n        if (Math.hypot(dx, dy) < 54) {\n          sendElectronToPanel(e);\n          e.grabbed = false;\n        }\n      } else if (mouse.dragElectron && mouse.dragElectron.id === e.id) {\n        // follow mouse coordinates when manual dragging\n        e.x = mouse.x;\n        e.y = mouse.y;\n      } else {\n        // free movement\n        e.x += e.vx * dt;\n        e.y += e.vy * dt;\n        // bounce\n        if (e.x < 60 || e.x > PANEL_X - 30) e.vx *= -1;\n        if (e.y < 80 || e.y > HEIGHT - 80) e.vy *= -1;\n      }\n    }\n    // remove electrons marked for removal\n    electrons = electrons.filter(e => !e.toRemove);\n\n    // messages decay\n    for (const m of messages) {\n      m.t -= dt * 1000;\n    }\n    messages = messages.filter(m => m.t > 0);\n\n    // glowTime decay\n    if (glowTime > 0) glowTime = Math.max(0, glowTime - dt);\n\n    // Occasionally spawn a wandering electron to keep things playful\n    if (Math.random() < dt * 0.2 && electrons.length < 10) {\n      electrons.push({\n        id: Math.random().toString(36).slice(2),\n        x: rand(220, 440),\n        y: rand(60, HEIGHT - 80),\n        r: 20,\n        vx: rand(-20, 20),\n        vy: rand(-20, 20),\n        value: Math.floor(rand(1, 9)),\n        grabbed: false,\n        beingSent: false,\n        sendT: 0\n      });\n    }\n  }\n\n  function render() {\n    drawBackground();\n    drawPanel();\n    drawBulb();\n\n    // connector wires from panel to bulb\n    ctx.save();\n    ctx.strokeStyle = '#5df0c8';\n    ctx.lineWidth = 4;\n    ctx.beginPath();\n    ctx.moveTo(PANEL_X + PANEL_W / 2 - 10, PANEL_Y + PANEL_H);\n    ctx.quadraticCurveTo(PANEL_X + PANEL_W / 2 + 30, PANEL_Y + PANEL_H + 80, BULB_X - 20, BULB_Y + 30);\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(PANEL_X + PANEL_W / 2 + 10, PANEL_Y + PANEL_H);\n    ctx.quadraticCurveTo(PANEL_X + PANEL_W / 2 - 40, PANEL_Y + PANEL_H + 80, BULB_X + 20, BULB_Y + 30);\n    ctx.stroke();\n    ctx.restore();\n\n    // electrons under other elements\n    for (const e of electrons) {\n      drawElectron(e);\n    }\n\n    drawSpark();\n\n    // messages\n    ctx.save();\n    ctx.textAlign = 'center';\n    ctx.font = 'bold 16px sans-serif';\n    ctx.fillStyle = '#05323a';\n    let mmY = HEIGHT - 40;\n    for (const m of messages) {\n      ctx.globalAlpha = clamp(m.t / 1200, 0, 1);\n      ctx.fillText(m.text, WIDTH / 2, mmY);\n      mmY -= 22;\n    }\n    ctx.globalAlpha = 1;\n    ctx.restore();\n\n    // draw UI overlays\n    drawUI();\n\n    // bottom instructions: interactive hints\n    ctx.save();\n    ctx.fillStyle = 'rgba(1,48,52,0.06)';\n    roundRect(ctx, 12, HEIGHT - 72, 420, 56, 8);\n    ctx.fill();\n    ctx.fillStyle = '#025b54';\n    ctx.font = 'bold 14px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Tip: Match numbers exactly to light the bulb. Overcharging pops it!', 24, HEIGHT - 44);\n    ctx.fillText('Click an electron to drag it or press SPACE near one.', 24, HEIGHT - 24);\n    ctx.restore();\n\n    // visual cue for audio events (when glowTime)\n    if (glowTime > 0) {\n      ctx.save();\n      ctx.globalAlpha = clamp(glowTime, 0, 1) * 0.8;\n      ctx.fillStyle = '#fff6b3';\n      ctx.beginPath();\n      ctx.ellipse(BULB_X, BULB_Y - 10, 100 * glowTime, 140 * glowTime, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // show helpful overlay when paused or on instructions\n    if (!running) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(0,0,0,0.46)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 28px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Spark & the Electric Sum', WIDTH / 2, HEIGHT / 2 - 40);\n      ctx.font = '18px sans-serif';\n      ctx.fillText('Click to start! Use arrow keys, space, enter. S to toggle sound.', WIDTH / 2, HEIGHT / 2 + 4);\n      ctx.restore();\n    }\n  }\n\n  function gameLoop(ts) {\n    if (!lastTime) lastTime = ts;\n    const dt = Math.min(0.05, (ts - lastTime) / 1000);\n    lastTime = ts;\n    if (running) update(dt);\n    render();\n    requestAnimationFrame(gameLoop);\n  }\n\n  // -------------------------\n  // Input handlers\n  // -------------------------\n  function onKeyDown(e) {\n    // Accessibility: allow starting audio on first user gesture\n    safeResumeAudio();\n    if (!audioAvailable) {\n      // do nothing\n    }\n    keys[e.key] = true;\n\n    if (e.key === ' ' || e.key === 'Spacebar') {\n      e.preventDefault();\n      collectNearestElectron();\n    } else if (e.key === 'Enter') {\n      submitCharge();\n    } else if (e.key === 's' || e.key === 'S') {\n      audioOn = !audioOn;\n      if (!audioOn) stopBackgroundHum();\n      else startBackgroundHum();\n      glowTime = 0.5;\n    } else if (e.key === 'h' || e.key === 'H') {\n      showInstructions = !showInstructions;\n    } else if (!running) {\n      // start game on any other key\n      startGame();\n    }\n  }\n\n  function onKeyUp(e) {\n    keys[e.key] = false;\n  }\n\n  function onMouseDown(e) {\n    safeResumeAudio();\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = e.clientX - rect.left;\n    mouse.y = e.clientY - rect.top;\n    mouse.down = true;\n\n    // check if clicked an electron\n    for (let i = electrons.length - 1; i >= 0; i--) {\n      const el = electrons[i];\n      const d = Math.hypot(el.x - mouse.x, el.y - mouse.y);\n      if (d <= el.r + 6) {\n        mouse.dragElectron = el;\n        el.grabbed = false;\n        el.beingSent = false;\n        return;\n      }\n    }\n\n    // if clicked start overlay, start\n    if (!running) {\n      startGame();\n    }\n  }\n\n  function onMouseMove(e) {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = e.clientX - rect.left;\n    mouse.y = e.clientY - rect.top;\n    // for keyboard-less users, let spark follow pointer when not dragging electron and mouse pressed\n    if (!mouse.down) {\n      // no auto-follow to avoid annoyances\n    }\n  }\n\n  function onMouseUp(e) {\n    mouse.down = false;\n    // release dragged electron\n    if (mouse.dragElectron) {\n      // if near panel center, send to panel\n      const el = mouse.dragElectron;\n      const dx = el.x - (PANEL_X + PANEL_W / 2);\n      const dy = el.y - (PANEL_Y + PANEL_H / 2);\n      if (Math.hypot(dx, dy) < 54) {\n        sendElectronToPanel(el);\n      } else {\n        // drop where released\n      }\n      mouse.dragElectron = null;\n    }\n  }\n\n  // click on canvas for toggles such as sound or instructions\n  function onClick(e) {\n    const rect = canvas.getBoundingClientRect();\n    const cx = e.clientX - rect.left;\n    const cy = e.clientY - rect.top;\n\n    // detect click on sound icon area\n    const sx = WIDTH - 80;\n    const sy = 18;\n    if (cx >= sx - 4 && cx <= sx + 40 && cy >= sy - 4 && cy <= sy + 64) {\n      audioOn = !audioOn;\n      if (!audioOn) stopBackgroundHum();\n      else startBackgroundHum();\n      return;\n    }\n\n    // toggle show instructions by clicking the instructions panel\n    if (cx >= 16 && cx <= 396 && cy >= 66 && cy <= 186) {\n      showInstructions = !showInstructions;\n    }\n  }\n\n  // -------------------------\n  // Game start/stop\n  // -------------------------\n  function startGame() {\n    running = true;\n    showInstructions = false;\n    lastTime = 0;\n    level = Math.max(1, level);\n    score = Math.max(0, score);\n    resetLevel();\n    safeResumeAudio();\n    if (audioAvailable && audioOn) startBackgroundHum();\n    addMessage('Welcome Spark! Match the number to light the bulb.');\n  }\n\n  // initialize and attach events\n  canvas.addEventListener('keydown', onKeyDown);\n  canvas.addEventListener('keyup', onKeyUp);\n  canvas.addEventListener('mousedown', onMouseDown);\n  window.addEventListener('mousemove', onMouseMove);\n  window.addEventListener('mouseup', onMouseUp);\n  canvas.addEventListener('click', onClick);\n\n  // Prevent losing focus on click (for keyboard)\n  canvas.addEventListener('blur', function () {\n    // clear keys to avoid stuck controls\n    for (const k in keys) keys[k] = false;\n  });\n\n  // Make sure the canvas is focused for keyboard controls\n  canvas.addEventListener('mouseenter', function () {\n    canvas.focus();\n  });\n\n  // Start rendering loop\n  requestAnimationFrame(gameLoop);\n\n  // Helpful startup visual instructions for screen readers / users without canvas access\n  try {\n    if ('ariaLabel' in canvas) {\n      // already set above\n    }\n  } catch (e) {\n    // ignore\n  }\n\n  // Small accessibility feature: provide keyboard help if no pointer events or if tabbed\n  canvas.addEventListener('focus', function () {\n    // show instructions briefly when focused\n    showInstructions = true;\n    setTimeout(() => {\n      showInstructions = false;\n    }, 3500);\n  });\n\n  // Expose simple API on the canvas element for testing or accessibility tools\n  canvas.gameState = {\n    get score() {\n      return score;\n    },\n    get level() {\n      return level;\n    },\n    get targetCharge() {\n      return targetCharge;\n    },\n    get currentCharge() {\n      return currentCharge;\n    }\n  };\n\n  // End of game code\n})();\n---\n",
  "improve_response_tokens": 22659,
  "formatted_code": true,
  "formatting_response_tokens": 25160,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}